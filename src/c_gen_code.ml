(*
    This file is a part of ficus language project.
    See ficus/LICENSE for the licensing terms
*)

(*
    Converts K-form into C-form (see c_form.ml).
    We assume that K-form has been prepared for the conversion,
    i.e. lambda lifting has been performed, all the complex
    data structures, such as records, tuple, lists etc. have
    been converted to KTypName(...) etc.

    The algorithm:
        1. do the 1st pass through the K-form, convert all the types and exceptions (see c_gen_types.ml).
        2. do the 2nd pass through the K-form, generate headers for all the functions.
            - each function gets extra "free variables"/"closure data" parameter fx_fv, even if it's not used.
            - the return value becomes the output parameter fx_result (before the closure pointer).
            - the function gets "int" return value, the status.
        3. do the 3rd pass through the K-form:
            - convert body of each function to C-form
            - put all the global calculations to a dedicated function _fx_init();
              all the intermediate values, used at the global scope, are moved to this function as well.
            - put all the global c-code fragments into a separate code sequence.
        4. output the final C code as concatenation of the following parts (in this particular order):
            - preamble (some general comment about autogenerated file + #include "ficus/ficus.h")
            - all the global c code
            - forward declarations of some types and their destructors
            - declarations of all the types and their helper functions (constructors, destructors, copy operators)
            - declarations of all the exceptions and their constructors
            - declarations of the global variables together with their default initializers.
            - forward declarations of some functions
            - declarations and definitions of all the functions
            - the function "int _fx_init(void) {...}"
            _ the function main() that initializes runtime, calls _fx_init() and returns its value.

    The transformed K-form as a recursive tree of expressions. So the basic element, workhorse
    of the conversion algorithm is the function to convert K expression to C code.

    We maintain and recursively pass the following compiler state:
    - C code generated so far. Just like in k_normalize.ml, this is the reverse list of c statements.
      We add new elements to the beginning of it and then reverse the produced list in the end.
    - The "catch" label stack. In the beginning of new function we push the default "cleanup" label
      for that function and pop in the end. We also push-pop a new label when we translate
      try {} catch {} block. In principle, we can use dedicated catch labels in some other nested statements,
      like for(), if() etc. For simplicity we do not do that, at the expense of slightly higher
      overhead imposed by the single big cleanup section per function. After we employ the inline function
      call optimization, the relative overhead of the cleanup sections should decrease.
      In the catch blocks we jump to the underlying label in the stack,
      thus providing the exception propagation mechanism.
    - the map of id->cexp_t pairs. It does not make sense to represent all the values in K form as C variables.
      If the value (id) is:
      1. used just once
      2. immutable (val, not var)
      3. a result of expression, which operands are also values
      then the id can be just replaced with the expression in C-form.
    - the name of currently processed function (noid in the case of global/module scope expressions).
      First of all, it helps us to detect and efficiently translate the recursive calls of the function itself:

      int _fx_foo(...args..., void* fx_fv) {... _fx_foo(...new_args..., fx_fv); } // just pass fx_fv directly

      It also lets us to distinguish between 2 cases: global and non-global. We need to handle
      KDefVal() differently, depending on the context.
    - id of the value to store the result at, or noid.
        - when the translated kexp_t has type KTypVoid, no output value is needed.
        - in some other cases, there is no pre-defined id.
          Then we need to generate a new temporary id and store the result there.
          Or even postpone the temporary value assignment and put the pair (id, cexp) to the map.
        - in some cases we are given the pre-defined id.
        - For example, the function body expression result should be stored in fx_result.
        - When we have K-form code "var x=val0; ... x=new_val;", new_val should be stored in x,
          no need to generate a temporary value, because we want to avoid unnecessary data copying.
        - "record.f = new_val", "arr[idx] += newval" etc. are other such cases. In those cases we
          use a TEMP_REF val that is the pointer to the proper record field or array element.
          However, in those cases we will try to generate idiomatic C code, e.g. "record.f = new_val",
          not the direct replication of K-form: "sometype* pf /* TEMP_REF */ = &record.f; *pf = new_val"
*)
open Ast
open K_form
open C_form

let make_label basename sc loc =
    let li = gen_temp_idc basename in
    let cname = if basename = "cleanup" then "_fx_cleanup"
        else (sprintf "_fx_%s%d" basename (id2idx li)) in
    set_idc_entry li (CLabel {cl_name=li; cl_cname=cname; cl_scope=sc; loc=loc});
    (li, CStmtLabel(li, loc))

(* Finds a set of immutable values that can potentially be replaced
   with the expressions that they are initalized with, e.g.

   val b = a + 1; foo(b)
   can be replaced with foo(a+1).

   Here we find a superset of such values, i.e. a set of values
   that are used just once. If a value is used more than once, it makes
   sense to store it in a temporary variable.

   Later on we shrink this superset. We check that their initialization
   expressions can be represented as pure (w.o side effects) scalar C expressions.
   This is a recursive rule that cannot be checked at this stage.
*)
let find_single_use_vals topcode =
    (let count_map = ref (Env.empty: int env_t) in
    let decl_const_vals = ref (IdSet.empty) in
    let rec count_atom a loc callb =
        match a with
        | Atom.Id i ->
            if IdSet.mem i !decl_const_vals then
                let n = match (Env.find_opt i !count_map) with
                    | Some(n) -> n
                    | _ -> 0
                in count_map := Env.add i (n+1) !count_map
            else ()
        | _ -> ()
    and count_ktyp t loc callb = ()
    and count_kexp e callb =
        (* we put to decl_const_vals only the values declared with
           "val" operator, which means they are declared by
           user or are temporary intermediate values.
           we do not put there function parameters and
           loop counters, because they cannot be replaced with
           any expressions. They themselves are expressions.
        *)
        match e with
        | KDefVal(k, e1, loc) ->
            decl_const_vals := IdSet.add k !decl_const_vals;
            count_kexp e1 callb
        | _ -> fold_kexp e callb
    in count_callb =
    {
        kcb_fold_typ=Some(count_ktyp);
        kcb_fold_exp=Some(count_kexp);
        kcb_fold_atom=Some(count_atom);
        kcb_result=0
    } in
    List.iter (fun e -> count_kexp e) topcode;
    IdSet.filter (fun i -> match (Env.find_opt i !count_map) with Some 1 -> true | _ -> false) !decl_const_vals)

type block_ctx_t =
{
    bctx_scope: scope_t list;
    bctx_label: id_t;
    mutable bctx_prologue: cstmt_t list;
    mutable bctx_cleanup: cstmt_t list
}

let gen_ccode topcode =
    let i2e = ref (Env.empty: cexp_t env_t) in
    let u1vals = find_single_use_vals topcode in
    let block_stack = ref ([]: block_ctx_t list) in

    let add_complex_val i ctyp e0 loc =

    let rec kexp2cexp e dstid ccode sc =
        let fname = match sc with ScFun f :: _ -> f | _ -> noid in
        let (ktyp, kloc) = get_kexp_ctx e in
        let dummy_exp = CExpSeq([], (CTypVoid, kloc)) in
        match e with
        | KExpNop _ -> (dummy_exp, ccode, i2e)
        | KExpBreak _ -> (dummy_exp, ((CStmtBreak kloc) :: ccode), i2e)
        | KExpContinue _ -> (dummy_exp, ((CStmtContinue kloc) :: ccode), i2e)
        | KExpAtom(a, _) ->
            match a with
            | Atom.Lit(l) ->
                match l with
                | LitString s -> (* generate temporary variable, initialize it with fx_make_str() *)
            (* [TODO] *) raise_compile_err kloc "cgen: unsupported KExpAtom"
        | KExpBinOp(bop, e1, e2, _) -> raise_compile_err kloc "cgen: unsupported KExpBinOp"
        | KExpUnOp(uop, e1, _) -> raise_compile_err kloc "cgen: unsupported KExpUnOp"
        | KExpIntrin(intr, args, _) -> raise_compile_err kloc "cgen: unsupported KExpIntrin"
        | KExpSeq(el, _) -> raise_compile_err kloc "cgen: unsupported KExpSeq"
        | KExpIf(c, e1, e2, _) -> raise_compile_err kloc "cgen: unsupported KExpIf"
        | KExpCall(f, args, _) -> raise_compile_err kloc "cgen: unsupported KExpCall"
        | KExpMkTuple(args, _) -> raise_compile_err kloc "cgen: unsupported KExpMkTuple"
        | KExpMkRecord(args, _) -> raise_compile_err kloc "cgen: unsupported KExpMkRecord"
        | KExpMkClosure(f, fcv, args, _) -> raise_compile_err kloc "cgen: unsupported KExpMkClosure"
        | KExpMkArray(shape, elems, _) -> raise_compile_err kloc "cgen: unsupported KExpMkArray"
        | KExpAt(a, idxs, _) -> raise_compile_err kloc "cgen: unsupported KExpAt"
        | KExpMem(a, n, _) -> raise_compile_err kloc "cgen: unsupported KExpMem"
        | KExpDeref(a, _) -> raise_compile_err kloc "cgen: unsupported KExpDeref"
        | KExpAssign(i, e1, _) -> raise_compile_err kloc "cgen: unsupported KExpAssign"
        | KExpMatch(cases, _) -> raise_compile_err kloc "cgen: unsupported KExpMatch"
        | KExpTryCatch(try_e, catch_e, _) -> raise_compile_err kloc "cgen: unsupported KExpCatch"
        | KExpThrow(i, _) -> raise_compile_err kloc "cgen: unsupported KExpThrow"
        | KExpCast(a, kt, _) -> raise_compile_err kloc "cgen: unsupported KExpCast"
        | KExpMap(e_kdl_l, body, flags, _) -> raise_compile_err kloc "cgen: unsupported KExpMap"
        | KExpFor(kdl, body, flags, _) -> raise_compile_err kloc "cgen: unsupported KExpFor"
        | KExpWhile(c, body, _) -> raise_compile_err kloc "cgen: unsupported KExpWhile"
        | KExpDoWhile(body, c, _) -> raise_compile_err kloc "cgen: unsupported KExpDoWhile"
        | KExpCCode(ccode_str, _) -> raise_compile_err kloc "cgen: unsupported KExpCCode"
        | KDefVal(i, e1, _) -> raise_compile_err kloc "cgen: unsupported KDefVal"
        | KDefFun kf -> raise_compile_err kloc "cgen: unsupported KDefFun"
        | KDefExn ke -> raise_compile_err kloc "cgen: unsupported KDefExn"
        | KDefVariant kvar -> (ccode, i2e) (* handled in c_gen_types *)
        | KDefTyp kt -> (ccode, i2e) (* handled in c_gen_types *)
        | KDefClosureVars kcv -> raise_compile_err kloc "cgen: unsupported KDefClosureVars"
    in ...

let convert_to_c top_code =
    let c_types_ccode = C_gen_types.convert_all_typs top_code in
