(*
    This file is a part of ficus language project.
    See ficus/LICENSE for the licensing terms
*)

(*
    Converts K-form into C-form (see c_form.ml).
    We assume that K-form has been prepared for the conversion,
    i.e. lambda lifting has been performed, all the complex
    data structures, such as records, tuple, lists etc. have
    been converted to KTypName(...) etc.

    The algorithm:
        1. do the 1st pass through the K-form, convert all the types and exceptions (see c_gen_types.ml).
        2. do the 2nd pass through the K-form, generate headers for all the functions.
            - each function gets extra "free variables"/"closure data" parameter fx_fv, even if it's not used.
            - the return value becomes the output parameter fx_result (before the closure pointer).
            - the function gets "int" return value, the status.
        3. do the 3rd pass through the K-form:
            - convert body of each function to C-form
            - put all the global calculations to a dedicated function _fx_init();
              all the intermediate values, used at the global scope, are moved to this function as well.
            - put all the global c-code fragments into a separate code sequence.
        4. output the final C code as concatenation of the following parts (in this particular order):
            - preamble (some general comment about autogenerated file + #include "ficus/ficus.h")
            - all the global c code
            - forward declarations of some types and their destructors
            - declarations of all the types and their helper functions (constructors, destructors, copy operators)
            - declarations of all the exceptions and their constructors
            - declarations of the global variables together with their default initializers.
            - forward declarations of some functions
            - declarations and definitions of all the functions
            - the function "int _fx_init(void) {...}"
            _ the function main() that initializes runtime, calls _fx_init() and returns its value.

    The transformed K-form as a recursive tree of expressions. So the basic element, workhorse
    of the conversion algorithm is the function to convert K expression to C code.

    We maintain and recursively pass the following compiler state:
    - C code generated so far. Just like in k_normalize.ml, this is the reverse list of c statements.
      We add new elements to the beginning of it and then reverse the produced list in the end.
    - The "catch" label stack. In the beginning of new function we push the default "cleanup" label
      for that function and pop in the end. We also push-pop a new label when we translate
      try {} catch {} block. In principle, we can use dedicated catch labels in some other nested statements,
      like for(), if() etc. For simplicity we do not do that, at the expense of slightly higher
      overhead imposed by the single big cleanup section per function. After we employ the inline function
      call optimization, the relative overhead of the cleanup sections should decrease.
      In the catch blocks we jump to the underlying label in the stack,
      thus providing the exception propagation mechanism.
    - the map of id->cexp_t pairs. It does not make sense to represent all the values in K form as C variables.
      If the value (id) is:
      1. used just once
      2. immutable (val, not var)
      3. a result of expression, which operands are also values
      then the id can be just replaced with the expression in C-form.
    - the name of currently processed function (noid in the case of global/module scope expressions).
      First of all, it helps us to detect and efficiently translate the recursive calls of the function itself:

      int _fx_foo(...args..., void* fx_fv) {... _fx_foo(...new_args..., fx_fv); } // just pass fx_fv directly

      It also lets us to distinguish between 2 cases: global and non-global. We need to handle
      KDefVal() differently, depending on the context.
    - id of the value to store the result at, or noid.
        - when the translated kexp_t has type KTypVoid, no output value is needed.
        - in some other cases, there is no pre-defined id.
          Then we need to generate a new temporary id and store the result there.
          Or even postpone the temporary value assignment and put the pair (id, cexp) to the map.
        - in some cases we are given the pre-defined id.
        - For example, the function body expression result should be stored in fx_result.
        - When we have K-form code "var x=val0; ... x=new_val;", new_val should be stored in x,
          no need to generate a temporary value, because we want to avoid unnecessary data copying.
        - "record.f = new_val", "arr[idx] += newval" etc. are other such cases. In those cases we
          use a TEMP_REF val that is the pointer to the proper record field or array element.
          However, in those cases we will try to generate idiomatic C code, e.g. "record.f = new_val",
          not the direct replication of K-form: "sometype* pf /* TEMP_REF */ = &record.f; *pf = new_val"
*)
open Ast
open K_form
open C_form

let make_label basename sc loc =
    let li = gen_temp_idc basename in
    let cname = if basename = "cleanup" then "_fx_cleanup"
        else (sprintf "_fx_%s%d" basename (id2idx li)) in
    set_idc_entry li (CLabel {cl_name=li; cl_cname=cname; cl_scope=sc; loc=loc});
    (li, CStmtLabel(li, loc))

(* Finds a set of immutable values that can potentially be replaced
   with the expressions that they are initalized with, e.g.

   val b = a + 1; foo(b)
   can be replaced with foo(a+1).

   Here we find a superset of such values, i.e. a set of values
   that are used just once. If a value is used more than once, it makes
   sense to store it in a temporary variable.

   Later on we shrink this superset. We check that their initialization
   expressions can be represented as pure (w.o side effects) scalar C expressions.
   This is a recursive rule that cannot be checked at this stage.
*)
let find_single_use_vals topcode =
    (let count_map = ref (Env.empty: int env_t) in
    let decl_const_vals = ref (IdSet.empty) in
    let rec count_atom a loc callb =
        match a with
        | Atom.Id i ->
            if IdSet.mem i !decl_const_vals then
                let n = match (Env.find_opt i !count_map) with
                    | Some(n) -> n
                    | _ -> 0
                in count_map := Env.add i (n+1) !count_map
            else ()
        | _ -> ()
    and count_ktyp t loc callb = ()
    and count_kexp e callb =
        (* we put to decl_const_vals only the values declared with
           "val" operator, which means they are declared by
           user or are temporary intermediate values.
           we do not put there function parameters and
           loop counters, because they cannot be replaced with
           any expressions. They themselves are expressions.
        *)
        match e with
        | KDefVal(k, e1, loc) ->
            decl_const_vals := IdSet.add k !decl_const_vals;
            count_kexp e1 callb
        | _ -> fold_kexp e callb
    in count_callb =
    {
        kcb_fold_typ=Some(count_ktyp);
        kcb_fold_exp=Some(count_kexp);
        kcb_fold_atom=Some(count_atom);
        kcb_result=0
    } in
    List.iter (fun e -> count_kexp e) topcode;
    IdSet.filter (fun i -> match (Env.find_opt i !count_map) with Some 1 -> true | _ -> false) !decl_const_vals)

type block_ctx_t =
{
    bctx_scope: scope_t list;
    bctx_label: id_t;
    mutable bctx_prologue: cstmt_t list;
    mutable bctx_cleanup: cstmt_t list
}

let gen_ccode topcode =
    let i2e = ref (Env.empty: cexp_t env_t) in
    let u1vals = find_single_use_vals topcode in
    let block_stack = ref ([]: block_ctx_t list) in

    let curr_block_ctx loc = match !block_stack with
        | top :: _ -> top
        | _ -> raise_compile_err loc "cgen internal err: empty block stack!"
    in
    let add_complex_val i ctyp e0 sc loc =
        let {ctp_ptr; ctp_free=(freem,freef)} = get_ctprops ctyp loc in
        let {bctx_prologue; bctx_cleanup} = curr_block_ctx loc in


    let add_complex_temp_val prefix ctyp e0 sc loc =
        let i = gen_temp_idc prefix in
        add_complex_val i ctyp e0 sc loc; i
    in

    (*
        cases:
           - input kexp is void:
                no expression should be stored anywhere,
                just need to update ccode and return "nop"
           - non-void expression,
                the result should be stored to some pre-defined value (dstid).
                returns this CExpIdent(dstid)
           - non-void expression (dstid=noid),
                the result should be returned as expression
                if needed, some temporary id is generated where the result is stored.
    *)
    let rec kexp2cexp kexp dstid ccode sc =
        let fname = match sc with ScFun f :: _ -> f | _ -> noid in
        let (ktyp, kloc) = get_kexp_ctx kexp in
        let dummy_exp = CExpSeq([], (CTypVoid, kloc)) in
        (* generate exp and then optionally generate the assignment if needed *)
        match kexp with
        | KExpNop _ -> (dummy_exp, ccode, i2e)
        | KExpBreak _ -> (dummy_exp, ((CStmtBreak kloc) :: ccode), i2e)
        | KExpContinue _ ->
            (* 1. need to transform the block context stack: add the type of block, in particular, for/while loop
               2. need to check that break & continue are called inside such block (or inside try-catch block inside loop).
                  BTW, if break/continue are called inside try-catch, it must have void type. Probably, in the common
                  case they should generate some Break/Continue exceptions, which for loop should catch.
                  In the easiest case (no cleanup sections before the end of loop) they can simply be converted into
                  break/continue C statements.
               3.  *)
            (dummy_exp, ((CStmtContinue kloc) :: ccode), i2e)
        | KExpAtom(a, _) ->
            match a with
            | Atom.Lit(l) ->
                match l with
                | LitString s -> (* generate temporary variable, initialize it with fx_make_str() *)
                    fx_cstr2str()
            (* [TODO] *) raise_compile_err kloc "cgen: unsupported KExpAtom"
        | KExpBinOp(bop, e1, e2, _) -> raise_compile_err kloc "cgen: unsupported KExpBinOp"
        | KExpUnOp(uop, e1, _) -> raise_compile_err kloc "cgen: unsupported KExpUnOp"
            (* UnOp/BinOp - generate C expression and return it *)
        | KExpIntrin(intr, args, _) -> raise_compile_err kloc "cgen: unsupported KExpIntrin"
        | KExpSeq(el, _) -> raise_compile_err kloc "cgen: unsupported KExpSeq"
            (* generate block of C statements;
               for all bust the last expression call kexp2cexp recursively with dstid=noid;
               for the last expression pass the input dstid transparently *)
        | KExpIf(c, e1, e2, _) -> raise_compile_err kloc "cgen: unsupported KExpIf"
            (* 1. should recognize the sequence of if (c1) a1 else if (c2) a2 else if ... else an
               2. in the lucky case when all ci and ai are simple expressions, this can be replaced
                    with a cascade of ternary operations:
                    "c1 ? a1 : c2 ? a2 ... : an."
                    for that, we generate code for cj and aj into a separate sequences
                    ccode_cj and ccode_aj, respectively (except for c1, for which we can safely use ccode).

                    if at some point ccode_cj or ccode_aj is not empty, we need to patch
                    so-far generated c code for previous branches, and generate a cascade of if's.

                    In this case, if some ck can be translated to a single C expression, it can be
                    translated to "else if(ck) ..." instead of "else { some_ccode_ck; if(ck) ... }".

                    So, in the second lucky case (not the most lucky, but still), the cascade of if's
                    can be translated to:

                    if(c1) a1 else if(c2) a2 ... else an,

                    where aj can be complex compound statements. If KExpIf() has non-void type, i.e.
                    it should return some expression, the code for all ak should be patched to use
                    assign the result to some common variable:

                    rtype res = ...; // init res
                    if(c1) { ... ; res=a1_res } else if(c2) { ...; res=a2_res } ... else { ...; res=an_res }
            *)
        | KExpCall(f, args, _) -> raise_compile_err kloc "cgen: unsupported KExpCall"
            (*
                generate the call; if the function returns the result via output parameter
                (for now we do not support "nothrow" functions properly, so this always be the case),
                we pass pointer to dstid as the output parameter. If dstid=noid and the function is non-void,
                we generate temporary id. Let's call it dstid' (=dstid if dstid!=noid, some_temp_id overwise).
                The result will look like: FX_CALL(f(args, &dstid', fv_data))
                Return dstid' as the result.
                If f is a known function, just call it and pass fv_data=0. If it's function closure,
                call it via pointer and provide the stored in closure fv_data:
                FX_CALL(f.ptr(args, &dstid', f.fv_data));
                if f is "void" function (can only be in th case of known nothrow function, e.g. destructor),
                FX_CALL is not needed.

                Need to look at each argument and optionally add '&' or '*' if needed.
            *)
        | KExpMkTuple(args, _) -> raise_compile_err kloc "cgen: unsupported KExpMkTuple"
            (* in the case of simple tuple, generate code "ttype tmp={args};"
               in the case of complex tuple, generate "ttype tmp={}; (added to the block prologue)
                                                      _fx_make_T(args,&tmp);"
               add the destructor call _fx_free_T...(&tmp); to epilogue
               in both cases return tmp *)
        | KExpMkRecord(args, _) -> raise_compile_err kloc "cgen: unsupported KExpMkRecord"
            (* same as tuples *)
        | KExpMkClosure(f, fcv, args, _) -> raise_compile_err kloc "cgen: unsupported KExpMkClosure"
            (* TBD *)
        | KExpMkArray(shape, elems, _) -> raise_compile_err kloc "cgen: unsupported KExpMkArray"
            (* declare array with initializer expressions.
               [TODO] if array is just an argument to some simple arithmetic operation
               or array comprehension or a pure function, maybe
               we can avoid allocation of the memory on heap and copying data there?
               call fx_make_arrNd(...); *)
        | KExpAt(a, idxs, _) -> raise_compile_err kloc "cgen: unsupported KExpAt"
            (* if array is accessed with index check, add macro to check boundaries to ccode.
               then return the expression that returns array element *)
        | KExpMem(a, n, _) -> raise_compile_err kloc "cgen: unsupported KExpMem"
            (* return expression {tuple|record}.n *)
        | KExpDeref(a, _) -> raise_compile_err kloc "cgen: unsupported KExpDeref"
            (* a should be reference, just generate *a expression (in some cases it can be **a) *)
        | KExpAssign(i, e1, _) -> raise_compile_err kloc "cgen: unsupported KExpAssign"
            (* 1. if needed, call destructor for i.
               2. then call _fx_copy(e1, &i), fx_copy(e1, &i) or simply do assignment i=e1 *)
        | KExpMatch(cases, _) -> raise_compile_err kloc "cgen: unsupported KExpMatch"
            (* very similar to if, just a little bit more complex *)
        | KExpTryCatch(try_e, catch_e, _) -> raise_compile_err kloc "cgen: unsupported KExpCatch"
            (* create new block context, generate temporary value to assign the try result.
               generate code for try_e. then generate code for catch similarly to kexpmatch:

               tvtype try_val = ...;
               try_code;
               try_val = try_code_result;

            try_cleanup:
               ...; // call destructors for complex data structures used in try
               if(fx_status >= 0) goto end_catch;

               int code = fx_status;
               fx_status = FX_OK;
               ... // code to match the exception
               // if not caught
               fx_status = FX_OK; goto next_label_in_stack; // propagate the unhandled exception
            end_catch:
               // here we jump after each successful try or after successful catch.
               *)
        | KExpThrow(i, _) -> raise_compile_err kloc "cgen: unsupported KExpThrow"
            (*
                set the current exception to i, which includes setting fx_status=i.tag;
                then "goto try_cleanup";
            *)
        | KExpCast(a, kt, _) -> raise_compile_err kloc "cgen: unsupported KExpCast"
            (*
                for now just generate the cast expression
            *)
        | KExpMap(e_kdl_l, body, flags, _) -> raise_compile_err kloc "cgen: unsupported KExpMap"
            (*
                TBD
            *)
        | KExpFor(kdl, body, flags, _) -> raise_compile_err kloc "cgen: unsupported KExpFor"
            (*
                TBD
            *)
        | KExpWhile(c, body, _) -> raise_compile_err kloc "cgen: unsupported KExpWhile"
            (*
                for body translation generate a new context
                if c == true, replace with "for(;;) { body_ccode }"
                if c is simple expression, but not "true", replace with "while(c) { body_ccode }"
                otherwise replace with
                for(;;) {
                    ccode_for_c;
                    if(!c) break;
                    body_ccode;
                }
            *)
        | KExpDoWhile(body, c, _) -> raise_compile_err kloc "cgen: unsupported KExpDoWhile"
            (*
                for body translation generate a new context
                if c == true, replace with "for(;;) { body_ccode }
                otherwise translate to
                do {
                    body_ccode;
                    ccode_for_c;
                }
                while(final_c_exp);
            *)
        | KExpCCode(ccode_str, _) -> raise_compile_err kloc "cgen: unsupported KExpCCode"
            (*
                copy-n-paste literaly to the output tree.
                just make sure that if it's function body, the function parameters
                look just like in the source code, without "@n", "@@m" etc.
            *)
        | KDefVal(i, e1, _) -> raise_compile_err kloc "cgen: unsupported KDefVal"
            (*
                * if e1/i has complex type:
                    ** generate "type i={};",
                    ** add it to prologue, add destuctor to cleanup.
                    ** set dstid = i
                * otherwise dstid = noid
                convert e1 to cexp. if e1/i has simple type, then do "some_type i = e1;"
                (otherwise during the conversion the result of e1 will automatically be stored to dstid)
            *)
        | KDefFun kf -> raise_compile_err kloc "cgen: unsupported KDefFun"
            (*
                generate new context.
                generate ccode for the body with dstid=fx_result.
                after cleanup section add "return fx_status;"
            *)
        | KDefExn ke -> raise_compile_err kloc "cgen: unsupported KDefExn"
            (*
                should generate constructor in the case of exception with argument(s) (TBD).
            *)
        | KDefVariant kvar -> (ccode, i2e) (* handled in c_gen_types *)
        | KDefTyp kt -> (ccode, i2e) (* handled in c_gen_types *)
        | KDefClosureVars kcv -> raise_compile_err kloc "cgen: unsupported KDefClosureVars"
            (* TBD *)
    in ...

let convert_to_c top_code =
    let c_types_ccode = C_gen_types.convert_all_typs top_code in
