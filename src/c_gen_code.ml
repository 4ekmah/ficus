(*
    This file is a part of ficus language project.
    See ficus/LICENSE for the licensing terms
*)

(*
    Converts K-form into C-form (see c_form.ml).
    We assume that K-form has been prepared for the conversion,
    i.e. lambda lifting has been done, all the complex
    data structures, such as records, tuple, lists etc. have
    been converted to KTypName(...) etc.

    The algorithm:
        1. do the 1st pass through the K-form, convert all the types and exceptions (see c_gen_types.ml).
        2. do the 2nd pass through the K-form, generate headers for all the functions (see c_gen_fdecl.ml):
            - each function, except for the constructors, gets extra "free variables"/"closure data"
              parameter fx_fv, even if it's not used.
            - the return value becomes the output parameter fx_result (before the closure pointer), unless
              the function is "nothrow" and the return type is scalar.
            - the non-"nothrow" function gets "int" return value, the status.
              "nothrow" functions return the result or return "void".
        3. do the 3rd pass through the K-form:
            - convert body of each function to C-form
            - put all the global calculations to a dedicated function _fx_init();
              all the intermediate values, used at the global scope, are moved to this function as well.
            - put all the global c-code fragments into a separate code sequence.
        4. output the final C code as concatenation of the following parts (in this particular order):
            - preamble (some general comment about autogenerated file + #include "ficus/ficus.h")
            - all the global c code
            - forward declarations of some types and their destructors
            - declarations of all the types and their helper functions (constructors, destructors, copy operators)
            - declarations of all the exceptions and their constructors
            - declarations of the global variables together with their default initializers.
            - forward declarations of some functions
            - declarations and definitions of all the functions
            - the function "int _fx_init(void) {...}"
            _ the function main() that initializes runtime, calls _fx_init() and returns its value.

    The transformed K-form as a recursive tree of expressions. So the basic element, workhorse
    of the conversion algorithm is the function to convert K expression to C code.

    We maintain and recursively pass the following compiler state:
    - C code generated so far. Just like in k_normalize.ml, this is the reverse list of c statements.
      We add new elements to the beginning of it and then reverse the produced list in the end.
    - The "catch" label stack. In the beginning of new function we push the default "cleanup" label
      for that function and pop in the end. We also push-pop a new label when we translate
      try {} catch {} block. In principle, we can use dedicated catch labels in some other nested statements,
      like for(), if() etc. For simplicity we do not do that, at the expense of slightly higher
      overhead imposed by the single big cleanup section per function. After we employ the inline function
      call optimization, the relative overhead of the cleanup sections should decrease.
      In the catch blocks we jump to the underlying label in the stack,
      thus providing the exception propagation mechanism.
    - the map of id->cexp_t pairs (i2e); not passed as argument, but maintained separately.
      It does not make sense to represent all the values in K form as C variables.
      If the value (id) is:
      1. used just once
      2. immutable (val, not var)
      3. a result of expression, which operands are also values
      then the id can be just replaced with the expression in C-form.
    - the stack of scopes where we need to do some cleanup:

      global -> [fun -> ] [try -> ] [for/while/do-while ->] [match case ->] ...

    - reference to the destination expression, or ref None.
        - when the translated kexp_t has type KTypVoid, no output value is needed.
        - in some other cases, there is no pre-defined target for expression.
          Then we need to generate a new temporary value and store the result there.
          Or even postpone the temporary value assignment and put the pair (id, cexp) to the map.
        - in some cases we are given the pre-defined expression target.
        - For example, the function body expression result should be stored in fx_result.
        - When we have K-form code "var x=val0; ... x=new_val;", new_val should be stored in x,
          no need to generate a temporary value, because we want to avoid unnecessary data copying.
        - "record.f = new_val", "arr[idx] += newval" etc. are other such cases. In those cases we
          use a TEMP_REF val that is the pointer to the proper record field or array element.
          However, in those cases we will try to generate idiomatic C code, e.g. "record.f = new_val",
          not the direct replication of K-form: "sometype* pf /* TEMP_REF */ = &record.f; *pf = new_val"
*)
open Ast
open K_form
open C_form

(* Finds a set of immutable values that can potentially be replaced
   with the expressions that they are initalized with, e.g.

   val b = a + 1; foo(b)
   can be replaced with foo(a+1).

   Here we find a superset of such values, i.e. a set of values
   that are pure expressions and used just once.
   If a value is used more than once, it makes
   sense to store it in a temporary variable.

   Later on we shrink this superset. We check that their initialization
   expressions can be represented as scalar C expressions.
   This is a recursive rule that cannot be checked at this stage.
*)
let find_single_use_vals topcode =
    (let count_map = ref (Env.empty: int env_t) in
    let decl_const_vals = ref (IdSet.empty) in
    let rec count_atom a loc callb =
        match a with
        | Atom.Id i ->
            if IdSet.mem i !decl_const_vals then
                let n = match (Env.find_opt i !count_map) with
                    | Some(n) -> n
                    | _ -> 0
                in count_map := Env.add i (n+1) !count_map
            else ()
        | _ -> ()
    and count_ktyp t loc callb = ()
    and count_kexp e callb =
        (* we put to decl_const_vals only the values declared with
           "val" operator, which means they are declared by
           user or are temporary intermediate values.
           we do not put there function parameters and
           loop counters, because they cannot be replaced with
           any expressions. They themselves are expressions.
        *)
        match e with
        | KDefVal(k, e1, loc) ->
            (match (kinfo_ k loc) with
            | KVal {kv_flags} ->
                (* We only replace those values with expressions which are temporary
                   and computed using pure expressions *)
                let good_temp = (List.mem ValTempRef kv_flags) || (List.mem ValTemp kv_flags) in
                if good_temp && (K_deadcode_elim.pure_kexp e1) then
                    decl_const_vals := IdSet.add k !decl_const_val
                else ()
            | _ -> ());
            count_kexp e1 callb
        | KExpCall(f, _, (_, loc)) ->
            (* count f twice to make sure it will be included into u1vals, because if
               f is function pointer, then in C the call will be converted to
               `f.fptr(args, f.fv)`, i.e. f is used twice here, so we need to save it anyway *)
            count_atom (Atom.Id f) loc callb;
            fold_kexp e callb
        | _ -> fold_kexp e callb
    in count_callb =
    {
        kcb_fold_typ=Some(count_ktyp);
        kcb_fold_exp=Some(count_kexp);
        kcb_fold_atom=Some(count_atom);
        kcb_result=0
    } in
    List.iter (fun e -> count_kexp e) topcode;
    IdSet.filter (fun i -> match (Env.find_opt i !count_map) with Some 1 -> true | _ -> false) !decl_const_vals)

type block_kind_t =
    | BlockKind_Global
    | BlockKind_Fun of id_t
    | BlockKind_Try
    | BlockKind_Loop
    | BlockKind_Case

type block_ctx_t =
{
    bctx_kind: block_kind_t;
    bctx_scope: scope_t list;
    bctx_label: id_t;
    mutable bctx_prologue: cstmt_t list;
    mutable bctx_cleanup: cstmt_t list;
    mutable bctx_break_used: int;
    mutable bctx_continue_used: int;
    mutable bctx_label_used: int;
}

let gen_ccode topcode =
    let top_ccode = ref ([]: cstmt_t list) in
    let i2e = ref (Env.empty: cexp_t env_t) in
    let u1vals = find_single_use_vals topcode in
    let block_stack = ref ([]: block_ctx_t list) in
    let curr_fun = ref noid in

    let check_inside_loop is_break loc =
        let rec check_inside_loop_ s =
            match s with
            | ({bctx_kind=BlockKind_Loop;} as top) :: _ ->
                if is_break then
                    top.bctx_break_used <- top.bctx_break_used + 1
                else
                    top.bctx_continue_used <- top.bctx_continue_used + 1
            | {bctx_kind=BlockKind_Fun} :: _ ->
                raise_compile_err loc
                    (sprintf "'%s' is used outside of a loop" (if is_break then "break" else "continue"))
            | _ :: rest -> check_inside_for rest
            | _ ->
                raise_compile_err loc
                    (sprintf "'%s' is used outside of a loop" (if is_break then "break" else "continue"))
        in check_inside_loop_ !block_stack
    in

    let curr_block_ctx loc = match !block_stack with
        | top :: _ -> top
        | _ -> raise_compile_err loc "cgen: empty block stack!"
    in

    let curr_func loc =
        match (List.find_opt (fun bctx ->
                match bctx.bctx_kind with
                | BlockKind_Fun _ -> true
                | _ -> false) !block_stack)
        with
        | Some({bctx_kind=BlockKind_Fun f}) -> f
        | _ -> noid

    let new_block_ctx kind sc loc =
        let l_basename = match kind with
            | BlockKind_Global | BlockKind_Fun -> "cleanup"
            | _ -> "catch" in
        let l = make_label l_basename sc (get_end_loc loc) in
        let bctx = {bctx_kind = kind; bctx_scope=sc; bctx_label=l;
                    bctx_prologue=[]; bctx_cleanup=[];
                    bctx_break_used=0; bctx_continue_used=0;
                    bctx_label_used=0} in
        block_stack := bctx :: !block_stack
    in

    let pop_block_ctx loc =
        match !block_stack with
        | _ :: rest -> block_stack := rest
        | _ -> raise_compile_err loc "cgen: empty block stack!"

    let curr_block_label loc =
        let bctx = curr_block_ctx loc in
        bctx.bctx_label_used <- bctx.bctx_label_used + 1;
        make_id_exp bctx.bctx_label loc
    in

    let parent_block_label loc = match !block_stack with
        | _ :: parent :: _ ->
            parent.bctx_label_used <- parent.bctx_label_used + 1;
            made_id_exp parent.bctx_label loc
        | _ ->
            raise_compile_err loc "cgen internal err: there is no parent block!"
    in

    let add_fx_call call_exp ccode loc =
        let l = curr_block_label loc in
        let fx_call_e = make_call !std_FX_CALL (call_exp :: l :: []) CTypVoid loc in
        (CExp fx_call_e) :: ccode
    in

    let add_val i ctyp flags e0_opt ccode sc loc =
        let {ctp_ptr; ctp_free=(freem, freef)} = get_ctprops ctyp loc in
        let i_exp = make_id_exp i loc in
        let need_dtor = freem <> noid || freef <> noid in
        let ccode = if need_dtor then
                (let bctx = curr_block_ctx loc in
                let init_exp = if ctp_ptr then CExpLit(LitNil, (ctyp, loc)) else CExpInit([], (ctyp, loc)) in
                bctx.bctx_prologue <- create_cdefval i ctyp flags "" (Some init_exp) bctx.bctx_prologue sc loc;
                bctx.bctx_cleanup <- C_gen_types.gen_free_code i_exp ctyp true true bctx.bctx_cleanup loc;
                ccode)
            else
                create_cdefval i ctyp flags "" e0_opt ccode sc loc in
        (i_exp, ccode)
    in

    let get_dstexp dstexp_r prefix ctyp flags ccode sc loc =
        match (ctyp, !dstexp_r) with
        | (_, Some(dstexp)) -> (dstexp, ccode)
        | (CTypVoid, _) -> ((make_dummy_exp loc), ccode)
        | _ ->
            let i = gen_temp_idc prefix in
            let (i_exp, ccode) = add_val i ctyp flags None ccode sc loc in
            dstid_r := (Some i_exp);
            (i_exp, ccode)
    in

    let get_struct c_e =
        let (ctyp, cloc) = get_cexp_ctx c_e in
        let rec try_deref c_e ctyp =
            match ctyp with
            | CTypRawPtr(_, ctyp1) -> try_deref (cexp_deref c_e) ctyp1
            | _ ->
                (match ctyp with
                | CTypName tn ->
                    (match (cinfo_ tn cloc) with
                    | CTyp {contents={ct_typ=CTypStruct(_, relems)}} ->
                        (c_e, relems)
                    | CTyp {contents={ct_typ=CTypRawPtr(_, CTypStruct(_, relems))}} ->
                        ((cexp_deref ce), relems)
                    | _ -> raise_compile_err cloc
                        (sprintf "the type '%s' is not a structure" (get_idc_cname tn cloc)))
                | CTypStruct(_, relems) -> (ce, relems)
                | _ -> raise_compile_err cloc "a structure is expected here")
        in try_deref c_e ctyp
    in

    let gen_break_continue_stmt is_break loc =
        let _ = check_inside_loop is_break loc in
        let f = if is_break then !std_FX_BREAK else !std_FX_CONTINUE in
        let l = curr_block_label loc in
        CExp (make_call f (l::[]) CTypVoid loc)
    in

    let handle_temp_ref flags lhs_e ctyp =
        if List.mem ValTempRef flags then
            (true, (cexp_get_addr lhs_e), CTypRawPtr([], ctyp))
        else
            (false, lhs_e, ctyp)

    let id2cexp i save ccode sc loc =
        match (Env.find_opt i !i2e) with
        | Some(e) ->
            if not save then (e, ccode)
            else
                let (ctyp, eloc) = get_cexp_ctx e in
                let flags = match (kinfo_ i loc) with
                    | KVal {kv_flags} -> kv_flags
                    | _ -> raise_compile_err loc ("gen: id2cexp: %s is not identifier" (id2str i))
                    in
                let i2 = dup_idc i in
                let (add_ref, lhs_e, ctyp) = handle_temp_ref flags e ctyp in
                let (i2_exp, ccode) = add_val i2 ctyp flags (Some lhs_e) ccode sc loc in
                i2e := Env.add i !i2e;
                ((if add_deref then cexp_deref e else e), ccode)
        | _ ->
            let e = make_id_exp i kloc in
            let e = (match cinfo_ i kloc with
            | CDefVal {cv_typ; cv_flags} ->
                let e = if (List.mem ValImplicitDeref cv_flags) then (cexp_deref e) else e in
                (match cv_typ with
                | CTypRawPtr(_, ctyp2) when ctyp2 = ctyp -> cexp_deref e
                | _ -> e)
            | _ -> e)
            in (e, ccode)
        in

    let finalize_loop_body body_code loc =
        let end_loc = get_end_loc loc in
        let bctx = curr_block_ctx loc in
        let {bctx_prologue; bctx_cleanup;
            bctx_break_used;bctx_continue_used;
            bctx_label; bctx_label_used} = bctx in
        let epilogue = List.rev bctx_cleanup in
        let epilogue =
            if bctx_label_used = 0 then
                epilogue
            else
                let parent_label_exp = parent_block_label end_loc in
                let check_exn = if bctx_break_used + bctx_continue_used > 0 then
                    !std_FX_CHECK_EXN_BREAK_CONTINUE else !std_FX_CHECK_EXN in
                let handle_exn = make_call check_exn (parent_label_exp::[]) CTypVoid end_loc in
                (CExp handle_exn) :: (epilogue @ ((CStmtLabel bctx_label end_loc) :: []))
            in
        let body_code = epilogue @ body_code @ bctx_prologue in
        let body_stmt = rccode2stmt body_code loc in
        pop_block_ctx end_loc; body_stmt
    in

    let atom2cexp_ a save ccode sc loc =
        match a with
        | Atom.Lit(l) ->
            (match l with
            | LitString _ ->
                (* since FX_MAKE_STR(<string_literal>) creates a string with NULL reference counter and
                without allocating string in memory heap, there is no need to call destructor for it *)
                let e0 = make_call !std_FX_MAKE_STR ((make_lit_exp l loc) :: []) CTypString loc in
                let i = gen_temp_idc "slit" in
                let ccode = create_cdefval i CTypString [] "" (Some e0) ccode sc loc in
                ((make_id_exp i loc), ccode)
            | _ ->
                let e = make_lit_exp l kloc in (e, ccode))
        | Atom.Id(i) -> id2cexp i save ccode sc loc
    in

    let atom2cexp a ccode sc loc = atom2cexp_ a false ccode sc loc

    let decl_arr arr_ctyp shape data dstexp_r ccode sc loc =
        let dims = List.length shape in
        let shape_ctyp = CTypRawArray ([CTypConst], CTypInt) in
        let shape_arr = CExpInit(shape, (shape_ctyp, loc)) in
        let shape_id = gen_temp_idc "shape" in
        let ccode = create_cdefval shape_id shape_ctyp [] "" (Some shape_arr) ccode sc loc in
        let elem_ctyp = match arr_ctyp with
            | CTypArray(_, elem_ctyp) -> elem_ctyp
            | _ -> raise_compile_err loc "cgen: invalid output type of array construction expression"
            in
        let (data_exp, ccode) = match data with
            | [] -> ((make_nullptr loc), ccode)
            | _ ->
                let elems_ctyp = CTypRawArray ([CTypConst], elem_ctyp) in
                let elems_arr = CExpInit((List.rev es), (elems_ctyp, loc)) in
                let elems_id = gen_temp_idc "data" in
                let ccode = create_cdefval elems_id elems_ctyp [] "" (Some elems_arr) ccode sc loc in
                (make_id_exp elems_id loc)
        let sizeof_elem_exp = make_call !std_sizeof [CExpTyp(elem_ctyp, loc)] CTypSize_t loc in
        let free_f_exp = match (get_free_f elem_ctyp true false loc) with
            | (_, (Some free_f)) -> make_id_exp free_f loc
            | _ -> make_nullptr loc
            in
        let copy_f_exp = match (get_copy_f elem_ctyp true false loc) with
            | Some(copy_f) -> make_id_exp copy_f loc
            | _ -> make_nullptr loc
            in
        let (arr_exp, _) = get_dstexp dstexp_r "arr" arr_ctyp [] [] sc loc in
        let call_mkarr = make_call !std_fx_make_arr [(make_int_exp dims loc), (make_id_exp shape_id loc),
            sizeof_elem_exp, free_f_exp, copy_f_exp, data_exp, (cexp_get_addr arr_exp)] CTypCInt loc in
        (arr_exp, (add_fx_call call_mkarr ccode loc))

    (*
        cases:
           - input kexp is void:
                no expression should be stored anywhere,
                just need to update ccode and return "nop"
           - non-void expression,
                the result should be stored to some pre-defined value (dstid).
                returns this CExpIdent(dstid)
           - non-void expression (dstid=noid),
                the result should be returned as expression
                if needed, some temporary id is generated where the result is stored.
    *)
    let rec kexp2cexp kexp dstexp_r ccode sc =
        let fname = match sc with ScFun f :: _ -> f | _ -> noid in
        let (ktyp, kloc) = get_kexp_ctx kexp in
        let ctyp = C_gen_types.ktyp2ctyp ktyp kloc in
        let dummy_exp = make_dummy_exp kloc in
        let is_dummy_exp e = match e with CExpInit([], (CTypVoid, _)) -> true | _ -> false in

        (* generate exp and then optionally generate the assignment if needed *)
        let (assign, cexp, ccode) = match kexp with
        | KExpNop _ -> (false, dummy_exp, ccode)
        | KExpBreak _ ->
            let break_stmt = gen_break_continue_stmt true kloc in
            (false, dummy_exp, break_stmt :: ccode)
        | KExpContinue _ ->
            let continue_stmt = gen_break_continue_stmt false kloc in
            (false, dummy_exp, continue_stmt :: ccode)
        | KExpAtom(a, _) ->
            let (e, ccode) = atom2cexp a ccode sc kloc in
            (true, e, ccode)
        | KExpBinOp(bop, a1, a2, _) ->
            let (ce1, ccode) = atom2cexp e1 ccode sc kloc in
            let (ce2, ccode) = atom2cexp e2 ccode sc kloc in
            (match bop with
            | OpLogicAnd | OpLogicOr ->
                raise_compile_err kloc "cgen: unexpected operation"
            | OpPow ->
                let (need_cast, ce1, ce2, rtyp, f) = match ctyp with
                    | CTypFloat(32) -> (false, ce1, ce2, ctyp, get_id "powf")
                    | CTypFloat(64) -> (false, ce1, ce2, ctyp, get_id "pow")
                    | _ ->
                        let ce1 = CExpCast(ce1, (CTypFloat 64), kloc) in
                        let ce2 = CExpCast(ce2, (CTypFloat 64), kloc) in
                        (true, ce1, ce2, (CTypFloat 64), get_id "pow") in
                let e = make_call f (ce1 :: ce2 :: []) rtyp kloc in
                let e = if need_cast then CExpCast(e, ctyp, kloc) else e in
                (true, e, ccode)
            | OpCons ->
                (*
                    l = e1 :: e2;
                    if !dstexp_r == None && (e2 is single-use id from u1vals) && (ce2 is id) then
                        re-use ce2 as l
                    else
                        obtain l using get_dstexp.
                *)
                let a2_id = match a2 with (Atom.Id i) when IdSet.mem i u1vals -> i | _ -> noid in
                let ce2_id = match ce2 with CExpIdent(i, _) -> i | _ -> noid in
                let (reuse_ce2, (l_exp, _)) = (Utils.is_none !dstexp_r) && a2_id <> noid && ce2_id <> noid then
                        (true, (ce2_id, []))
                    else (false, (get_dstexp dstexp_r "lst" ctyp [] [] sc kloc)) in
                let lcon = C_gen_types.get_constructor ctyp true kloc in
                let call_cons = make_call lcon
                    (ce1 :: ce2 :: (make_lit_exp (LitBool (not reuse_ce2)) kloc) ::
                    (cexp_get_addr l_exp) :: []) CTypCInt kloc in
                (false, l_exp, (add_fx_call call_cons ccode kloc))
            | _ ->
                let c_bop = match bop with
                    | OpAdd -> COpAdd
                    | OpSub -> COpSub
                    | OpMul -> COpMul
                    | OpDiv -> COpDiv
                    | OpMod -> COpMod
                    | OpShiftLeft -> COpShiftLeft
                    | OpShiftRight -> COpShiftRight
                    | OpBitwiseAnd -> COpBitwiseAnd
                    | OpBitwiseOr -> COpBitwiseOr
                    | OpBitwiseXor -> COpBitwiseXor
                    | OpCompareEQ -> COpCompareEQ
                    | OpCompareNE -> COpCompareNE
                    | OpCompareLT -> COpCompareLT
                    | OpCompareLE -> COpCompareLE
                    | OpCompareGT -> COpCompareGT
                    | OpCompareGE -> COpCompareGE
                    | _ -> raise_compile_err kloc (sprintf "cgen: unsupported op '%s'" (binop_to_string bop))
                in (true, CExpBinOp(c_bop, ce1, ce2, (ctyp, kloc)), ccode))
        | KExpUnOp(OpMkRef, a1, _) ->
            let (ce1, ccode) = atom2cexp a1 ccode sc kloc in
            let (r_exp, _) = get_dstexp dstexp_r "r" ctyp [] [] sc kloc in
            let rcon = C_gen_types.get_constructor ctyp true kloc in
            let call_mkref = make_call rcon
                (ce1 :: (cexp_get_addr r_exp) :: []) CTypCInt kloc in
            (false, r_exp, (add_fx_call call_mkref ccode kloc))
        | KExpUnOp(OpDeref, a1, _) ->
            let (ce1, ccode) = atom2cexp a1 ccode sc kloc in
            (true, (cexp_deref ce1), ccode)
        | KExpUnOp(uop, a1, _) ->
            let (ce1, ccode) = atom2cexp a1 ccode sc kloc in
            let c_uop = match uop with
                | OpPlus -> COpPlus
                | OpNegate -> COpNegate
                | OpBitwiseNot -> COpBitwiseNot
                | OpLogicNot -> COpLogicNot
                | OpExpand -> raise_compile_err kloc "cgen: unsupported op 'expand'"
            in (true, CExpUnOp(c_uop, ce1, (ctyp, kloc)), ccode)
        | KExpIntrin(intr, args, _) ->
            (match (intr, args) with
            | (IntrinVariantTag, v :: []) ->
                let (cv, ccode) = atom2cexp v ccode sc kloc in
                let {ktp_ptr} = get_ktprops (get_atom_ktyp v kloc) kloc in
                let ctag = if ktp_ptr then
                        cexp_arrow cv (get_id "tag") CTypCInt
                    else
                        cexp_mem cv (get_id "tag") CTypCInt in
                (true, ctag, ccode)
            | (IntrinVariantCase, v :: (KExpAtom((Atom.Id vn), _)) :: []) ->
                let cv = atom2cexp v ccode sc kloc in
                let {ktp_ptr} = get_ktprops (get_atom_ktyp v kloc) kloc in
                let cvu = if ktp_ptr then
                        cexp_arrow cv (get_id "u") CTypAny
                    else
                        cexp_mem cv (get_id "u") CTypAny in
                let celem = cexp_mem cvu (get_orig_id vn) ctyp in
                (true, celem, ccode)
            | (IntrinListHead, l :: []) ->
                let (cl, ccode) = atom2cexp l ccode sc kloc in
                (true, (cexp_arrow cl (get_id "hd") ctyp), ccode)
            | (IntrinListTail, l :: []) ->
                let (cl, ccode) = atom2cexp l ccode sc kloc in
                (true, (cexp_arrow cl (get_id "hd") ctyp), ccode)
            | _ -> raise_compile_err kloc "cgen: unsupported KExpIntrin")
        | KExpSeq(el, _) ->
            let rec process_seq el ccode = match el with
                | [] -> (dummy_exp, ccode)
                | last :: [] -> kexp2cexp last dstid_r ccode sc
                | e :: rest ->
                    let (_, ccode) = kexp2cexp e (ref None) ccode sc in
                    process_seq rest ccode
            in let (e, ccode) = process_seq el ccode in
            (false, e, ccode)
        | KExpIf(c, e1, e2, _) ->
            let (cc, ccode) = kexp2cexp c (ref None) ccode sc in
            let (dstexp, ccode) = get_dstexp dstexp_r "t" ctyp [] ccode sc kloc in
            let (c_e1, ccode1) = kexp2cexp e1 dstid_r [] sc in
            let (c_e2, ccode2) = kexp2cexp e2 dstid_r [] sc in
            let c_e1 = rccode2stmt ((cexp2stmt c_e1) :: ccode1) (get_kexp_loc e1) in
            let c_e2 = rccode2stmt ((cexp2stmt c_e2) :: ccode2) (get_kexp_loc e2) in
            (false, dstexp, (CStmtIf(cc, c_e1, c_e2, kloc)) :: ccode)

        | KExpCall(f, args, _) ->
            let ftyp = get_idk_typ f loc in
            let (argtyps, rt) = match ftyp with
                | KTypFun(argtyps, rt) -> (argtyps, rt)
                | _ -> ([], ftyp)
                in
            let (args, ccode) = List.fold_left2 (fun (args, ccode) arg kt ->
                let (carg, ccode) = atom2cexp arg ccode sc kloc in
                let {ktp_pass_by_ref} = K_annotate_types.get_ktprops kt kloc in
                let carg = if ktp_pass_by_ref then (cexp_get_addr carg) else carg in
                (carg :: args, ccode)) ([], ccode) args argtyps
                in
            let (f_exp, fv_exp, have_fv_arg, is_nothrow, ccode) = match (kinfo_ f kloc) with
                | KFun {contents={kf_typ; kf_flags; kf_closure=(fv_arg, _); kf_loc}} ->
                    (* [TODO] check if f is declared already; if not, need to add it to the forward decl list *)
                    let f_exp = make_id_exp f kf_loc in
                    let have_fv_arg = List.mem FunConstr kf_flags in
                    let fv_exp = if fv_arg = noid then (make_lit_exp LitNil kloc) else
                        if f = curr_func then CExpIdent((get_id "fx_fv"), (!std_CTypVoidPtr, kf_loc)) else
                        raise_compile_err kloc "cgen: calling functions that need free vars is not supported yet"
                        in
                    let is_nothrow = List.mem FunNoThrow kf_flags in
                    (f_exp, fv_exp, is_nothrow, ccode)
                | KVal {kv_typ} ->
                    let (fclo_exp, ccode) = id2exp f true ccode sc loc in
                    let fclo_exp = make_id_exp f kf_loc in
                    let cftyp = ktyp2ctyp ftyp kloc in
                    let f_exp = cexp_mem fclo_exp (get_id "f") cftyp in
                    let fv_exp = cexp_mem fclo_exp (get_id "fv") !std_CTypVoidPtr in
                    (f_exp, fv_exp, true, false, ccode)
                | _ -> raise_compile_err kloc (sprintf "cgen: the called '%s' is not a function nor value" (id2str f))
                in
            let {ktp_scalar=rt_scalar} = K_annotate_types.get_ktprops rt kloc in
            let crt = ktyp2ctyp rt kloc in
            if is_nothrow && rt_scalar then
                let args = if have_fv_arg then fv_exp :: args else args in
                (true, CExpCall(f_exp, (List.rev args), (crt, kloc)), ccode)
            else
                let (args, dstexp, ccode) = if crt = CTypVoid then (args, dummy_exp, ccode) else
                    let (dstexp, ccode) = get_dstexp dstexp_r "res" crt [] ccode sc kloc in
                    (((cexp_get_addr dstexp) :: args), dstexp, ccode)
                    in
                let args = if have_fv_arg then fv_exp :: args else args in
                let fcall_rt = if is_nothrow then CTypVoid else CTypCInt in
                let fcall_exp = CExpCall(f_exp, (List.rev args), (fcall_rt, kloc)) in
                if is_nothrow then
                    (false, dstexp, (CExp fcall_exp) :: ccode)
                else
                    let ccode = add_fx_call fcall_exp ccode kloc in
                    (false, dstexp, ccode)

        | KExpMkTuple(args, _) | KExpMkRecord(args, _) ->
            let prefix = match kexp with KExpMkTuple(_, _) -> "tup" | _ -> "rec" in
            let (cargs, ccode) = List.fold_left (fun (cargs, ccode) a ->
                let (ca, ccode) = atom2cexp a ccode sc kloc in
                ((a :: cargs), ccode)) ([], ccode) args in
            let tcon = C_gen_types.get_constructor ctyp true kloc in
            if tcon <> noid then
                let (t_exp, _) = get_dstexp dstexp_r prefix ctyp [] [] true sc kloc in
                let call_mktup = make_call tcon
                    ((List.rev cargs) @ [cexp_get_addr t_exp]) CTypVoid kloc in
                (false, t_exp, (CExp call_mktup) :: ccode)
            else
                let tup = gen_temp_idc prefix in
                let e0 = CExpInit((List.rev cargs), (ctyp, kloc)) in
                let (t_exp, ccode) = add_val tup ctyp flags (Some e0) ccode sc loc in
                (true, t_exp, ccode)
        | KExpMkClosure(f, fcv, args, _) -> raise_compile_err kloc "cgen: unsupported KExpMkClosure"
            (* TBD *)
        | KExpMkArray(shape, elems, _) ->
            let shape = List.map (fun i -> make_lit_exp (LitInt i) kloc) shape in
            let (data, ccode) = List.fold_left (fun (data, ccode) a ->
                    let (e, ccode) = atom2cexp a ccode sc kloc in
                    (e :: data, ccode)) ([], ccode) elems in
            let (arr_exp, ccode) = decl_arr ctyp shape (List.rev data) dstexp_r ccode sc kloc in
            (false, arr_exp, ccode)
        | KExpAt(arr, idxs, _) ->
            (*
                there are 2 major cases:
                1. some of the idxs are ranges. Then the result is fx_arr_t
                2. all the ranges are scalars. Then the result is array element

                1. In the first case need to call a special function
                    `FX_CALL(fx_subarr(arr, ranges, subarr));`.
                    where ranges is array, concatenation of the following groups:
                    (0, idx) scalar indices
                    (1, a, b, delta) closed ranges [a:b:delta]
                        (if a was missing, it's set to 0, if delta was missing, it's set to 1)
                    (2, a, delta) open ranges [a::delta]
                        (if delta was missing, it's set to 1)

                2. In the second case need first to process each index idx_k (k=0..ndims-1):
                   2.1. If idx_k is "fast index" - great, just use the expression for the index
                        (process it via `atom2cexp`)
                   2.2. Otherwise we need to use the index more than once, so we need to
                        store it to temporary variable (unless it's already an indentifier or constant)
                        and add it to the check
                        `FX_CHKIDX(FX_CHKIDX1(arr, k1, idx_k1) || FX_CHKIDX1(arr, k2, idx_k2) ..., catch_label);`
                    if all the indices are fast indices, the whole check is excluded, of course.
                    then we return `(true, FX_PTR_{ndims}D(elem_ctyp, arr, idx0, ..., idx{ndims-1}), ccode)`
            *)
            let (arr_exp, ccode) = atom2cexp_ arr true ccode sc kloc in
            let need_subarr = List.exist (fun d -> match d with Domain.Range _ -> true | _ -> false) idxs in
            if need_subarr then
                let elem_ctyp = match ctyp with
                | CTypArray(_, elem_ctyp) -> elem_ctyp
                | _ -> raise_compile_err loc "cgen: invalid output type of array construction expression"
                in
                let (range_data, ccode) = List.fold_left (fun (range_data, ccode) d ->
                    match d with
                    | Domain.Elem i | Domain.Fast i ->
                        let (i_exp, ccode) = atom2cexp i ccode sc kloc in
                        ((i_exp :: (make_int_exp 0 kloc) :: range_data), ccode)
                    | Domain.Range (a, b, delta) ->
                        let (a_exp, ccode) = atom2cexp a ccode sc kloc in
                        let (range_delta, ccode) = match b with
                            | Atom.Lit LitNil -> ((a_exp :: (make_int_exp 2 kloc) :: []), ccode)
                            | _ ->
                                let (b_exp, ccode) = atom2cexp b ccode sc kloc in
                                ((b :: exp :: a_exp :: (make_int_exp 1 kloc) :: []), ccode)
                            in
                        let (d_exp, ccode) = atom2cexp delta ccode sc kloc in
                        (((d_exp :: range_delta) @ range_data), ccode)) ([], ccode) idxs
                    in
                let rdata_ctyp = CTypRawArray ([CTypConst], CTypInt) in
                let rdata_arr = CExpInit((List.rev range_data), (rdata_ctyp, kloc)) in
                let rdata_id = gen_temp_idc "ranges" in
                let ccode = create_cdefval rdata_id rdata_ctyp [] "" (Some rdata_arr) ccode sc kloc in
                let (subarr_exp, _) = get_dstexp dstexp_r "arr" arr_ctyp [] [] sc loc in
                let call_subarr = make_call !std_fx_subarr [(cexp_get_addr arr_exp);
                    (make_id_exp rdata_id kloc), (cexp_get_addr subarr_exp)] CTypCInt kloc in
                (false, subarr_exp, (add_fx_call call_subarr ccode kloc))
            else
                let elem_ctyp = ctyp in
                let (_, chk_exp_opt, i_exps, ccode) = List.fold_left (fun (dim, chk_exp_opt, i_exps, ccode) d ->
                    match d with
                    | Domain.Fast i ->
                        let (i_exp, ccode) = atom2cexp i ccode sc kloc in
                        (dim+1, chk_exp_opt, i_exp :: i_exps, ccode)
                    | Domain.Elem i ->
                        let (i_exp, ccode) = atom2cexp_ i true ccode sc kloc in
                        let chk_exp1 = make_call !std_FX_CHKIDX1 [arr_exp; (make_int_exp dim kloc); i_exp] CTypBool kloc in
                        let chk_exp_opt = match chk_exp_opt with
                            | Some(chk_exp) ->
                                let chk_exp = CExpBinOp(COpLogicOr, chk_exp, chk_exp1, (CTypBool, kloc)) in
                                Some chk_exp
                            | _ -> Some(chk_exp1)
                            in
                        (dim+1, chk_exp_opt, i_exp :: i_exps, ccode)) (0, None, [], ccode) idxs
                    in
                let ccode = match chk_exp_opt with
                    | Some (chk_exp) ->
                        let l = curr_block_label kloc in
                        let call_chkidx = make_call !std_FX_CHKIDX [chk_exp; l] CTypVoid kloc in
                        (CExp call_chkidx) :: ccode
                    | _ -> ccode
                    in
                let ndims = List.length idxs in
                let get_elem_exp = make_call (List.nth (!std_FX_PTR_xD) (ndims-1))
                    ((CExpTyp elem_ctyp kloc) :: arr_exp :: (List.rev i_exps)) elem_ctyp kloc in
                (true, get_elem_exp, ccode)
        | KExpMem(a1, n, _) ->
            let ce1 = atom2cexp a1 ccode sc kloc in
            let (ce1, relems) = get_struct ce1 in
            let nelems = List.length relems in
            let _ = if n < 0 || n >= nelems then
                raise_compile_err kloc (sprintf "the tuple/record element index %d is out of range [0, %d]" n nelems)
                else () in
            let (n_id, _) = List.nth relems n in
            (true, (cexp_mem ce1 n_id ctyp), ccode)
        | KExpAssign(i, e2, _) ->
            let (ktyp2, kloc2) = get_kexp_ctx e2 in
            let {ktp_complex} = K_annotate_types.get_ktprops ktyp2 kloc2 in
            let (i_exp, ccode) =
                if ktp_complex then
                    let (i_exp, ccode) = id2cexp i true ccode sc kloc in
                    let ctyp = get_cexp_typ i_exp in
                    let ccode = C_gen_types.gen_free_code i_exp ctyp true false ccode kloc
                    in (i_exp, ccode)
                else
                    (* if the type is simple then there is no need to save lhs into
                       intermediate variable, because it's used just once: lhs = rhs *)
                    id2cexp i false ccode sc kloc in
                in
            let (_, ccode) = kexp2cexp e2 (ref i_exp) ccode sc in
            (false, dummy_exp, ccode)
        | KExpMatch(cases, _) ->
            (*code00; if(exp00) {
                code01; if(exp01) {
                ... if(exp0N0) {
                    action0; goto _fx_endmatch...;
            }...}}
            code10; if(exp01) {
                code11; if(exp11) {
                ... if(exp1N1) {
                    action1; goto _fx_endmatch...;
            }...}}
            ...
            #if <have_default_action>
            default_action; // if there is default case
            #else
            fx_status = FX_NO_MATCH_ERR;
            #endif
            [_fx_endmatch...:]
            FX_CHECK_EXN(parent_label);
            ...*)
            let (dstexp, ccode) = get_dstexp dstexp_r "mres" ctyp [] ccode sc kloc in
            let end_loc = get_end_loc kloc in
            let endmatch = make_label "endmatch" sc end_loc in
            let (have_default, need_em_label, ccode) = List.fold_left
                (fun (have_default, need_em_label, ccode) (checks_i, action_i) ->
                let (checks_i, pre_checks_i) = List.fold_left (fun (checks_i, pre_checks_i) check_ij ->
                    let (ccheck_ij, ccode_ij) = kexp2cexp check_ij (ref None) [] sc in
                    (check_ij :: checks_i, ccode_ij :: pre_checks_i)) ([], []) checks_i
                    in
                let ai_loc = get_kexp_loc action_i in
                let new_have_default =
                    match checks_i with
                    | [] -> if have_default then raise_compile_err ai_loc
                        "cgen: more than one default action" else true
                    | _ -> have_default
                    in
                (* for each action we create a dedicated scope with its own cleanup section;
                   this is because it can be very lengthy match expressions with
                   many cases (like in compilers), so if we put all the
                   non-trivial locals into the common scope, the cleanup section
                   will be very inefficient *)
                let _ = new_block_ctx BlockKind_Case sc ai_loc in
                let (_, ai_ccode) = kexp2cexp action_i dstexp_r [] sc in
                let ai_end_loc = get_end_loc ai_loc in
                let bctx_i = curr_block_ctx loc in
                let {bctx_prologue; bctx_cleanup;
                    bctx_label; bctx_label_used} = bctx_i in
                let epilogue = List.rev bctx_cleanup in
                let epilogue =
                    if bctx_label_used = 0 then
                        epilogue
                    else
                        epilogue @ ((CStmtLabel bctx_label ai_end_loc) :: [])
                    in
                let (new_need_em_label, epilogue) = if new_have_default then
                        (need_em_label, epilogue)
                    else
                        (true, ((CStmtGoto (endmatch, ai_end_loc)) :: epilogue))
                    in
                let ai_ccode = epilogue @ ai_ccode @ bctx_prologue in
                let ai_stmt = rccode2stmt ai_ccode ai_loc in
                let _ = pop_block_ctx ai_end_loc in
                (* generate the nested if statement;
                 [TODO] need to replace it with one
                 `if (expi0 && expi1 && ... && expi{n-1}) { action_i }`
                 if possible (i.e. when all pre_check_ij's are empty) *)
                let case_ccode = List.fold_left2 (fun case_ccode check_ij pre_check_ij ->
                    let case_stmt = rccode2stmt case_ccode ai_end_loc in
                    let checkij_loc = get_cexp_loc check_ij in
                    let if_stmt = CStmtIf(check_ij, case_stmt, (CStmtNop ai_end_loc), checkij_loc) in
                    if_stmt :: pre_check_ij) (ai_stmt :: []) checks_i pre_checks_i
                    in
                (new_have_default, new_need_em_label, case_ccode @ ccode)) (false, false, ccode) cases
                in
            let ccode = if have_default then ccode else
                let fx_status = CExpIdent((get_id "fx_status"), (CTypCInt, end_loc)) in
                let fx_no_match_err = CExpIdent((get_id "FX_NO_MATCH_ERR"), (CTypCInt, end_loc)) in
                CExp (CExpBinOp(COpAssign, fx_status, fx_no_match_err, (CTypVoid, end_loc))) :: ccode
                in
            let ccode = if not need_em_label then ccode
                else (CStmtLabel endmatch end_loc) :: ccode in
            let parent_label_exp = parent_block_label end_loc in
            let check_exn = make_call !std_FX_CHECK_EXN (parent_label_exp::[]) CTypVoid end_loc in
            (false, dstexp, (CExp check_exn) :: ccode)
        | KExpTryCatch(try_e, catch_e, _) -> raise_compile_err kloc "cgen: unsupported KExpCatch"
            (* create new block context, generate temporary value to assign the try result.
               generate code for try_e. then generate code for catch similarly to kexpmatch:

               tvtype try_val = ...;
               try_code;
               try_val = try_code_result;

            try_cleanup:
               ...; // call destructors for complex data structures used in try
               if(fx_status >= 0) goto end_catch;

               int code = fx_status;
               fx_status = FX_OK;
               ... // code to match the exception
               // if not caught
               fx_status = FX_OK; goto next_label_in_stack; // propagate the unhandled exception
            end_catch:
               // here we jump after each successful try or after successful catch.
            *)
        | KExpThrow(i, _) -> raise_compile_err kloc "cgen: unsupported KExpThrow"
            (*
                set the current exception to i, which includes setting fx_status=i.tag;
                then "goto try_cleanup";
            *)
        | KExpCast(a1, kt, _) ->
            let ce1 = atom2cexp a1 ccode sc kloc in
            let ct = C_gen_types.ktyp2ctyp kt kloc in
            (true, CExpCast(ce1, ct, kloc), ccode)
        | KExpMap(e_kdl_l, body, flags, _) -> raise_compile_err kloc "cgen: unsupported KExpMap"
            (*
                TBD
            *)
        | KExpFor(kdl, body, flags, _) ->
            let l = curr_block_label kloc in
            let for_loc = get_start_loc kloc in
            let (nclauses, init_ccode, ndims, iter_list, first_arr_opt, i_exps, n_exps) = List.fold_left
                (fun (k, init_ccode, ndims, iter_list, first_arr_opt, i_exps, n_exps) (i, dom_i) ->
                    let (idx_exps, elem_exp, ndims_i, ctyp_i, is_arr_i, is_list_i, is_open_i, init_code, n_exps) =
                        match dom_i with
                        | Domain.Range(a, b, delta) ->
                            let (idx_exp, n_exp_opt, is_open_i, body_code, init_code) =
                                match (a, b, delta) with
                                | (Atom.Lit(LitInt 0)), n, (Atom.Lit(LitInt 1)) ->
                                    let n_exp = atom2cexp_ n true init_code sc for_loc in
                                |


            (*
                KExpFor of (id_t * dom_t) list * kexp_t * for_flag_t list * loc_t

            *)
        | KExpWhile(c, body, _) ->
            let _ = new_block_ctx BlockKind_Loop sc kloc in
            let (cc, cc_code) = kexp2cexp c (ref None) [] sc in
            let (is_for_loop, check_code) =
                (match (cc, cc_code) with
                | (CExp(CExpLit(LitBool(true), _)), []) -> (true, [])
                | (_, []) -> (false, [])
                | _ ->
                    let cc_loc = get_cexp_loc cc in
                    let not_cc = CExpUnOp(COpLogicNot, cc, (CTypBool, cc_loc)) in
                    let break_stmt = gen_break_continue_stmt cc_loc in
                    let check_cc = CStmtIf(not_cc, break_stmt, CStmtNop(cc_loc), cc_loc) in
                    (true, check_cc :: cc_code))
                in
            let (e, body_code) = kexp2cexp body (ref None) [] sc in
            let body_code = ((CExp e) :: body_code) @ check_code in
            let body_stmt = finalize_loop_body body_code kloc in
            let loop_stmt = (if is_for_loop then
                    CStmtFor([], None, [], body_stmt, kloc)
                else
                    CStmtWhile(cc, loop_stmt, kloc))
            in
            (false, dummy_exp, loop_stmt :: ccode)
        | KExpDoWhile(body, c, _) ->
            let _ = new_block_ctx BlockKind_Loop sc kloc in
            let (e, body_code) = kexp2cexp body (ref None) [] sc in
            let (cc, cc_code) = kexp2cexp c (ref None) [] in
            let (is_for_loop, check_code) =
                (match (cc, cc_code) with
                | (CExp(CExpLit(LitBool(true), _)), []) -> (true, [])
                | (_, []) -> (false, [])
                | _ ->
                    let cc_loc = get_cexp_loc cc in
                    let not_cc = CExpUnOp(COpLogicNot, cc, (CTypBool, cc_loc)) in
                    let break_stmt = gen_break_continue_stmt cc_loc in
                    let check_cc = CStmtIf(not_cc, break_stmt, CStmtNop(cc_loc), cc_loc) in
                    (true, check_cc :: cc_code))
                in
            let body_code = check_code :: body_code in
            let body_stmt = finalize_loop_body body_code kloc in
            let loop_stmt = if is_for_loop then
                    CStmtFor([], None, [], body_stmt, kloc)
                else
                    CStmtDoWhile(loop_stmt, cc, kloc)
            in
            (false, dummy_exp, loop_stmt :: ccode)
        | KExpCCode(ccode_str, _) ->
            if (curr_block_ctx kloc).bctx_kind <> BlockKind_Global then
                raise_compile_err kloc "cgen: unexpected ccode expression"
            else ();
            top_ccode := CExp (CExpCCode(ccode_str, kloc)) :: !top_ccode;
            (false, dummy_exp, ccode)
        | KDefVal(i, e2, _) ->
            let {kv_typ; kv_flags} = match (kinfo_ i kloc) with
                | KVal kv -> kv
                | _ -> raise_compile_err kloc ("'%s' is not a value/variable" (id2str i))
                in
            let {ktp_ptr; ktp_complex; ktp_scalar} = K_annotate_types.get_ktprops kv_typ kloc in
            let ctyp = C_gen_types.ktyp2ctyp kv_typ kloc in
            let bctx = curr_block_ctx kloc in
            let is_global = bctx.bctx_kind == BlockKind_Global in
            let is_temp_ref = List.mem ValTempRef kv_flags in
            (* there are 3 cases (ce2 denotes e2 converted to C):
                1. definition "ctyp i = ce2" is not added; instead, i is replaced with ce2.
                2. i is defined separately: "ctyp i[={}|0];" and then
                   expression is compiled with 'i' as the destination.
                3. i is defined and initialized at once: "ctyp i=ce2;"
            *)
            let ccode =
                if (is_temp_ref ||
                    (ktp_scalar && (List.mem ValTemp kv_flags))) &&
                    (IdSet.mem i u1vals) then
                    let (ce2, ccode) = kexp2cexp e2 (ref None) ccode sc in
                    let _ = i2e := Env.add i ce2 !i2e in
                    ccode
                else if is_temp_ref then
                    let (ce2, ccode) = kexp2cexp e2 (re None) ccode sc in
                    let (i_exp, ccode) = add_val i (make_ptr ctyp) kv_flags
                        (Some (cexp_get_addr ce2)) ccode sc kloc in
                    (*let _ = i2e := Env.add i (cexp_deref i_exp) !i2e in*)
                    ccode
                else if ktp_complex || is_global ||
                    (match e2 with
                    | KExpUnOp(OpMkRef, _, _) -> true
                    | KExpBinOp _ | KExpUnOp _ | KExpIntrin _ | KExpMkTuple
                    | KExpMkRecord _ | KExpAt _ | KExpMem _ | KExpCast _ | KExpCCode _ -> false
                    | _ -> true) then
                    let (i_exp, delta_code) = add_val i ctyp kv_flags None [] sc kloc in
                    let ccode = if is_global then (bctx.bctx_prologue <- delta_code @ bctx.bctx_prologue; ccode)
                        else delta_code @ ccode in
                    let (_, ccode) = kexp2cexp e2 (ref (Some i_exp)) ccode sc in
                    ccode
                else
                    let (ce2, ccode) = match (ktp_ptr, e2) with
                        | (_, KExpCCode(s, (_, loc))) -> (CExpCCode(s, loc), ccode)
                        | (false, KExpAtom((Atom.Lit LitNil), (_, loc))) -> (CExpInit([], (ctyp, loc)), ccode)
                        | _ -> kexp2cexp e2 (re None) ccode sc in
                        in
                    let (_, ccode) = add_val i ctyp kv_flags (Some ce2) ccode sc kloc in
                    ccode
                in
            (false, dummy_exp, ccode)
        | KDefFun kf ->
            (*
                generate new context.
                generate ccode for the body with dstid=fx_result.
                add the prologue and the cleanup sections to the generated c code.
                before cleanup possibly insert a label if needed.
                prior to the cleanup save the output expression if needed
                (because it may use elements that will be released)
                after cleanup section add "return fx_status;" if needed or
                "return ret_exp"; if the function is nothrow and is not void.

                handle the case of 'c code'-body separately
            *)
            let {kf_name; kf_typ; kf_closure=(arg_id, _); kf_body; kf_flags; kf_scope; kf_loc} = !kf in
            let _ = new_block_ctx (BlockKind_Fun kf_name) sc kloc in
            let (argtyps, rt, args, cf) = match (cinfo_ kf_name kf_loc) with
                | CFun {contents={cf_typ=CTypFun(argtyps, rt); cf_args}} as cf -> (argtyps, rt, cf_args, cf)
                | _ -> raise_compile_err kf_loc "cgen: the function declaration was not properly converted"
                in
            (* in the list of parameters the return value (if any) can be the last one
               (in the case of no-throw functions) or pre-last one
               (in the case of functions that may throw exceptions)
            *)
            let new_body = (match kf_body with
                | KExpCCode(code, (_, loc)) -> CExp (CExpCCode(code, loc)) :: []
                | _ ->
                    let retid0 = get_id "fx_result" in
                    let retid = match (List.rev argtyps) with
                        | (retid :: _) when (get_orig_id retid) = retid0 -> retid
                        | (_ :: retid :: _) when (get_orig_id retid) = retid0 -> retid
                        | _ -> noid
                        in
                    let dstexp_r = ref (if retid = noid then None else
                        (Some (cexp_deref (make_id_exp retid kf_loc))))
                        in
                    let status_id = if (List.mem FunNoThrow kf_flags) then noid else gen_temp_idc "fx_status" in
                    let ccode = if status_id = noid then []
                        else create_cdefval status_id CTypCInt [ValMutable] "fx_status"
                            (Some (make_int_exp 0 kf_loc)) [] kf_scope kf_loc
                        in
                    let (ret_e, ccode) = kexp2cexp kf_body dstexp_r ccode kf_scope in
                    let end_loc = get_kexp_end kf_body in
                    let {bctx_label; bctx_prologue; bctx_cleanup; bctx_label_used} = curr_block_ctx end_loc in
                    let ccode = if bctx_label_used > 0 then (StmtLabel bctx_label end_loc) :: ccode else ccode in
                    let (ret_e, ccode) = if bctx_cleanup = [] then (ret_e, ccode) else
                        let (ret_e, ccode) = if retid <> noid || status_id <> noid || (Utils.is_some !dstexp_r) then
                                (ret_e, ccode)
                            else
                            (match ret_e with
                            | CExpInit([], _) | CExpLit _ | CExpIdent _ -> ret_e
                            | _ ->
                                let new_ret_id = gen_temp_idc "result" in
                                let ccode = create_cdefval new_ret_id (get_cexp_typ) [] ""
                                    (Some ret_e) ccode kf_scope end_loc in
                                ((make_id_exp new_ret_id end_loc), ccode)
                                in
                                (ret_e, (bctx_cleanup @ ccode)))
                        in
                    let ccode = if status_id <> noid then
                            (CStmtReturn (Some (make_id_exp status_id end_loc)) end_loc) :: ccode
                        else if rt = CTypVoid then ccode
                        else (CStmtReturn (Some ret_e) end_loc) :: ccode
                        in
                    (List.rev bctx_prologue) @ (List.rev ccode))
                in
            cf := {!cf with cf_body = new_body};
            (false, dummy_exp, ccode)
        | KDefExn ke -> raise_compile_err kloc "cgen: unsupported KDefExn"
            (*
                should generate constructor in the case of exception with argument(s) (TBD).
            *)
        | KDefVariant kvar -> (false, dummy_exp, ccode) (* handled in c_gen_types *)
        | KDefTyp kt -> (false, dummy_exp, ccode) (* handled in c_gen_types *)
        | KDefClosureVars kcv -> raise_compile_err kloc "cgen: unsupported KDefClosureVars"
            (* TBD *)
    in ...

let convert_to_c top_code =
    let c_types_ccode = C_gen_types.convert_all_typs top_code in
