(*
    This file is a part of ficus language project.
    See ficus/LICENSE for the licensing terms
*)

(*
    Converts K-form into C-form (see c_form.ml).
    We assume that K-form has been prepared for the conversion,
    i.e. lambda lifting has been done, all the complex
    data structures, such as records, tuple, lists etc. have
    been converted to KTypName(...) etc.

    The algorithm:
        1. do the 1st pass through the K-form, convert all the types and exceptions (see c_gen_types.ml).
        2. do the 2nd pass through the K-form, generate headers for all the functions (see c_gen_fdecl.ml):
            - each function, except for the constructors, gets extra "free variables"/"closure data"
              parameter fx_fv, even if it's not used.
            - the return value becomes the output parameter fx_result (before the closure pointer), unless
              the function is "nothrow" and the return type is scalar.
            - the non-"nothrow" function gets "int" return value, the status.
              "nothrow" functions return the result or return "void".
        3. do the 3rd pass through the K-form:
            - convert body of each function to C-form
            - put all the global calculations to a dedicated function fx_toplevel();
              all the intermediate values, used at the global scope, are moved to this function as well.
            - put all the global c-code fragments into a separate code sequence.
        4. output the final C code as concatenation of the following parts (in this particular order):
            - preamble (some general comment about autogenerated file + #include "ficus/ficus.h")
            - all the global c code
            - forward declarations of some types and their destructors
            - declarations of all the types and their helper functions (constructors, destructors, copy operators)
            - declarations of all the exceptions and their constructors
            - declarations of the global variables together with their default initializers.
            - forward declarations of some functions
            - declarations and definitions of all the functions
            - the function "int fx_toplevel(void) {...}"
            _ the function main() that initializes runtime, calls fx_toplevel() and returns its value.

    The transformed K-form as a recursive tree of expressions. So the basic element, workhorse
    of the conversion algorithm is the function to convert K expression to C code.

    We maintain and recursively pass the following compiler state:
    - C code generated so far. Just like in k_normalize.ml, this is the reverse list of c statements.
      We add new elements to the beginning of it and then reverse the produced list in the end.
    - The "catch" label stack. In the beginning of new function we push the default "cleanup" label
      for that function and pop in the end. We also push-pop a new label when we translate
      try {} catch {} block. In principle, we can use dedicated catch labels in some other nested statements,
      like for(), if() etc. For simplicity we do not do that, at the expense of slightly higher
      overhead imposed by the single big cleanup section per function. After we employ the inline function
      call optimization, the relative overhead of the cleanup sections should decrease.
      In the catch blocks we jump to the underlying label in the stack,
      thus providing the exception propagation mechanism.
    - the map of id->cexp_t pairs (i2e); not passed as argument, but maintained separately.
      It does not make sense to represent all the values in K form as C variables.
      If the value (id) is:
      1. used just once
      2. immutable (val, not var)
      3. a result of expression, which operands are also values
      then the id can be just replaced with the expression in C-form.
    - the stack of scopes where we need to do some cleanup:

      global -> [fun -> ] [try -> ] [for/while/do-while ->] [match case ->] ...

    - reference to the destination expression, or ref None.
        - when the translated kexp_t has type KTypVoid, no output value is needed.
        - in some other cases, there is no pre-defined target for expression.
          Then we need to generate a new temporary value and store the result there.
          Or even postpone the temporary value assignment and put the pair (id, cexp) to the map.
        - in some cases we are given the pre-defined expression target.
        - For example, the function body expression result should be stored in fx_result.
        - When we have K-form code "var x=val0; ... x=new_val;", new_val should be stored in x,
          no need to generate a temporary value, because we want to avoid unnecessary data copying.
        - "record.f = new_val", "arr[idx] += newval" etc. are other such cases. In those cases we
          use a TEMP_REF val that is the pointer to the proper record field or array element.
          However, in those cases we will try to generate idiomatic C code, e.g. "record.f = new_val",
          not the direct replication of K-form: "sometype* pf /* TEMP_REF */ = &record.f; *pf = new_val"
*)
open Ast
open K_form
open C_form

let do_fold_left2 f result l1 l2 loc msg =
    let len1 = List.length l1 in
    let len2 = List.length l2 in
    (if len1 <> len2 then
        raise_compile_err loc (msg ^ (sprintf " len1=%d, len2=%d" len1 len2)) else ();
    List.fold_left2 f result l1 l2)

(* Finds a set of immutable values that can potentially be replaced
   with the expressions that they are initalized with, e.g.

   val b = a + 1; foo(b)
   can be replaced with foo(a+1).

   Here we find a superset of such values, i.e. a set of values
   that are pure expressions and used just once.
   If a value is used more than once, it makes
   sense to store it in a temporary variable.

   Later on we shrink this superset. We check that their initialization
   expressions can be represented as scalar C expressions.
   This is a recursive rule that cannot be checked at this stage.
*)
let find_single_use_vals topcode =
    (let count_map = ref (Env.empty: int Env.t) in
    let decl_const_vals = ref (IdSet.empty) in
    let rec count_atom a loc callb =
        match a with
        | Atom.Id i ->
            if IdSet.mem i !decl_const_vals then
                let n = match (Env.find_opt i !count_map) with
                    | Some(n) -> n
                    | _ -> 0
                in count_map := Env.add i (n+1) !count_map
            else ()
        | _ -> ()
    and count_ktyp t loc callb = ()
    and count_kexp e callb =
        (* we put to decl_const_vals only the values declared with
           "val" operator, which means they are declared by
           user or are temporary intermediate values.
           we do not put there function parameters and
           loop counters, because they cannot be replaced with
           any expressions. They themselves are expressions.
        *)
        match e with
        | KDefVal(k, e1, loc) ->
            (match (kinfo_ k loc) with
            | KVal {kv_flags} ->
                (* We only replace those values with expressions which are temporary
                   and computed using pure expressions *)
                let good_temp = (List.mem ValTempRef kv_flags) || (List.mem ValTemp kv_flags) in
                if good_temp && (K_deadcode_elim.pure_kexp e1) then
                    decl_const_vals := IdSet.add k !decl_const_vals
                else ()
            | _ -> ());
            count_kexp e1 callb
        | KExpCall(f, _, (_, loc)) ->
            (* count f twice to make sure it will be included into u1vals, because if
               f is function pointer, then in C the call will be converted to
               `f.fptr(args, f.fv)`, i.e. f is used twice here, so we need to save it anyway *)
            count_atom (Atom.Id f) loc callb;
            fold_kexp e callb
        | _ -> fold_kexp e callb
    in let count_callb =
    {
        kcb_fold_ktyp=Some(count_ktyp);
        kcb_fold_kexp=Some(count_kexp);
        kcb_fold_atom=Some(count_atom);
        kcb_fold_result=0
    } in
    List.iter (fun e -> count_kexp e count_callb) topcode;
    IdSet.filter (fun i -> match (Env.find_opt i !count_map) with Some 1 -> true | _ -> false) !decl_const_vals)

let occurs_id_kexp i0 e =
    let r_occurs = ref false in
    let rec occurs_atom a loc callb =
        match a with
        | Atom.Id i ->
            if i = i0 then r_occurs := true else ()
        | _ -> ()
    and occurs_ktyp t loc callb = ()
    and occurs_kexp e callb = if !r_occurs then () else fold_kexp e callb
    in let occurs_callb =
    {
        kcb_fold_ktyp=Some(occurs_ktyp);
        kcb_fold_kexp=Some(occurs_kexp);
        kcb_fold_atom=Some(occurs_atom);
        kcb_fold_result=0
    } in
    occurs_kexp e occurs_callb;
    !r_occurs

type block_kind_t =
    | BlockKind_Global
    | BlockKind_Fun of id_t
    | BlockKind_Try
    | BlockKind_Loop
    | BlockKind_LoopND
    | BlockKind_Case

type block_ctx_t =
{
    bctx_kind: block_kind_t;
    bctx_scope: scope_t list;
    bctx_label: id_t;
    bctx_br_label: id_t;
    mutable bctx_prologue: cstmt_t list;
    mutable bctx_cleanup: cstmt_t list;
    mutable bctx_break_used: int;
    mutable bctx_continue_used: int;
    mutable bctx_label_used: int;
}

let make_ccode_prologue loc =
    CExp(CExpCCode("// this is autogenerated file, do not edit it.\n#include \"ficus/ficus.h\"\n", loc)) ::
    []

let make_ccode_epilogue loc =
    CExp(CExpCCode("int main(int argc, char** argv)\n{\n   fx_init(argc, argv);\n   return fx_toplevel();\n}", loc)) ::
    []

let gen_ccode top_code =
    let top_ccode = ref ([]: cstmt_t list) in
    let i2e = ref (Env.empty: cexp_t Env.t) in
    let u1vals = find_single_use_vals top_code in
    let block_stack = ref ([]: block_ctx_t list) in

    let check_inside_loop is_break loc =
        let rec check_inside_loop_ s =
            match s with
            | ({bctx_kind=BlockKind_Loop} as top) :: _
            | ({bctx_kind=BlockKind_LoopND} as top) :: _ ->
                if is_break then
                    top.bctx_break_used <- top.bctx_break_used + 1
                else
                    top.bctx_continue_used <- top.bctx_continue_used + 1
            | {bctx_kind=BlockKind_Fun _} :: _ ->
                raise_compile_err loc
                    (sprintf "'%s' is used outside of a loop" (if is_break then "break" else "continue"))
            | _ :: rest -> check_inside_loop_ rest
            | _ ->
                raise_compile_err loc
                    (sprintf "'%s' is used outside of a loop" (if is_break then "break" else "continue"))
        in check_inside_loop_ !block_stack
    in

    let curr_block_ctx loc = match !block_stack with
        | top :: _ -> top
        | _ -> raise_compile_err loc "cgen: empty block stack!"
    in

    let curr_func loc =
        match (List.find_opt (fun bctx ->
                match bctx.bctx_kind with
                | BlockKind_Fun _ -> true
                | _ -> false) !block_stack)
        with
        | Some({bctx_kind=BlockKind_Fun f}) -> f
        | _ -> noid
    in

    let new_block_ctx kind sc loc =
        let l_basename = match kind with
            | BlockKind_Global | BlockKind_Fun _ -> "cleanup"
            | _ -> "catch" in
        let l = make_label l_basename sc (get_end_loc loc) in
        let br_l = if kind <> BlockKind_LoopND then noid else
            make_label "break" sc (get_end_loc loc) in
        let bctx = {bctx_kind = kind; bctx_scope=sc; bctx_label=l;
                    bctx_br_label = br_l;
                    bctx_prologue=[]; bctx_cleanup=[];
                    bctx_break_used=0; bctx_continue_used=0;
                    bctx_label_used=0} in
        block_stack := bctx :: !block_stack
    in

    let pop_block_ctx loc =
        match !block_stack with
        | _ :: rest -> block_stack := rest
        | _ -> raise_compile_err loc "cgen: empty block stack!"
    in

    let curr_block_label loc =
        let bctx = curr_block_ctx loc in
        bctx.bctx_label_used <- bctx.bctx_label_used + 1;
        make_id_exp bctx.bctx_label loc
    in

    let parent_block_label loc = match !block_stack with
        | _ :: parent :: _ ->
            parent.bctx_label_used <- parent.bctx_label_used + 1;
            make_id_exp parent.bctx_label loc
        | _ ->
            raise_compile_err loc "cgen internal err: there is no parent block!"
    in

    let add_fx_call call_exp ccode loc =
        let l = curr_block_label loc in
        let fx_call_e = make_call !std_FX_CALL (call_exp :: l :: []) CTypVoid loc in
        (CExp fx_call_e) :: ccode
    in

    let add_val i ctyp flags e0_opt ccode sc loc =
        let {ctp_ptr; ctp_free=(freem, freef)} = C_gen_types.get_ctprops ctyp loc in
        let i_exp = CExpIdent(i, (ctyp, loc)) in
        let need_dtor = freem <> noid || freef <> noid in
        let ccode = if need_dtor then
                (let bctx = curr_block_ctx loc in
                let init_exp = if ctp_ptr then CExpLit(LitNil, (ctyp, loc)) else CExpInit([], (ctyp, loc)) in
                bctx.bctx_prologue <- create_cdefval i ctyp flags "" (Some init_exp) bctx.bctx_prologue sc loc;
                bctx.bctx_cleanup <- C_gen_types.gen_free_code i_exp ctyp true true bctx.bctx_cleanup loc;
                match e0_opt with
                | Some(e0) -> C_gen_types.gen_copy_code e0 i_exp ctyp ccode loc
                | _ -> ccode)
            else
                create_cdefval i ctyp flags "" e0_opt ccode sc loc in
        (i_exp, ccode)
    in

    let get_dstexp dstexp_r prefix ctyp flags ccode sc loc =
        match (ctyp, !dstexp_r) with
        | (_, Some(dstexp)) -> (dstexp, ccode)
        | (CTypVoid, _) -> ((make_dummy_exp loc), ccode)
        | _ ->
            let i = gen_temp_idc prefix in
            let (i_exp, ccode) = add_val i ctyp flags None ccode sc loc in
            dstexp_r := (Some i_exp);
            (i_exp, ccode)
    in

    let get_struct cexp =
        let (ctyp, cloc) = get_cexp_ctx cexp in
        let rec try_deref cexp ctyp =
            match ctyp with
            | CTypRawPtr(_, ctyp1) -> try_deref (cexp_deref cexp) ctyp1
            | _ ->
                (match ctyp with
                | CTypName tn ->
                    (match (cinfo_ tn cloc) with
                    | CTyp {contents={ct_typ=CTypStruct(_, relems)}} ->
                        (cexp, relems)
                    | CTyp {contents={ct_typ=CTypRawPtr(_, CTypStruct(_, relems))}} ->
                        ((cexp_deref cexp), relems)
                    | _ -> raise_compile_err cloc
                        (sprintf "the type '%s' is not a structure" (get_idc_cname tn cloc)))
                | CTypStruct(_, relems) -> (cexp, relems)
                | _ -> raise_compile_err cloc "a structure is expected here")
        in try_deref cexp ctyp
    in

    let make_break_stmt loc =
        (check_inside_loop true loc;
        CExp (make_call !std_FX_BREAK [curr_block_label loc] CTypVoid loc))
    in

    let make_continue_stmt loc =
        (check_inside_loop false loc;
        CExp (make_call !std_FX_CONTINUE [curr_block_label loc] CTypVoid loc))
    in

    let handle_temp_ref flags lhs_e ctyp =
        if List.mem ValTempRef flags then
            (true, (cexp_get_addr lhs_e), CTypRawPtr([], ctyp))
        else
            (false, lhs_e, ctyp)
    in

    let id2cexp i save ccode sc loc =
        match (Env.find_opt i !i2e) with
        | Some(e) ->
            if not save then (e, ccode)
            else
                let (ctyp, eloc) = get_cexp_ctx e in
                let flags = match (kinfo_ i loc) with
                    | KVal {kv_flags} -> kv_flags
                    | _ -> raise_compile_err loc (sprintf "cgen: id2cexp: %s is not identifier" (id2str i))
                    in
                let i2 = dup_idc i in
                let (add_deref, lhs_e, ctyp) = handle_temp_ref flags e ctyp in
                let (i2_exp, ccode) = add_val i2 ctyp flags (Some lhs_e) ccode sc loc in
                i2e := Env.add i lhs_e !i2e;
                ((if add_deref then cexp_deref lhs_e else lhs_e), ccode)
        | _ ->
            let e = make_id_exp i loc in
            let e = (match cinfo_ i loc with
            | CVal {cv_typ; cv_flags} ->
                let e = if (List.mem ValImplicitDeref cv_flags) then (cexp_deref e) else e in
                (match cv_typ with
                | CTypRawPtr(_, ctyp2) when ctyp2 = cv_typ -> cexp_deref e
                | _ -> e)
            | _ -> e)
            in (e, ccode)
    in

    let finalize_loop_body body_code loc =
        let end_loc = get_end_loc loc in
        let bctx = curr_block_ctx loc in
        let {bctx_kind; bctx_prologue; bctx_cleanup;
            bctx_break_used; bctx_continue_used;
            bctx_label; bctx_br_label; bctx_label_used} = bctx in
        let _ = if bctx_kind = BlockKind_Loop || bctx_kind = BlockKind_LoopND then
            () else raise_compile_err loc "cgen: the current context is not a loop" in
        let epilogue = List.rev bctx_cleanup in
        let (br_label, epilogue) =
            if bctx_label_used = 0 then
                (noid, epilogue)
            else
                (let parent_label_exp = parent_block_label end_loc in
                let (br_label, check_exn, args) =
                    if bctx_break_used + bctx_continue_used = 0 then
                        (noid, !std_FX_CHECK_EXN, [parent_label_exp])
                    else if bctx_br_label = noid then
                        (noid, !std_FX_CHECK_EXN_BREAK_CONTINUE, [parent_label_exp])
                    else
                        let br_label_exp = make_id_exp bctx_br_label end_loc in
                        (bctx_br_label, !std_FX_CHECK_EXN_BREAK_CONTINUE_ND, [parent_label_exp; br_label_exp]) in
                let handle_exn = make_call check_exn args CTypVoid end_loc in
                (br_label, ((CExp handle_exn) :: (epilogue @ ((CStmtLabel(bctx_label, end_loc)) :: [])))))
            in
        let body_code = epilogue @ body_code @ bctx_prologue in
        let body_stmt = rccode2stmt body_code loc in
        pop_block_ctx end_loc; (br_label, body_stmt)
    in

    let atom2cexp_ a save ccode sc loc =
        match a with
        | Atom.Lit(l) ->
            (match l with
            | LitString _ ->
                (* since FX_MAKE_STR(<string_literal>) creates a string with NULL reference counter and
                without allocating string in memory heap, there is no need to call destructor for it *)
                let e0 = make_call !std_FX_MAKE_STR ((make_lit_exp l loc) :: []) CTypString loc in
                let i = gen_temp_idc "slit" in
                let ccode = create_cdefval i CTypString [] "" (Some e0) ccode sc loc in
                ((make_id_exp i loc), ccode)
            | _ ->
                let e = make_lit_exp l loc in (e, ccode))
        | Atom.Id(i) -> id2cexp i save ccode sc loc
    in

    let atom2cexp a ccode sc loc = atom2cexp_ a false ccode sc loc
    in

    let decl_arr arr_ctyp shape data dstexp_r ccode sc loc =
        let dims = List.length shape in
        let shape_ctyp = CTypRawArray ([CTypConst], CTypInt) in
        let shape_arr = CExpInit(shape, (shape_ctyp, loc)) in
        let shape_id = gen_temp_idc "shape" in
        let ccode = create_cdefval shape_id shape_ctyp [] "" (Some shape_arr) ccode sc loc in
        let elem_ctyp = match arr_ctyp with
            | CTypArray(_, elem_ctyp) -> elem_ctyp
            | _ -> raise_compile_err loc "cgen: invalid output type of array construction expression"
            in
        let (data_exp, ccode) = match data with
            | [] -> ((make_nullptr loc), ccode)
            | _ ->
                let elems_ctyp = CTypRawArray ([CTypConst], elem_ctyp) in
                let elems_arr = CExpInit(data, (elems_ctyp, loc)) in
                let elems_id = gen_temp_idc "data" in
                let ccode = create_cdefval elems_id elems_ctyp [] "" (Some elems_arr) ccode sc loc in
                ((make_id_exp elems_id loc), ccode)
            in
        let sizeof_elem_exp = make_call !std_sizeof [CExpTyp(elem_ctyp, loc)] CTypSize_t loc in
        let free_f_exp = match (C_gen_types.get_free_f elem_ctyp true false loc) with
            | (_, (Some free_f)) -> free_f
            | _ -> make_nullptr loc
            in
        let copy_f_exp = match (C_gen_types.get_copy_f elem_ctyp true false loc) with
            | (_, Some(copy_f)) -> copy_f
            | _ -> make_nullptr loc
            in
        let (arr_exp, _) = get_dstexp dstexp_r "arr" arr_ctyp [] [] sc loc in
        let call_mkarr = make_call !std_fx_make_arr [(make_int_exp dims loc); (make_id_exp shape_id loc);
            sizeof_elem_exp; free_f_exp; copy_f_exp; data_exp; (cexp_get_addr arr_exp)] CTypCInt loc in
        (arr_exp, (add_fx_call call_mkarr ccode loc))
    in

    let add_ne_size_check check_list ccode lbl loc =
        match check_list with
        | e0 :: rest ->
            let check_exp = List.fold_left (fun e check_i ->
                CExpBinOp(COpLogicOr, e, check_i, (CTypBool, loc))) e0 rest in
            let check_call = make_call !std_FX_CHECK_NE_SIZE [check_exp; lbl] CTypVoid loc in
            (CExp check_call) :: ccode
        | _ -> ccode
    in

    (*
        cases:
           - input kexp is void:
                no expression should be stored anywhere,
                just need to update ccode and return "nop"
           - non-void expression,
                the result should be stored to some pre-defined value (dstid).
                returns this CExpIdent(dstid)
           - non-void expression (dstid=noid),
                the result should be returned as expression
                if needed, some temporary id is generated where the result is stored.
    *)
    let rec kexp2cexp kexp dstexp_r ccode sc =
        let (ktyp, kloc) = get_kexp_ctx kexp in
        let ctyp = C_gen_types.ktyp2ctyp ktyp kloc in
        let dummy_exp = make_dummy_exp kloc in
        (*let _ = (printf "processing kexp: "; K_pp.pprint_kexp_x kexp; printf "\n") in*)

        (* generate exp and then optionally generate the assignment if needed *)
        let (assign, result_exp, ccode) = match kexp with
        | KExpNop _ -> (false, dummy_exp, ccode)
        | KExpBreak _ ->
            let break_stmt = make_break_stmt kloc in
            (false, dummy_exp, break_stmt :: ccode)
        | KExpContinue _ ->
            let continue_stmt = make_continue_stmt kloc in
            (false, dummy_exp, continue_stmt :: ccode)
        | KExpAtom(a, _) ->
            let (e, ccode) = atom2cexp a ccode sc kloc in
            (true, e, ccode)
        | KExpBinOp(bop, a1, a2, _) ->
            let (ce1, ccode) = atom2cexp a1 ccode sc kloc in
            let (ce2, ccode) = atom2cexp a2 ccode sc kloc in
            (match bop with
            | OpLogicAnd | OpLogicOr ->
                raise_compile_err kloc "cgen: unexpected operation"
            | OpPow ->
                let (need_cast, ce1, ce2, rtyp, f) = match ctyp with
                    | CTypFloat(32) -> (false, ce1, ce2, ctyp, get_id "powf")
                    | CTypFloat(64) -> (false, ce1, ce2, ctyp, get_id "pow")
                    | _ ->
                        let ce1 = CExpCast(ce1, (CTypFloat 64), kloc) in
                        let ce2 = CExpCast(ce2, (CTypFloat 64), kloc) in
                        (true, ce1, ce2, (CTypFloat 64), get_id "pow") in
                let e = make_call f (ce1 :: ce2 :: []) rtyp kloc in
                let e = if need_cast then CExpCast(e, ctyp, kloc) else e in
                (true, e, ccode)
            | OpCons ->
                (*
                    l = e1 :: e2;
                    if !dstexp_r == None && (e2 is single-use id from u1vals) && (ce2 is id) then
                        re-use ce2 as l
                    else
                        obtain l using get_dstexp.
                *)
                let a2_id = match a2 with (Atom.Id i) when IdSet.mem i u1vals -> i | _ -> noid in
                let ce2_id = match ce2 with CExpIdent(i, _) -> i | _ -> noid in
                let (reuse_ce2, (l_exp, _)) = if (Utils.is_none !dstexp_r) && a2_id <> noid && ce2_id <> noid then
                        (true, (ce2, []))
                    else (false, (get_dstexp dstexp_r "lst" ctyp [] [] sc kloc)) in
                let lcon = C_gen_types.get_constructor ctyp true kloc in
                let call_cons = make_call lcon
                    (ce1 :: ce2 :: (make_lit_exp (LitBool (not reuse_ce2)) kloc) ::
                    (cexp_get_addr l_exp) :: []) CTypCInt kloc in
                (false, l_exp, (add_fx_call call_cons ccode kloc))
            | _ ->
                let c_bop = match bop with
                    | OpAdd -> COpAdd
                    | OpSub -> COpSub
                    | OpMul -> COpMul
                    | OpDiv -> COpDiv
                    | OpMod -> COpMod
                    | OpShiftLeft -> COpShiftLeft
                    | OpShiftRight -> COpShiftRight
                    | OpBitwiseAnd -> COpBitwiseAnd
                    | OpBitwiseOr -> COpBitwiseOr
                    | OpBitwiseXor -> COpBitwiseXor
                    | OpCompareEQ -> COpCompareEQ
                    | OpCompareNE -> COpCompareNE
                    | OpCompareLT -> COpCompareLT
                    | OpCompareLE -> COpCompareLE
                    | OpCompareGT -> COpCompareGT
                    | OpCompareGE -> COpCompareGE
                    | _ -> raise_compile_err kloc (sprintf "cgen: unsupported op '%s'" (binop_to_string bop))
                in (true, CExpBinOp(c_bop, ce1, ce2, (ctyp, kloc)), ccode))
        | KExpUnOp(OpMkRef, a1, _) ->
            let (ce1, ccode) = atom2cexp a1 ccode sc kloc in
            let (r_exp, _) = get_dstexp dstexp_r "r" ctyp [] [] sc kloc in
            let rcon = C_gen_types.get_constructor ctyp true kloc in
            let call_mkref = make_call rcon
                (ce1 :: (cexp_get_addr r_exp) :: []) CTypCInt kloc in
            (false, r_exp, (add_fx_call call_mkref ccode kloc))
        | KExpUnOp(OpDeref, a1, _) ->
            let (ce1, ccode) = atom2cexp a1 ccode sc kloc in
            (true, (cexp_deref ce1), ccode)
        | KExpUnOp(uop, a1, _) ->
            let (ce1, ccode) = atom2cexp a1 ccode sc kloc in
            let c_uop = match uop with
                | OpPlus -> COpPlus
                | OpNegate -> COpNegate
                | OpBitwiseNot -> COpBitwiseNot
                | OpLogicNot -> COpLogicNot
                | _ -> raise_compile_err kloc "cgen: unsupported unary op"
            in (true, CExpUnOp(c_uop, ce1, (ctyp, kloc)), ccode)
        | KExpIntrin(intr, args, _) ->
            (match (intr, args) with
            | (IntrinVariantTag, v :: []) ->
                let (cv, ccode) = atom2cexp v ccode sc kloc in
                let {ktp_ptr} = K_annotate_types.get_ktprops (get_atom_ktyp v kloc) kloc in
                let ctag = if ktp_ptr then
                        cexp_arrow cv (get_id "tag") CTypCInt
                    else
                        cexp_mem cv (get_id "tag") CTypCInt in
                (true, ctag, ccode)
            | (IntrinVariantCase, v :: (Atom.Id vn) :: []) ->
                let (cv, ccode) = atom2cexp v ccode sc kloc in
                let {ktp_ptr} = K_annotate_types.get_ktprops (get_atom_ktyp v kloc) kloc in
                let cvu = if ktp_ptr then
                        cexp_arrow cv (get_id "u") CTypAny
                    else
                        cexp_mem cv (get_id "u") CTypAny in
                let celem = cexp_mem cvu (get_orig_id vn) ctyp in
                (true, celem, ccode)
            | (IntrinListHead, l :: []) ->
                let (cl, ccode) = atom2cexp l ccode sc kloc in
                (true, (cexp_arrow cl (get_id "hd") ctyp), ccode)
            | (IntrinListTail, l :: []) ->
                let (cl, ccode) = atom2cexp l ccode sc kloc in
                (true, (cexp_arrow cl (get_id "hd") ctyp), ccode)
            | _ -> raise_compile_err kloc "cgen: unsupported KExpIntrin")
        | KExpSeq(el, _) ->
            let rec process_seq el ccode = match el with
                | [] -> (dummy_exp, ccode)
                | last :: [] -> kexp2cexp last dstexp_r ccode sc
                | e :: rest ->
                    let (_, ccode) = kexp2cexp e (ref None) ccode sc in
                    process_seq rest ccode
            in let (e, ccode) = process_seq el ccode in
            (false, e, ccode)
        | KExpIf(c, e1, e2, _) ->
            let (cc, ccode) = kexp2cexp c (ref None) ccode sc in
            let (dstexp, ccode) = get_dstexp dstexp_r "t" ctyp [] ccode sc kloc in
            let (_, ccode1) = kexp2cexp e1 dstexp_r [] sc in
            let (_, ccode2) = kexp2cexp e2 dstexp_r [] sc in
            let c_e1 = rccode2stmt ccode1 (get_kexp_loc e1) in
            let c_e2 = rccode2stmt ccode2 (get_kexp_loc e2) in
            (false, dstexp, (CStmtIf(cc, c_e1, c_e2, kloc)) :: ccode)

        | KExpCall(f, args, _) ->
            let ftyp = get_idk_typ f kloc in
            let (argtyps, rt) = match ftyp with
                | KTypFun(argtyps, rt) -> (argtyps, rt)
                | _ -> ([], ftyp)
                in
            let (args, ccode) = do_fold_left2 (fun (args, ccode) arg kt ->
                let (carg, ccode) = atom2cexp arg ccode sc kloc in
                let {ktp_pass_by_ref} = K_annotate_types.get_ktprops kt kloc in
                let carg = if ktp_pass_by_ref then (cexp_get_addr carg) else carg in
                (carg :: args, ccode)) ([], ccode) args argtyps kloc (sprintf "cgen: KExpCall(%s) fold_left2" (id2str f))
                in
            let (f_exp, fv_exp, have_fv_arg, is_nothrow, ccode) = match (kinfo_ f kloc) with
                | KFun {contents={kf_typ; kf_flags; kf_closure=(fv_arg, _); kf_loc}} ->
                    (* [TODO] check if f is declared already; if not, need to add it to the forward decl list *)
                    let f_exp = make_id_exp f kf_loc in
                    let have_fv_arg = List.mem FunConstr kf_flags in
                    let fv_exp = if fv_arg = noid then (make_lit_exp LitNil kloc) else
                        if f = (curr_func kloc) then CExpIdent((get_id "fx_fv"), (std_CTypVoidPtr, kf_loc)) else
                        raise_compile_err kloc "cgen: calling functions that need free vars is not supported yet"
                        in
                    let is_nothrow = List.mem FunNoThrow kf_flags in
                    (f_exp, fv_exp, have_fv_arg, is_nothrow, ccode)
                | KVal {kv_typ; kv_loc} ->
                    let (fclo_exp, ccode) = id2cexp f true ccode sc kloc in
                    let fclo_exp = make_id_exp f kv_loc in
                    let cftyp = C_gen_types.ktyp2ctyp kv_typ kloc in
                    let f_exp = cexp_mem fclo_exp (get_id "f") cftyp in
                    let fv_exp = cexp_mem fclo_exp (get_id "fv") std_CTypVoidPtr in
                    (f_exp, fv_exp, true, false, ccode)
                | _ -> raise_compile_err kloc (sprintf "cgen: the called '%s' is not a function nor value" (id2str f))
                in
            let {ktp_scalar=rt_scalar} = K_annotate_types.get_ktprops rt kloc in
            let crt = C_gen_types.ktyp2ctyp rt kloc in
            if is_nothrow && rt_scalar then
                let args = if have_fv_arg then fv_exp :: args else args in
                (true, CExpCall(f_exp, (List.rev args), (crt, kloc)), ccode)
            else
                let (args, dstexp, ccode) = if crt = CTypVoid then (args, dummy_exp, ccode) else
                    let (dstexp, ccode) = get_dstexp dstexp_r "res" crt [] ccode sc kloc in
                    (((cexp_get_addr dstexp) :: args), dstexp, ccode)
                    in
                let args = if have_fv_arg then fv_exp :: args else args in
                let fcall_rt = if is_nothrow then CTypVoid else CTypCInt in
                let fcall_exp = CExpCall(f_exp, (List.rev args), (fcall_rt, kloc)) in
                if is_nothrow then
                    (false, dstexp, (CExp fcall_exp) :: ccode)
                else
                    let ccode = add_fx_call fcall_exp ccode kloc in
                    (false, dstexp, ccode)

        | KExpMkTuple(args, _) | KExpMkRecord(args, _) ->
            let prefix = match kexp with KExpMkTuple(_, _) -> "tup" | _ -> "rec" in
            let (cargs, ccode) = List.fold_left (fun (cargs, ccode) a ->
                let (ca, ccode) = atom2cexp a ccode sc kloc in
                ((ca :: cargs), ccode)) ([], ccode) args in
            let tcon = C_gen_types.get_constructor ctyp false kloc in
            if tcon <> noid then
                let (t_exp, _) = get_dstexp dstexp_r prefix ctyp [] [] sc kloc in
                let call_mktup = make_call tcon
                    ((List.rev cargs) @ [cexp_get_addr t_exp]) CTypVoid kloc in
                (false, t_exp, (CExp call_mktup) :: ccode)
            else
                let tup = gen_temp_idc prefix in
                let e0 = CExpInit((List.rev cargs), (ctyp, kloc)) in
                let (t_exp, ccode) = add_val tup ctyp [] (Some e0) ccode sc kloc in
                (true, t_exp, ccode)
        | KExpMkClosure(f, fcv, args, _) -> raise_compile_err kloc "cgen: unsupported KExpMkClosure"
            (* TBD *)
        | KExpMkArray(shape, elems, _) ->
            let shape = List.map (fun i -> make_int_exp i kloc) shape in
            let (data, ccode) = List.fold_left (fun (data, ccode) a ->
                    let (e, ccode) = atom2cexp a ccode sc kloc in
                    (e :: data, ccode)) ([], ccode) elems in
            let (arr_exp, ccode) = decl_arr ctyp shape (List.rev data) dstexp_r ccode sc kloc in
            (false, arr_exp, ccode)
        | KExpAt(arr, idxs, _) ->
            (*
                there are 2 major cases:
                1. some of the idxs are ranges. Then the result is fx_arr_t
                2. all the ranges are scalars. Then the result is array element

                1. In the first case need to call a special function
                    `FX_CALL(fx_subarr(arr, ranges, subarr));`.
                    where ranges is array, concatenation of the following groups:
                    (0, idx) scalar indices
                    (1, a, b, delta) closed ranges [a:b:delta]
                        (if a was missing, it's set to 0, if delta was missing, it's set to 1)
                    (2, a, delta) open ranges [a::delta]
                        (if delta was missing, it's set to 1)

                2. In the second case need first to process each index idx_k (k=0..ndims-1):
                   2.1. If idx_k is "fast index" - great, just use the expression for the index
                        (process it via `atom2cexp`)
                   2.2. Otherwise we need to use the index more than once, so we need to
                        store it to temporary variable (unless it's already an indentifier or constant)
                        and add it to the check
                        `FX_CHKIDX(FX_CHKIDX1(arr, k1, idx_k1) || FX_CHKIDX1(arr, k2, idx_k2) ..., catch_label);`
                    if all the indices are fast indices, the whole check is excluded, of course.
                    then we return `(true, FX_PTR_{ndims}D(elem_ctyp, arr, idx0, ..., idx{ndims-1}), ccode)`
            *)
            let (arr_exp, ccode) = atom2cexp_ arr true ccode sc kloc in
            let need_subarr = List.exists (fun d -> match d with Domain.Range _ -> true | _ -> false) idxs in
            if need_subarr then
                let (range_data, ccode) = List.fold_left (fun (range_data, ccode) d ->
                    match d with
                    | Domain.Elem i | Domain.Fast i ->
                        let (i_exp, ccode) = atom2cexp i ccode sc kloc in
                        ((i_exp :: (make_int_exp 0 kloc) :: range_data), ccode)
                    | Domain.Range (a, b, delta) ->
                        let (a_exp, ccode) = atom2cexp a ccode sc kloc in
                        let (range_delta, ccode) = match b with
                            | Atom.Lit LitNil -> ((a_exp :: (make_int_exp 2 kloc) :: []), ccode)
                            | _ ->
                                let (b_exp, ccode) = atom2cexp b ccode sc kloc in
                                ((b_exp :: a_exp :: (make_int_exp 1 kloc) :: []), ccode)
                            in
                        let (d_exp, ccode) = atom2cexp delta ccode sc kloc in
                        (((d_exp :: range_delta) @ range_data), ccode)) ([], ccode) idxs
                    in
                let rdata_ctyp = CTypRawArray ([CTypConst], CTypInt) in
                let rdata_arr = CExpInit((List.rev range_data), (rdata_ctyp, kloc)) in
                let rdata_id = gen_temp_idc "ranges" in
                let ccode = create_cdefval rdata_id rdata_ctyp [] "" (Some rdata_arr) ccode sc kloc in
                let (subarr_exp, _) = get_dstexp dstexp_r "arr" ctyp [] [] sc kloc in
                let call_subarr = make_call !std_fx_subarr [(cexp_get_addr arr_exp);
                    (make_id_exp rdata_id kloc); (cexp_get_addr subarr_exp)] CTypCInt kloc in
                (false, subarr_exp, (add_fx_call call_subarr ccode kloc))
            else
                let elem_ctyp = ctyp in
                let (_, chk_exp_opt, i_exps, ccode) = List.fold_left (fun (dim, chk_exp_opt, i_exps, ccode) d ->
                    match d with
                    | Domain.Fast i ->
                        let (i_exp, ccode) = atom2cexp i ccode sc kloc in
                        (dim+1, chk_exp_opt, i_exp :: i_exps, ccode)
                    | Domain.Elem i ->
                        let (i_exp, ccode) = atom2cexp_ i true ccode sc kloc in
                        let chk_exp1 = make_call !std_FX_CHKIDX1 [arr_exp; (make_int_exp dim kloc); i_exp] CTypBool kloc in
                        let chk_exp_opt = match chk_exp_opt with
                            | Some(chk_exp) ->
                                let chk_exp = CExpBinOp(COpLogicOr, chk_exp, chk_exp1, (CTypBool, kloc)) in
                                Some chk_exp
                            | _ -> Some(chk_exp1)
                            in
                        (dim+1, chk_exp_opt, i_exp :: i_exps, ccode)
                    | _ -> raise_compile_err kloc "cgen: unexpected index type")
                    (0, None, [], ccode) idxs
                    in
                let ccode = match chk_exp_opt with
                    | Some (chk_exp) ->
                        let l = curr_block_label kloc in
                        let call_chkidx = make_call !std_FX_CHKIDX [chk_exp; l] CTypVoid kloc in
                        (CExp call_chkidx) :: ccode
                    | _ -> ccode
                    in
                let ndims = List.length idxs in
                let get_elem_exp = make_call (List.nth (!std_FX_PTR_xD) (ndims-1))
                    (CExpTyp (elem_ctyp,kloc) :: arr_exp :: (List.rev i_exps)) (make_ptr elem_ctyp) kloc in
                (true, (cexp_deref get_elem_exp), ccode)
        | KExpMem(a1, n, _) ->
            let (ce1, ccode) = id2cexp a1 false ccode sc kloc in
            let (ce1, relems) = get_struct ce1 in
            let nelems = List.length relems in
            let _ = if n < 0 || n >= nelems then
                raise_compile_err kloc (sprintf "the tuple/record element index %d is out of range [0, %d]" n nelems)
                else () in
            let (n_id, _) = List.nth relems n in
            (true, (cexp_mem ce1 n_id ctyp), ccode)
        | KExpAssign(i, e2, _) ->
            let (ktyp2, kloc2) = get_kexp_ctx e2 in
            let {ktp_complex} = K_annotate_types.get_ktprops ktyp2 kloc2 in
            let ccode =
                if ktp_complex then
                    let (i_exp, ccode) = id2cexp i true ccode sc kloc in
                    let ctyp = get_cexp_typ i_exp in
                    (if occurs_id_kexp i e2 then
                        (* if "i" occurs in "e2", we need to be safe and free "i" only after "e2" is computed *)
                        let (e_exp, ccode) = kexp2cexp e2 (ref None) ccode sc in
                        let ccode = C_gen_types.gen_free_code i_exp ctyp true false ccode kloc in
                        C_gen_types.gen_copy_code e_exp i_exp ctyp ccode kloc
                    else
                        (* otherwise, we can free "i" first and then compute "e2" directly at "i",
                           i.e. avoid extra copy in the end *)
                        let ccode = C_gen_types.gen_free_code i_exp ctyp true false ccode kloc in
                        let (_, ccode) = kexp2cexp e2 (ref (Some i_exp)) ccode sc in
                        ccode)
                else
                    (* if the type is simple then there is no need to save lhs into
                        intermediate variable, because it's used just once: lhs = rhs *)
                    let (i_exp, ccode) = id2cexp i false ccode sc kloc in
                    let (_, ccode) = kexp2cexp e2 (ref (Some i_exp)) ccode sc in
                    ccode
                in
            (false, dummy_exp, ccode)
        | KExpMatch(cases, _) ->
            (*code00; if(exp00) {
                code01; if(exp01) {
                ... if(exp0N0) {
                    action0; goto _fx_endmatch...;
            }...}}
            code10; if(exp01) {
                code11; if(exp11) {
                ... if(exp1N1) {
                    action1; goto _fx_endmatch...;
            }...}}
            ...
            #if <have_default_action>
            default_action; // if there is default case
            #else
            fx_status = FX_NO_MATCH_ERR;
            #endif
            [_fx_endmatch...:]
            FX_CHECK_EXN(parent_label);
            ...*)
            let (dstexp, ccode) = get_dstexp dstexp_r "mres" ctyp [] ccode sc kloc in
            let end_loc = get_end_loc kloc in
            let endmatch = make_label "endmatch" sc end_loc in
            let (have_default, need_em_label, ccode) = List.fold_left
                (fun (have_default, need_em_label, ccode) (checks_i, action_i) ->
                let (cchecks_i, pre_cchecks_i) = List.fold_left (fun (checks_i, pre_checks_i) check_ij ->
                    let (ccheck_ij, ccode_ij) = kexp2cexp check_ij (ref None) [] sc in
                    (ccheck_ij :: checks_i, ccode_ij :: pre_checks_i)) ([], []) checks_i
                    in
                let ai_loc = get_kexp_loc action_i in
                let new_have_default =
                    match checks_i with
                    | [] -> if have_default then raise_compile_err ai_loc
                        "cgen: more than one default action" else true
                    | _ -> have_default
                    in
                (* for each action we create a dedicated scope with its own cleanup section;
                   this is because it can be very lengthy match expressions with
                   many cases (like in compilers), so if we put all the
                   non-trivial locals into the common scope, the cleanup section
                   will be very inefficient *)
                let _ = new_block_ctx BlockKind_Case sc ai_loc in
                let (_, ai_ccode) = kexp2cexp action_i dstexp_r [] sc in
                let ai_end_loc = get_end_loc ai_loc in
                let bctx_i = curr_block_ctx kloc in
                let {bctx_prologue; bctx_cleanup;
                    bctx_label; bctx_label_used} = bctx_i in
                let epilogue = List.rev bctx_cleanup in
                let epilogue =
                    if bctx_label_used = 0 then
                        epilogue
                    else
                        epilogue @ (CStmtLabel (bctx_label, ai_end_loc) :: [])
                    in
                let (new_need_em_label, epilogue) = if new_have_default then
                        (need_em_label, epilogue)
                    else
                        (true, ((CStmtGoto (endmatch, ai_end_loc)) :: epilogue))
                    in
                let ai_ccode = epilogue @ ai_ccode @ bctx_prologue in
                let ai_stmt = rccode2stmt ai_ccode ai_loc in
                let _ = pop_block_ctx ai_end_loc in
                (* generate the nested if statement;
                 [TODO] need to replace it with one
                 `if (expi0 && expi1 && ... && expi{n-1}) { action_i }`
                 if possible (i.e. when all pre_check_ij's are empty) *)
                let case_ccode = do_fold_left2 (fun case_ccode check_ij pre_check_ij ->
                    let case_stmt = rccode2stmt case_ccode ai_end_loc in
                    let checkij_loc = get_cexp_loc check_ij in
                    let if_stmt = CStmtIf(check_ij, case_stmt, (CStmtNop ai_end_loc), checkij_loc) in
                    if_stmt :: pre_check_ij) (ai_stmt :: []) cchecks_i pre_cchecks_i ai_end_loc "cgen: KExpMatch fold_left2"
                    in
                (new_have_default, new_need_em_label, case_ccode @ ccode)) (false, false, ccode) cases
                in
            let ccode = if have_default then ccode else
                let fx_status = CExpIdent((get_id "fx_status"), (CTypCInt, end_loc)) in
                let fx_no_match_err = CExpIdent((get_id "FX_NO_MATCH_ERR"), (CTypCInt, end_loc)) in
                CExp (CExpBinOp(COpAssign, fx_status, fx_no_match_err, (CTypVoid, end_loc))) :: ccode
                in
            let ccode = if not need_em_label then ccode
                else (CStmtLabel (endmatch, end_loc)) :: ccode in
            let parent_label_exp = parent_block_label end_loc in
            let check_exn = make_call !std_FX_CHECK_EXN (parent_label_exp::[]) CTypVoid end_loc in
            (false, dstexp, (CExp check_exn) :: ccode)
        | KExpTryCatch(try_e, catch_e, _) -> raise_compile_err kloc "cgen: unsupported KExpCatch"
            (* create new block context, generate temporary value to assign the try result.
               generate code for try_e. then generate code for catch similarly to kexpmatch:

               tvtype try_val = ...;
               try_code;
               try_val = try_code_result;

            try_cleanup:
               ...; // call destructors for complex data structures used in try
               if(fx_status >= 0) goto end_catch;

               int code = fx_status;
               fx_status = FX_OK;
               ... // code to match the exception
               // if not caught
               fx_status = FX_OK; goto next_label_in_stack; // propagate the unhandled exception
            end_catch:
               // here we jump after each successful try or after successful catch.
            *)
        | KExpThrow(i, _) -> raise_compile_err kloc "cgen: unsupported KExpThrow"
            (*
                set the current exception to i, which includes setting fx_status=i.tag;
                then "goto try_cleanup";
            *)
        | KExpCast(a1, kt, _) ->
            let (ce1, ccode) = atom2cexp a1 ccode sc kloc in
            let ct = C_gen_types.ktyp2ctyp kt kloc in
            (true, CExpCast(ce1, ct, kloc), ccode)
        | KExpMap(e_kdl_l, body, flags, _) -> raise_compile_err kloc "cgen: unsupported KExpMap"
            (*
                TBD
            *)
        | KExpFor(kdl, body, flags, _) ->
            let lbl = curr_block_label kloc in
            let for_loc = get_start_loc kloc in
            let end_for_loc = get_end_loc kloc in
            let for_letters = ["i"; "j"; "k"; "l"; "m"] in
            let for_err_msg i msg = sprintf "cgen: %i-th iteration clause: %s" i msg in
            let (_, ndims, nlists, is_open_loop) = List.fold_left (fun (k, ndims, nlists, is_open_loop) (_, dom_i) ->
                let (ndims_i, nlists_i, is_open_loop_i) =
                    (match dom_i with
                    | Domain.Range(_, (Atom.Lit LitNil), _) -> (1, 0, true)
                    | Domain.Range(_, _, _) -> (1, 0, false)
                    | Domain.Elem (Atom.Id d) ->
                        (match (get_idk_typ d for_loc) with
                        | KTypList _ -> (1, 1, true)
                        | KTypString -> (1, 0, false)
                        | KTypArray(n, _) -> (n, 0, false)
                        | _ -> raise_compile_err for_loc (for_err_msg k "unsupported type of collection in the for loop"))
                    | _ -> raise_compile_err for_loc (for_err_msg k "unsupported type of the for loop iteration domain"))
                    in
                if ndims <> 0 && ndims <> ndims_i then
                    raise_compile_err for_loc (for_err_msg k
                    (sprintf "dimensionalities of the simultaneously iterated collections/ranges are not the same (...%d...%d...)" ndims ndims_i))
                else ();
                (k+1, ndims_i, nlists + nlists_i, (is_open_loop && is_open_loop_i))) (0, 0, 0, true) kdl
                in
            (*
                [TODO] parallel loops are not supported yet.

                Compute various elements/attributes/parts of the for loop:

                i_exps: i, j, k etc. - for-loop integer iteration variables (only for closed ranges and arrays, not for open ranges or lists)
                n_exps: n0, n1, n2 etc. - for-loop limits (also integers)
                for_checks0: extra checks (besides `i < n0`, `j < n1`, `k < n2` etc.). Used for iteration over list(s): lst0[!=0], lst1[!=0] etc. ...
                incr_exps0: extra increment operations (besides `i++`, `j++`, `k++`). Used for iteration over lists(s): lst0=lst0->tl, lst1=lst1->tl, ...
                init_checks: the checks that we need to put before the loop into FX_CHECK_NE_SIZE((check0 || check1 || check2 ...), catch_label) macro.
                    We check that all closed ranges and all simultaneously iterated 1D or nD arrays have the same shape.
                    The lists sizes are not checked because we don't know their sizes before the loop,
                        and we don't want to make extra loop to count their lengths.
                init_ccode: inital code for the loop:
                    Save all the arrays, lists etc. if needed to guarantee that they are not destroyed
                        in the middle of loop (and that they are computed just once).
                    Save start:stop:step expressions in the ranges.
                    Compute n_i=FX_LOOP_COUNT(start_i, stop_i, step_i) for each range.
                    Save n0_i,n1_i,...=arr_i.dim[0,1,...].size.
                    init_ccode does not include the check for size/shape equality/inequality (see init_checks). It's added after this let statement.
                pre_body_ccode: code before the inner-most loop. Now it's used only for arrays:
                    elem_type0* ptr_arr0 = FX_PTR_<ndims>D(arr_0, i, j, ..., 0);
                    elem_type1* ptr_arr1 = FX_PTR_<ndims>D(arr_1, i, j, ..., 0);
                    that is, get the pointers to the linear slices of the iterated arrays.
                    [TODO] we can check whether all the iterated arrays are continuous and modify n_exps accordingly,
                        e.g. in 2D case with 2 arrays A and B:
                        if(FX_ARR_CONTINUOUS(A) && FX_ARR_CONTINUOUS(B)) {
                            n1 *= n0;
                            n0 = 1;
                        }
                        with such a trick, the arrays are processed completely with a single run of inner loop with minimal overhead.
                    note that in the case of 1D array processing pre_body_ccode immediately follows init_ccode and init_checks.
                body_pairs: a list of pairs (v_0, exp_0), (v_1, exp_1), ...
                    This is a list of values that need to be extracted in the beginning of loop body.
                    We keep them separately without forming expressions v_0 = exp_0, because in the case of complex types, e.g. strings or nested arrays,
                    we need to initalize v_i separately and put the destructors to the for-loop body cleanup section. All this is done using add_val,
                    but for that we need to form a nested for-loop body context, which we form after this let.
                post_checks: the checks that we need to put after the loop into FX_CHECK_NE_SIZE((check0 || check1 || check2 ...), catch_label) macro.
                    We check that all closed ranges/arrays and all simultaneously iterated lists finished at once.
                    In this let statement we put only lists. The range check is added later if needed.
                    a) just list case:
                    fx_list0_t lst0 = list0;
                    fx_list1_t lst1 = list1;
                    for(; lst0 && lst1; lst0=lst0->tl, lst1=lst1->tl) {
                        int a=lst0->hd, b=lst1->hd;
                        s += abs(a-b);
                    }
                    FX_CHECK_NE_SIZE(lst0 || lst1, catch_label); // check that both lists finished simultaneously.
                    b) list and "closed range"/array case:
                    fx_list0_t lst0 = list0;
                    fx_list1_t lst1 = list1;
                    for(int i = 0; i < n && lst0 && lst1; lst0=lst0->tl, lst1=lst1->tl) {
                        int a=lst0->hd, b=lst1->hd;
                        if(a!=b) {printf("diff=%d at %d\n", abs(a-b), i);}
                    }
                    FX_CHECK_NE_SIZE(i < n || lst0 || lst1, catch_label); // check that both lists and the range finished simultaneously.
            *)
            let (_, i_exps, n_exps, for_checks0, incr_exps0, init_checks, init_ccode, pre_body_ccode, body_pairs, post_checks) = List.fold_left
                (fun (k, i_exps, n_exps, for_checks, incr_exps, init_checks, init_ccode,
                    pre_body_ccode, body_pairs, post_checks) (iter_val_i, dom_i) ->
                    let (i_exps, n_exps, for_checks, incr_exps, init_checks,
                        init_ccode, pre_body_ccode, body_pairs, post_checks) = match dom_i with
                        | Domain.Range(a, b, delta) ->
                            let (aug_add_delta, add_delta, d_exp, init_ccode) = match delta with
                                | Atom.Lit(LitInt 0L) ->
                                    raise_compile_err for_loc (for_err_msg k "the iteration step is zero")
                                | Atom.Lit (LitInt i) ->
                                    let (aug_add_delta, add_delta, i) = if i > 0L then
                                            (COpAugAdd, COpAdd, i)
                                        else
                                            (COpAugSub, COpSub, (Int64.neg i))
                                        in
                                    (aug_add_delta, add_delta, (make_int__exp i for_loc), init_ccode)
                                | _ ->
                                    let (d_exp, init_ccode) = atom2cexp_ delta true init_ccode sc for_loc in
                                    let init_ccode = (CExp (make_call !std_FX_CHECK_ZERO_STEP [d_exp; lbl] CTypVoid for_loc)) :: init_ccode in
                                    (COpAugAdd, COpAdd, d_exp, init_ccode)
                                in
                            (match b with
                            | Atom.Lit LitNil ->
                                (*
                                    int iter_var = a;
                                    for(;;iter_var += delta) {
                                        ...
                                    }
                                *)
                                let (a_exp, init_ccode) = atom2cexp_ a false init_ccode sc for_loc in
                                let init_ccode = create_cdefval iter_val_i CTypInt [ValMutable] "" (Some a_exp) init_ccode sc for_loc in
                                let i_exp = make_id_exp iter_val_i for_loc in
                                let incr_i_exp = CExpBinOp(aug_add_delta, i_exp, d_exp, (CTypVoid, for_loc)) in
                                (i_exps, n_exps, for_checks, incr_i_exp :: incr_exps, init_checks, init_ccode, pre_body_ccode, body_pairs, post_checks)
                            | _ ->
                                (*
                                    // save the loop counter
                                    int n = FX_LOOP_COUNT(a, b, delta); // n === loop_counter
                                    // or check it
                                    FX_CHECK_NE_SIZE(FX_LOOP_COUNT(a, b, delta) != loop_counter, catch_label);
                                    for(int i = 0; i < loop_counter; i++) {
                                        int iter_var = a + i*delta; // compute the current value
                                    }
                                *)
                                let (a_exp, init_ccode) = atom2cexp_ a true init_ccode sc for_loc in
                                let (b_exp, init_ccode) = atom2cexp_ b true init_ccode sc for_loc in
                                let calc_n_exp = make_call !std_FX_LOOP_COUNT [a_exp; b_exp; d_exp] CTypInt for_loc in
                                let (i_exp, i_exps, n_exps, init_checks, init_ccode) = match (i_exps, n_exps) with
                                    | (prev_i :: _, prev_n :: _) ->
                                        (prev_i, i_exps, n_exps,
                                        (CExpBinOp(COpCompareNE, prev_n, calc_n_exp, (CTypBool, for_loc))) :: init_checks,
                                        init_ccode)
                                    | _ ->
                                        let (n_exp, init_ccode) = add_val (gen_temp_idc "n") CTypInt
                                            [] (Some calc_n_exp) init_ccode sc for_loc in
                                        let (i_exp, _) = add_val (gen_temp_idc "i") CTypInt [ValMutable] None [] sc for_loc in
                                        (i_exp, i_exp :: i_exps, n_exp :: n_exps, init_checks, init_ccode)
                                    in
                                let calc_i_exp = CExpBinOp(add_delta, a_exp, CExpBinOp(COpMul, i_exp, d_exp, (CTypInt, for_loc)), (CTypInt, for_loc)) in
                                (i_exps, n_exps, for_checks, incr_exps, init_checks, init_ccode, pre_body_ccode,
                                    ((iter_val_i, calc_i_exp) :: body_pairs), post_checks))
                        | Domain.Elem(Atom.Id col) ->
                            let ktyp = get_idk_typ col for_loc in
                            let ctyp = C_gen_types.ktyp2ctyp ktyp for_loc in
                            (* before running iteration over a collection,
                               we need to make sure that it will not be deallocated in the middle *)
                            let (col_exp, init_ccode) = if occurs_id_kexp col body then
                                    let (src_exp, init_ccode) = atom2cexp (Atom.Id col) init_ccode sc for_loc in
                                    let (col_exp, init_ccode) = get_dstexp (ref None) (pp_id2str col) ctyp [] init_ccode sc for_loc in
                                    let init_ccode = C_gen_types.gen_copy_code src_exp col_exp ctyp ccode kloc in
                                    (col_exp, init_ccode)
                                else
                                    atom2cexp_ (Atom.Id col) true init_ccode sc for_loc
                                in
                            (match ktyp with
                            | KTypList et ->
                                (*
                                    some_lst_t lst = col;
                                    for(; lst [&& ...]; lst=lst->tl) {
                                        some_lst_elem_t x = lst->hd;
                                        ...
                                    }
                                    // optional check
                                    FX_CHECK_NE_SIZE(!lst || ..., catch_label);
                                *)
                                let l_id = gen_temp_idc "lst" in
                                let init_ccode = create_cdefval l_id ctyp [ValMutable] "" (Some col_exp) init_ccode sc for_loc in
                                let l_exp = make_id_exp l_id for_loc in
                                let l_next_exp = CExpBinOp(COpAssign, l_exp, (cexp_arrow l_exp (get_id "tl") ctyp), (CTypVoid, for_loc)) in
                                let c_et = C_gen_types.ktyp2ctyp et for_loc in
                                let get_hd_exp = cexp_arrow l_exp (get_id "hd") c_et in
                                (i_exps, n_exps, (l_exp :: for_checks), (l_next_exp :: incr_exps), init_checks, init_ccode,
                                pre_body_ccode, ((iter_val_i, get_hd_exp) :: body_pairs), (l_exp :: post_checks))
                            | KTypString ->
                                (*
                                    // either save the length
                                    int_ len = str->length; // loop_counter === len
                                    // or check it
                                    FX_CHECK_NE_SIZE(str->length != loop_counter, catch_label);
                                    for(int i = 0; i < loop_counter; i++) {
                                        char_ x = str->data[i];
                                        ...
                                    }
                                *)
                                let calc_n_exp = cexp_mem col_exp (get_id "length") CTypInt in
                                let (i_exp, i_exps, n_exps, init_checks, init_ccode) = match (i_exps, n_exps) with
                                    | (prev_i :: _, prev_n :: _) ->
                                        (prev_i, i_exps, n_exps,
                                        (CExpBinOp(COpCompareNE, prev_n, calc_n_exp, (CTypBool, for_loc))) :: init_checks,
                                        init_ccode)
                                    | _ ->
                                        let (n_exp, init_ccode) = add_val (gen_temp_idc "len") CTypInt
                                            [] (Some calc_n_exp) init_ccode sc for_loc in
                                        let (i_exp, _) = add_val (gen_temp_idc "i") CTypInt [ValMutable] None [] sc for_loc in
                                        (i_exp, i_exp :: i_exps, n_exp :: n_exps, init_checks, init_ccode)
                                    in
                                let get_chars = cexp_mem col_exp (get_id "data") (make_const_ptr CTypUniChar) in
                                let get_char_i = CExpBinOp(COpArrayElem, get_chars, i_exp, (CTypUniChar, for_loc)) in
                                (i_exps, n_exps, for_checks, incr_exps, init_checks, init_ccode,
                                pre_body_ccode, ((iter_val_i, get_char_i) :: body_pairs), post_checks)
                            | KTypArray(ndims, et) ->
                                (*
                                    // either save all the dimensions
                                    int_ ni = FX_ARR_SIZE(arr, 0);
                                    int_ nj = FX_ARR_SIZE(arr, 1);
                                    ...
                                    // or check them
                                    FX_CHECK_NE_SIZE(FX_ARR_SIZE(arr, 0) != ni || FX_ARR_SIZE(arr, 1) != nj ..., catch_label);
                                    for(int i = 0; i < ni; i++) {
                                        // before the inner-most loop
                                        arr_elem_t* ptr
                                        for(int j = 0; j < nj; j++) {
                                        char_ x = str->data[i];
                                        ...
                                    }
                                *)
                                let (i_exps, n_exps, init_checks, init_ccode) = if n_exps = [] then
                                        let (i_exps, n_exps, init_ccode) = List.fold_left (fun (i_exps, n_exps, init_ccode) k ->
                                            let calc_n_exp = make_call !std_FX_ARR_SIZE [col_exp; (make_int_exp k for_loc)] CTypInt for_loc in
                                            let iter_letter = List.nth for_letters k in
                                            let (n_exp, init_ccode) = add_val (gen_temp_idc ("n" ^ iter_letter)) CTypInt
                                                [] (Some calc_n_exp) init_ccode sc for_loc in
                                            let (i_exp, _) = add_val (gen_temp_idc iter_letter) CTypInt [ValMutable] None [] sc for_loc in
                                            (i_exp :: i_exps, n_exp :: n_exps, init_ccode))
                                            ([], [], init_ccode) (List.init ndims (fun k -> k))
                                        in ((List.rev i_exps), (List.rev n_exps), init_checks, init_ccode)
                                    else
                                        let (_, init_checks) = List.fold_left (fun (k, init_checks) prev_nk ->
                                            let calc_n_exp = make_call !std_FX_ARR_SIZE [col_exp; (make_int_exp k for_loc)] CTypInt for_loc in
                                            let init_check_k = CExpBinOp(COpCompareNE, prev_nk, calc_n_exp, (CTypBool, for_loc)) in
                                            (k+1, init_check_k :: init_checks)) (0, init_checks) n_exps
                                        in (i_exps, n_exps, init_checks, init_ccode)
                                    in
                                let c_et = C_gen_types.ktyp2ctyp et for_loc in
                                let c_et_ptr = make_ptr c_et in
                                let rev_i_exps = List.rev i_exps in
                                let inner_idx = List.hd rev_i_exps in
                                let slice_idxs = List.rev ((make_int_exp 0 for_loc) :: (List.tl rev_i_exps)) in
                                let get_arr_slice = make_call (List.nth (!std_FX_PTR_xD) (ndims-1))
                                    (CExpTyp (c_et, for_loc) :: col_exp :: slice_idxs) c_et_ptr for_loc in
                                let ptr_id = gen_temp_idc ("ptr_" ^ (pp_id2str col)) in
                                let pre_body_ccode = create_cdefval ptr_id c_et_ptr [] "" (Some get_arr_slice) pre_body_ccode sc for_loc in
                                let ptr_exp = make_id_exp ptr_id for_loc in
                                let get_arr_elem = CExpBinOp(COpArrayElem, ptr_exp, inner_idx, (c_et, for_loc)) in
                                (i_exps, n_exps, for_checks, incr_exps, init_checks, init_ccode,
                                pre_body_ccode, ((iter_val_i, get_arr_elem) :: body_pairs), post_checks)
                            | _ -> raise_compile_err for_loc (for_err_msg k
                                (sprintf "cannot iterate over '%s'; it needs to be array, list or string" (id2str col)))
                            )
                        | _ ->
                            raise_compile_err for_loc (for_err_msg k "unsupported type of the for loop iteration domain")
                    in (k+1, i_exps, n_exps, for_checks, incr_exps, init_checks,
                        init_ccode, pre_body_ccode, body_pairs, post_checks))
                    (0, [], [], [], [], [], [], [], [], []) kdl
                in
            let _ = new_block_ctx (if ndims = 1 then BlockKind_Loop else BlockKind_LoopND) sc kloc in
            (* inside the loop body context form `<etyp> v=e` expressions (or more complex ones in the case of complex types) *)
            let body_ccode = List.fold_left (fun body_ccode (v, e) ->
                let (ctyp, loc) = get_cexp_ctx e in
                let (_, body_ccode) = add_val v ctyp [] (Some e) body_ccode sc loc in
                body_ccode) [] body_pairs
                in
            (* add the loop body itself *)
            let (_, body_ccode) = kexp2cexp body (ref None) body_ccode sc in
            let body_loc = get_kexp_loc body in
            (* add the initialization and the cleanup sections, if needed *)
            let (br_label, body_stmt) = finalize_loop_body body_ccode body_loc in

            (* add initial size checks *)
            let init_ccode = add_ne_size_check (List.rev init_checks) init_ccode lbl for_loc in
            (* in the case of 1D arrays put pre_body_ccode immediately after initialization code *)
            let (init_ccode, pre_body_ccode) = if ndims > 1 then (init_ccode, pre_body_ccode)
                else (pre_body_ccode @ init_ccode, []) in
            (* for (possibly nested) for statement *)
            let (k_final, for_stmt) = do_fold_left2 (fun (k, for_stmt) i_exp n_exp ->
                let ifor_loc = get_cexp_loc n_exp in
                let init_exps = [CExpBinOp(COpAssign, i_exp, (make_int_exp 0 ifor_loc), (CTypVoid, ifor_loc))] in
                let check_exp = CExpBinOp(COpCompareLT, i_exp, n_exp, (CTypBool, ifor_loc)) in
                let incr_exps = [CExpUnOp(COpSuffixInc, i_exp, (CTypInt, ifor_loc))] in
                let (check_exp, incr_exps) = if k > 0 then (check_exp, incr_exps) else
                    let check_exp = List.fold_left (fun check_exp e ->
                        CExpBinOp(COpLogicAnd, check_exp, e, (CTypBool, ifor_loc)))
                        check_exp (List.rev for_checks0) in
                    (check_exp, incr_exps @ (List.rev incr_exps0))
                    in
                let for_stmt = CStmtFor((Some CTypInt), init_exps, (Some check_exp), incr_exps, for_stmt, kloc) in
                (k+1, (if k > 0 || pre_body_ccode = [] then for_stmt else
                    rccode2stmt (for_stmt :: pre_body_ccode) for_loc))) (0, body_stmt) (List.rev i_exps) (List.rev n_exps)
                    for_loc "cgen: for-loop fold_left2"
                in
            (* if we have open loop (i.e. i_exps and n_exps are empty lists),
               we still need to form the for-loop statement *)
            let for_stmt = if k_final > 0 then for_stmt else
                let check_exp_opt = List.fold_left (fun check_exp_opt check_i ->
                    Some (match check_exp_opt with
                    | Some e -> CExpBinOp(COpLogicAnd, e, check_i, (CTypBool, for_loc))
                    | _ -> check_i)) None (List.rev for_checks0) in
                CStmtFor(None, [], check_exp_opt, incr_exps0, body_stmt, kloc)
                in
            (* add "post" checks, if needed *)
            let post_checks = List.rev post_checks in
            let post_checks = if post_checks = [] || i_exps = [] then post_checks else
                (CExpBinOp(COpCompareLT, (List.hd i_exps), (List.hd n_exps), (CTypBool, end_for_loc))) :: post_checks
                in
            let post_ccode = add_ne_size_check post_checks [] lbl end_for_loc in
            (* add the non-local "break" label if needed *)
            let post_ccode = if br_label = noid then post_ccode else (CStmtLabel(br_label, end_for_loc)) :: post_ccode in
            (* add it all to ccode; nothing to return/assign, since "for-loop" is "void" expression *)
            (false, dummy_exp, post_ccode @ (for_stmt :: (init_ccode @ ccode)))
        | KExpWhile(c, body, _) ->
            let _ = new_block_ctx BlockKind_Loop sc kloc in
            let (cc, cc_code) = kexp2cexp c (ref None) [] sc in
            let (is_for_loop, check_code) =
                (match (cc, cc_code) with
                | (CExpLit((LitBool true), _), []) -> (true, [])
                | (_, []) -> (false, [])
                | _ ->
                    let cc_loc = get_cexp_loc cc in
                    let not_cc = CExpUnOp(COpLogicNot, cc, (CTypBool, cc_loc)) in
                    let break_stmt = make_break_stmt cc_loc in
                    let check_cc = CStmtIf(not_cc, break_stmt, CStmtNop(cc_loc), cc_loc) in
                    (true, check_cc :: cc_code))
                in
            let (e, body_ccode) = kexp2cexp body (ref None) [] sc in
            let body_ccode = ((cexp2stmt e) :: body_ccode) @ check_code in
            let (_, body_stmt) = finalize_loop_body body_ccode kloc in
            let loop_stmt = (if is_for_loop then
                    CStmtFor(None, [], None, [], body_stmt, kloc)
                else
                    CStmtWhile(cc, body_stmt, kloc))
            in
            (false, dummy_exp, loop_stmt :: ccode)
        | KExpDoWhile(body, c, _) ->
            let _ = new_block_ctx BlockKind_Loop sc kloc in
            let (e, body_ccode) = kexp2cexp body (ref None) [] sc in
            let (cc, cc_code) = kexp2cexp c (ref None) [] sc in
            let (is_for_loop, check_code) =
                (match (cc, cc_code) with
                | (CExpLit((LitBool true), _), []) -> (true, [])
                | (_, []) -> (false, [])
                | _ ->
                    let cc_loc = get_cexp_loc cc in
                    let not_cc = CExpUnOp(COpLogicNot, cc, (CTypBool, cc_loc)) in
                    let break_stmt = make_break_stmt cc_loc in
                    let check_cc = CStmtIf(not_cc, break_stmt, CStmtNop(cc_loc), cc_loc) in
                    (true, check_cc :: cc_code))
                in
            let body_ccode = check_code @ body_ccode in
            let (_, body_stmt) = finalize_loop_body body_ccode kloc in
            let loop_stmt = if is_for_loop then
                    CStmtFor(None, [], None, [], body_stmt, kloc)
                else
                    CStmtDoWhile(body_stmt, cc, kloc)
            in
            (false, dummy_exp, loop_stmt :: ccode)
        | KExpCCode(ccode_str, _) ->
            if (curr_block_ctx kloc).bctx_kind <> BlockKind_Global then
                raise_compile_err kloc "cgen: unexpected ccode expression"
            else ();
            top_ccode := CExp (CExpCCode(ccode_str, kloc)) :: !top_ccode;
            (false, dummy_exp, ccode)
        | KDefVal(i, e2, _) ->
            let {kv_typ; kv_flags} = match (kinfo_ i kloc) with
                | KVal kv -> kv
                | _ -> raise_compile_err kloc (sprintf "'%s' is not a value/variable" (id2str i))
                in
            let {ktp_ptr; ktp_complex; ktp_scalar} = K_annotate_types.get_ktprops kv_typ kloc in
            let ctyp = C_gen_types.ktyp2ctyp kv_typ kloc in
            let bctx = curr_block_ctx kloc in
            let is_global = bctx.bctx_kind == BlockKind_Global in
            let is_temp_ref = List.mem ValTempRef kv_flags in
            (* there are 3 cases (ce2 denotes e2 converted to C):
                1. definition "ctyp i = ce2" is not added; instead, i is replaced with ce2.
                2. i is defined separately: "ctyp i[={}|0];" and then
                   expression is compiled with 'i' as the destination.
                3. i is defined and initialized at once: "ctyp i=ce2;"
            *)
            let ccode =
                if (is_temp_ref ||
                    (ktp_scalar && (List.mem ValTemp kv_flags))) &&
                    (IdSet.mem i u1vals) then
                    let (ce2, ccode) = kexp2cexp e2 (ref None) ccode sc in
                    (* we still need to declare i to be able to access its type *)
                    let _ = create_cdefval i ctyp kv_flags "" None [] sc kloc in
                    let _ = i2e := Env.add i ce2 !i2e in
                    ccode
                else if is_temp_ref then
                    let (ce2, ccode) = kexp2cexp e2 (ref None) ccode sc in
                    let (i_exp, ccode) = add_val i (make_ptr ctyp) kv_flags
                        (Some (cexp_get_addr ce2)) ccode sc kloc in
                    (*let _ = i2e := Env.add i (cexp_deref i_exp) !i2e in*)
                    ccode
                else if ktp_complex || is_global ||
                    (match e2 with
                    | KExpUnOp(OpMkRef, _, _) -> true
                    | KExpBinOp _ | KExpUnOp _ | KExpIntrin _ | KExpMkTuple _
                    | KExpMkRecord _ | KExpAt _ | KExpMem _ | KExpCast _ | KExpCCode _ -> false
                    | _ -> true) then
                    let (i_exp, delta_code) = add_val i ctyp kv_flags None [] sc kloc in
                    let ccode = if is_global then (bctx.bctx_prologue <- delta_code @ bctx.bctx_prologue; ccode)
                        else delta_code @ ccode in
                    let (_, ccode) = kexp2cexp e2 (ref (Some i_exp)) ccode sc in
                    ccode
                else
                    let (ce2, ccode) = match (ktp_ptr, e2) with
                        | (_, KExpCCode(s, (_, loc))) -> (CExpCCode(s, loc), ccode)
                        | (false, KExpAtom((Atom.Lit LitNil), (_, loc))) -> (CExpInit([], (ctyp, loc)), ccode)
                        | _ -> kexp2cexp e2 (ref None) ccode sc
                        in
                    let (_, ccode) = add_val i ctyp kv_flags (Some ce2) ccode sc kloc in
                    ccode
                in
            (false, dummy_exp, ccode)
        | KDefFun kf ->
            (*
                generate new context.
                generate ccode for the body with dstid=fx_result.
                add the prologue and the cleanup sections to the generated c code.
                before cleanup possibly insert a label if needed.
                prior to the cleanup save the output expression if needed
                (because it may use elements that will be released)
                after cleanup section add "return fx_status;" if needed or
                "return ret_exp"; if the function is nothrow and is not void.

                handle the case of 'c code'-body separately
            *)
            let {kf_name; kf_typ; kf_closure=(arg_id, _); kf_body; kf_cname; kf_flags; kf_scope; kf_loc} = !kf in
            let _ = new_block_ctx (BlockKind_Fun kf_name) sc kloc in
            let (argtyps, rt, args, cf) = match (cinfo_ kf_name kf_loc) with
                | CFun ({contents={cf_typ=CTypFun(argtyps, rt); cf_args}} as cf) -> (argtyps, rt, cf_args, cf)
                | _ -> raise_compile_err kf_loc "cgen: the function declaration was not properly converted"
                in
            (* in the list of parameters the return value (if any) can be the last one
               (in the case of no-throw functions) or pre-last one
               (in the case of functions that may throw exceptions)
            *)
            let new_body = (match kf_body with
                | KExpCCode(code, (_, loc)) -> CExp (CExpCCode(code, loc)) :: []
                | _ ->
                    let (real_args, real_argtyps, retid) = match ((List.rev args), (List.rev argtyps)) with
                        | ((retid :: rargs), (_ :: ratyps)) when (get_idc_cname retid kloc) = "fx_result" -> (rargs, ratyps, retid)
                        | ((_ :: retid :: rargs), (_ :: _ :: ratyps)) when (get_idc_cname retid kloc) = "fx_result" -> (rargs, ratyps, retid)
                        | (rargs, ratyps) -> (rargs, ratyps, noid)
                        in
                    let dstexp_r = ref (if retid = noid then None else
                        (Some (cexp_deref (make_id_exp retid kf_loc))))
                        in
                    let status_id = if (List.mem FunNoThrow kf_flags) then noid else gen_temp_idc "fx_status" in
                    let ccode = if status_id = noid then []
                        else create_cdefval status_id CTypCInt [ValMutable] "fx_status"
                            (Some (make_int_exp 0 kf_loc)) [] kf_scope kf_loc
                        in
                    let _ = List.iter2 (fun a t ->
                        match t with
                        | CTypRawPtr _ -> i2e := Env.add a (cexp_deref (make_id_exp a kf_loc)) !i2e
                        | _ -> ()) real_args real_argtyps
                        in
                    let (ret_e, ccode) = kexp2cexp kf_body dstexp_r ccode kf_scope in
                    let end_loc = get_kexp_end kf_body in
                    let {bctx_label; bctx_prologue; bctx_cleanup; bctx_label_used} = curr_block_ctx end_loc in
                    let ccode = if bctx_label_used > 0 then CStmtLabel(bctx_label, end_loc) :: ccode else ccode in
                    let (ret_e, ccode) =
                        if bctx_cleanup = [] then
                            (ret_e, ccode)
                        else
                            let (ret_e, ccode) =
                                if retid <> noid || status_id <> noid || (Utils.is_some !dstexp_r) then
                                    (ret_e, ccode)
                                else
                                (match ret_e with
                                | CExpInit([], _) | CExpLit _ | CExpIdent _ -> (ret_e, ccode)
                                | _ ->
                                    let new_ret_id = gen_temp_idc "result" in
                                    let ccode = create_cdefval new_ret_id (get_cexp_typ ret_e) [] ""
                                        (Some ret_e) ccode kf_scope end_loc in
                                    ((make_id_exp new_ret_id end_loc), ccode))
                            in
                                (ret_e, (bctx_cleanup @ ccode))
                        in
                    let ccode = if status_id <> noid then
                            CStmtReturn ((Some (make_id_exp status_id end_loc)), end_loc) :: ccode
                        else if rt = CTypVoid then ccode
                        else CStmtReturn ((Some ret_e), end_loc) :: ccode
                        in
                    (List.rev bctx_prologue) @ (List.rev ccode))
                in
            pop_block_ctx kloc;
            cf := {!cf with cf_body = (filter_out_nops new_body)};
            (false, dummy_exp, ccode)
        | KDefExn ke -> raise_compile_err kloc "cgen: unsupported KDefExn"
            (*
                should generate constructor in the case of exception with argument(s) (TBD).
            *)
        | KDefVariant kvar -> (false, dummy_exp, ccode) (* handled in c_gen_types *)
        | KDefTyp kt -> (false, dummy_exp, ccode) (* handled in c_gen_types *)
        | KDefClosureVars kcv -> raise_compile_err kloc "cgen: unsupported KDefClosureVars"
            (* TBD *)
        in
        if not assign || ctyp = CTypVoid then
            (result_exp, ccode)
        else match !dstexp_r with
        | Some (dstexp) ->
            let ccode = C_gen_types.gen_copy_code result_exp dstexp ctyp ccode kloc in
            (dstexp, ccode)
        | _ -> (result_exp, ccode)
    in
    (* ok, here is the top-level C code generation procedure *)

    (* 1. convert all types to C *)
    let c_types_ccode = C_gen_types.convert_all_typs top_code in

    (* 2. [TODO] convert all exceptions to C *)

    (* 3. convert function declarations to C *)
    let c_fdecls = C_gen_fdecls.convert_all_fdecls top_code in

    (* 4. all the global code should be put into fx_toplevel() function. Let's form its body,
          starting with the classical `int fx_status = 0;` *)
    let sc0 = ScGlobal::[] in
    let start_loc = if top_code = [] then noloc else get_kexp_loc(List.hd top_code) in
    let _ = new_block_ctx BlockKind_Global sc0 start_loc in
    let status_id = gen_temp_idc "fx_status" in
    let ccode = create_cdefval status_id CTypCInt [ValMutable] "fx_status"
            (Some (make_int_exp 0 start_loc)) [] sc0 start_loc in
    (* 5. convert all the code to C. It will automatically update functions bodies *)
    let (e, ccode) = kexp2cexp (code2kexp top_code start_loc) (ref None) ccode sc0 in

    let end_loc = get_cexp_loc e in

    (* 6. bctx_prologue will contain all the global definitions.
          bctx_cleanup will contain destructor calls for all the global definitions.
          Need to add it to end of fx_toplevel() and
          form its body
    *)
    let {bctx_prologue; bctx_label; bctx_cleanup; bctx_label_used} = curr_block_ctx end_loc in
    let _ = pop_block_ctx end_loc in
    let ccode = (cexp2stmt e) :: ccode in
    let ccode = if bctx_label_used = 0 then ccode else (CStmtLabel(bctx_label, end_loc)) :: ccode in
    let ccode = filter_out_nops (bctx_cleanup @ ccode) in
    let ccode = CStmtReturn ((Some (make_id_exp status_id end_loc)), end_loc) :: ccode in
    let toplevel_cname = "fx_toplevel" in
    let toplevel_name = (gen_temp_idc toplevel_cname) in
    let toplevel_f = ref {cf_name=toplevel_name; cf_typ=CTypFun([], CTypCInt);
        cf_args=[]; cf_cname=toplevel_cname; cf_body=(List.rev ccode); cf_flags=[]; cf_scope=sc0; cf_loc=end_loc} in
    let _ = set_idc_entry toplevel_name (CFun toplevel_f) in
    let all_ccode = (make_ccode_prologue start_loc) @ !top_ccode @
        c_types_ccode @ c_fdecls @ [CDefFun toplevel_f] @ (make_ccode_epilogue end_loc) in
    all_ccode
