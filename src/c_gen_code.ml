(*
    This file is a part of ficus language project.
    See ficus/LICENSE for the licensing terms
*)

(*
    Converts K-form into C-form (see c_form.ml).
    We assume that K-form has been prepared for the conversion,
    i.e. lambda lifting has been done, all the complex
    data structures, such as records, tuple, lists etc. have
    been converted to KTypName(...) etc.

    The algorithm:
        1. do the 1st pass through the K-form, convert all the types and exceptions (see c_gen_types.ml).
        2. do the 2nd pass through the K-form, generate headers for all the functions (see c_gen_fdecls.ml):
            - each function, except for the constructors, gets extra "free variables"/"closure data"
              parameter fx_fv, even if it's not used.
            - the return value becomes the output parameter fx_result (before the closure pointer), unless
              the function is "nothrow" and the return type is scalar.
            - the non-"nothrow" function gets "int" return value, the status.
              "nothrow" functions return the result or return "void".
        3. do the 3rd pass through the K-form:
            - convert body of each function to C-form
            - put all the global calculations to a dedicated function fx_toplevel();
              all the intermediate values, used at the global scope, are moved to this function as well.
            - collect all the global c-code fragments into a dedicated list
        4. output the final C code as concatenation of the following parts (in this particular order):
            - preamble (some general comment about autogenerated file + #include "ficus/ficus.h")
            - all the global c code
            - forward declarations of some types and their destructors
            - declarations of all the types and their helper functions (constructors, destructors, copy operators)
            - declarations of all the exceptions and their constructors
            - declarations of the global variables together with their default initializers.
            - forward declarations of some functions
            - declarations and definitions of all the functions
            - the function "int fx_toplevel(void) {...}"
            _ the function main() that initializes runtime, calls fx_toplevel() and returns its value.

    The K-form to transform as a recursive tree of expressions.
    So we call kexp2cexp recursively to convert K expression to C code. The function
    takes kexp_t on input and returns a pair of (cexp_t, cstmt_t list) on output.
    The first output value is equivalent C expression or name of variable that stores it.
    The second output value is reversed list of C statements, new statements are added into the begining,
    because it's O(1) operation. In the end of each block we reverse the list and form block statement
    (loop body, if branch, function body etc.)

    We maintain and recursively pass the following compiler state:
    - C code generated so far. Just like in k_normalize.ml, this is the reverse list of c statements.
      It's passed as input to many code generation functions that update it and return.
    - The "catch" label stack. In the beginning of new function we push the default "cleanup" label
      for that function and pop in the end. We also push-pop a new label when we translate
      try {} catch {} block. In principle, we can use dedicated catch labels in some other nested statements,
      like for(), if() etc. For simplicity we do not do that, at the expense of slightly higher
      overhead imposed by the single big cleanup section per function. After we employ the inline function
      call optimization, the relative overhead of the cleanup sections should decrease.
      In the catch blocks we jump to the underlying label in the stack,
      thus providing the exception propagation mechanism.
    - the map of id->cexp_t pairs (i2e); not passed as argument, but maintained separately.
      It does not make sense to represent all the values in K form as C variables.
      If the value (id) is:
      1. used just once
      2. immutable (val, not var)
      3. a result of pure expression, which operands are also values
      then the id can be just replaced with the expression in C-form.
    - the stack of scopes where we need to do some cleanup:

      global -> [fun -> ] [try -> ] [for/while/do-while ->] [match case ->] ...

    - reference to the destination expression, or ref None.
        - when the translated kexp_t has type KTypVoid, no output value is needed.
        - in some other cases, there is no pre-defined target for expression.
          Then we need to generate a new temporary value and store the result there.
          Or even postpone the temporary value assignment and put the pair (id, cexp) to the map.
        - in some cases we are given the pre-defined expression target.
        - for example, the function body expression result should be stored in fx_result.
        - When we have K-form code "var x=val0; ... x=new_val;", new_val should be stored in x,
          no need to generate a temporary value, because we want to avoid unnecessary data copying.
          So, we pass x as the target location when we convert `new_val` to C code.
        - "record.f = new_val", "arr[idx] += newval" etc. are other such cases. In those cases we
          use a TEMP_REF val that is the pointer to the proper record field or array element.
          However, in those cases we will try to generate idiomatic C code, e.g. "record.f = new_val",
          not the direct replication of K-form: "sometype* pf /* TEMP_REF */ = &record.f; *pf = new_val"
*)
open Ast
open K_form
open C_form

let do_fold_left2 f result l1 l2 loc msg =
    let len1 = List.length l1 in
    let len2 = List.length l2 in
    (if len1 <> len2 then
        raise_compile_err loc (msg ^ (sprintf " len1=%d, len2=%d" len1 len2)) else ();
    List.fold_left2 f result l1 l2)

(* Finds a set of immutable values that can potentially be replaced
   with the expressions that they are initalized with, e.g.

   val b = a + 1; foo(b)
   can be replaced with foo(a+1).

   Here we find a superset of such values, i.e. a set of values
   that are pure expressions and used just once.
   If a value is used more than once, it makes
   sense to store it in a temporary variable.

   Later on we shrink this superset. We check that their initialization
   expressions can be represented as scalar C expressions.
   This is a recursive rule that cannot be checked at this stage.
*)
let find_single_use_vals topcode =
    (let count_map = ref (Env.empty: int Env.t) in
    let decl_const_vals = ref (IdSet.empty) in
    let rec count_atom a loc callb =
        match a with
        | Atom.Id i ->
            if IdSet.mem i !decl_const_vals then
                let n = match (Env.find_opt i !count_map) with
                    | Some(n) -> n
                    | _ -> 0
                in count_map := Env.add i (n+1) !count_map
            else ()
        | _ -> ()
    and count_ktyp t loc callb = ()
    and count_kexp e callb =
        (* we put to decl_const_vals only the values declared with
           "val" operator, which means they are declared by
           user or are temporary intermediate values.
           we do not put there function parameters and
           loop counters, because they cannot be replaced with
           any expressions. They themselves are expressions.
        *)
        match e with
        | KDefVal(k, e1, loc) ->
            let {kv_flags} = get_kval k loc in
            (* We only replace those values with expressions which are temporary
                and computed using pure expressions *)
            let good_temp = (List.mem ValTempRef kv_flags) || (List.mem ValTemp kv_flags) in
            if good_temp && (K_deadcode_elim.pure_kexp e1) then
                decl_const_vals := IdSet.add k !decl_const_vals
            else ();
            count_kexp e1 callb
        | KExpCall(f, _, (_, loc)) ->
            (* count f twice to make sure it will not be included into u1vals, because if
               f is function pointer, then in C the call will be converted to
               `f.fp(args, f.fcv)`, i.e. f is used twice here, so we need to save it anyway *)
            count_atom (Atom.Id f) loc callb;
            fold_kexp e callb
        | _ -> fold_kexp e callb
    in let count_callb =
    {
        kcb_fold_ktyp=Some(count_ktyp);
        kcb_fold_kexp=Some(count_kexp);
        kcb_fold_atom=Some(count_atom);
        kcb_fold_result=0
    } in
    List.iter (fun e -> count_kexp e count_callb) topcode;
    IdSet.filter (fun i -> match (Env.find_opt i !count_map) with Some 1 -> true | _ -> false) !decl_const_vals)

let occurs_id_kexp i0 e =
    let r_occurs = ref false in
    let rec occurs_atom a loc callb =
        match a with
        | Atom.Id i ->
            if i = i0 then r_occurs := true else ()
        | _ -> ()
    and occurs_ktyp t loc callb = ()
    and occurs_kexp e callb = if !r_occurs then () else fold_kexp e callb
    in let occurs_callb =
    {
        kcb_fold_ktyp=Some(occurs_ktyp);
        kcb_fold_kexp=Some(occurs_kexp);
        kcb_fold_atom=Some(occurs_atom);
        kcb_fold_result=0
    } in
    let loc = get_kexp_loc e in
    (* occurs_id_kexp main use is to find some loop or other complex expression invariants.
       if "i0" is temp ref, i.e. a pointer to some part of a complex data type,
       its contents can be implictly modified via a variable/value with different name.
       so we always return true, i.e. "i0" cannot be considered a constant w.r.t "e" *)
    let f = match (kinfo_ i0 loc) with
        | KVal {kv_flags} -> List.mem ValTempRef kv_flags
        | _ -> false
        in
    f || (occurs_kexp e occurs_callb; !r_occurs)

type block_kind_t =
    | BlockKind_Global
    | BlockKind_Fun of id_t
    | BlockKind_Branch
    | BlockKind_Try
    | BlockKind_Loop
    | BlockKind_LoopND
    | BlockKind_Case

type block_ctx_t =
{
    bctx_kind: block_kind_t;
    bctx_scope: scope_t list;
    bctx_label: id_t;
    bctx_br_label: id_t;
    bctx_for_flags: for_flag_t list;
    mutable bctx_prologue: cstmt_t list;
    mutable bctx_cleanup: cstmt_t list;
    mutable bctx_break_used: int;
    mutable bctx_continue_used: int;
    mutable bctx_label_used: int;
}

let make_ccode_prologue loc =
    CExp(CExpCCode(
        ("// this is autogenerated file, do not edit it.\n" ^
        "#include \"ficus/ficus.h\"\n" ^
        "#include \"ficus/impl/ficus.impl.h\"\n"
        ), loc)) ::
    []

let make_ccode_epilogue loc =
    [CExp(CExpCCode((
    "int main(int argc, char** argv)\n{\n" ^
    "   fx_init(argc, argv);\n" ^
    "   int fx_status = fx_toplevel();\n" ^
    "   return fx_finit(fx_status);\n" ^
    "}"), loc))]

let gen_ccode top_code =
    (*let user_exceptions_ofs = ref 0 in
    let top_exn_vals = ref ([]: (id_t*cexp_t) list) in*)
    let top_ccode = ref ([]: cstmt_t list) in
    let fwd_fdecls = ref ([]: cstmt_t list) in
    let defined_funcs = ref (IdSet.empty) in
    let i2e = ref (Env.empty: cexp_t Env.t) in
    let u1vals = find_single_use_vals top_code in
    let block_stack = ref ([]: block_ctx_t list) in
    let for_letters = ["i"; "j"; "k"; "l"; "m"] in
    let fx_status = get_id "fx_status" in

    let make_fx_status loc = make_id_t_exp fx_status CTypCInt loc in

    let ensure_func_is_defined_or_declared f loc =
        if (IdSet.mem f !defined_funcs) then () else
            (defined_funcs := IdSet.add f !defined_funcs;
            fwd_fdecls := CDefForwardFun (f, loc) :: !fwd_fdecls)
    in

    let check_inside_loop is_break loc =
        let rec check_inside_loop_ s =
            match s with
            | top :: rest ->
                let {bctx_kind; bctx_for_flags} = top in
                (match bctx_kind with
                | BlockKind_Loop | BlockKind_LoopND ->
                    if (List.mem ForNested bctx_for_flags) then
                        check_inside_loop_ rest
                    else
                        if is_break then
                            top.bctx_break_used <- top.bctx_break_used + 1
                        else
                            top.bctx_continue_used <- top.bctx_continue_used + 1
                | BlockKind_Fun _ | BlockKind_Global ->
                    raise_compile_err loc
                        (sprintf "'%s' is used outside of a loop" (if is_break then "break" else "continue"))
                | _ -> check_inside_loop_ rest)
            | _ ->
                raise_compile_err loc
                    (sprintf "'%s' is used outside of a loop" (if is_break then "break" else "continue"))
        in check_inside_loop_ !block_stack
    in

    let curr_block_ctx loc = match !block_stack with
        | top :: _ -> top
        | _ -> raise_compile_err loc "cgen: empty block stack!"
    in

    let curr_func loc =
        match (List.find_opt (fun bctx ->
                match bctx.bctx_kind with
                | BlockKind_Fun _ -> true
                | _ -> false) !block_stack)
        with
        | Some({bctx_kind=BlockKind_Fun f}) -> f
        | _ -> noid
    in

    let new_block_ctx_ kind for_flags sc loc =
        let l_basename = match kind with
            | BlockKind_Global | BlockKind_Fun _ -> "cleanup"
            | _ -> "catch" in
        let l = make_label l_basename sc (get_end_loc loc) in
        let br_l = if kind <> BlockKind_LoopND then noid else
            make_label "break" sc (get_end_loc loc) in
        let bctx = {bctx_kind = kind; bctx_scope=sc; bctx_label=l;
                    bctx_br_label = br_l;
                    bctx_for_flags = for_flags;
                    bctx_prologue=[]; bctx_cleanup=[];
                    bctx_break_used=0; bctx_continue_used=0;
                    bctx_label_used=0} in
        block_stack := bctx :: !block_stack
    in

    let new_block_ctx kind sc loc = new_block_ctx_ kind [] sc loc
    in

    let new_for_block_ctx ndims for_flags sc loc =
        let kind = if ndims = 1 then BlockKind_Loop else BlockKind_LoopND in
        new_block_ctx_ kind for_flags sc loc
    in

    let pop_block_ctx loc =
        match !block_stack with
        | _ :: rest -> block_stack := rest
        | _ -> raise_compile_err loc "cgen: empty block stack!"
    in

    let curr_block_label loc =
        let bctx = curr_block_ctx loc in
        bctx.bctx_label_used <- bctx.bctx_label_used + 1;
        make_id_exp bctx.bctx_label loc
    in

    let parent_block_label loc = match !block_stack with
        | _ :: parent :: _ ->
            parent.bctx_label_used <- parent.bctx_label_used + 1;
            make_id_exp parent.bctx_label loc
        | _ ->
            raise_compile_err loc "cgen internal err: there is no parent block!"
    in

    let add_fx_call call_exp ccode loc =
        let l = curr_block_label loc in
        let fx_call_e = make_call !std_FX_CALL (call_exp :: l :: []) CTypVoid loc in
        (CExp fx_call_e) :: ccode
    in

    let add_local i ctyp flags e0_opt ccode sc loc =
        let {ctp_ptr; ctp_free=(freem, freef)} = C_gen_types.get_ctprops ctyp loc in
        let need_dtor = freem <> noid || freef <> noid in
        if need_dtor then
            (let bctx = curr_block_ctx loc in
            let init_exp = if ctp_ptr then (make_nullptr loc) else CExpInit([], (ctyp, loc)) in
            let (i_exp, prologue) = create_cdefval i ctyp flags "" (Some init_exp) bctx.bctx_prologue sc loc in
            bctx.bctx_prologue <- prologue;
            bctx.bctx_cleanup <- C_gen_types.gen_free_code i_exp ctyp true true bctx.bctx_cleanup loc;
            (i_exp, (match (e0_opt, ctp_ptr) with
            | (Some(CExpLit(LitNil, _)), true) -> ccode
            | (Some(e0), _) -> C_gen_types.gen_copy_code e0 i_exp ctyp ccode loc
            | _ -> ccode)))
        else
            create_cdefval i ctyp flags "" e0_opt ccode sc loc
    in

    let add_local_tempref i ctyp flags e0 ccode sc loc =
        let {ctp_ptr} = C_gen_types.get_ctprops ctyp loc in
        let (e, ctyp) = if ctp_ptr then (e0, ctyp) else
            let ctyp_ptr = make_ptr ctyp in
            let deref_i_exp = CExpUnOp(COpDeref, (make_id_t_exp i ctyp_ptr loc), (ctyp, loc)) in
            let _ = i2e := Env.add i deref_i_exp !i2e in
            ((cexp_get_addr e0), ctyp_ptr)
        in
        create_cdefval i ctyp flags "" (Some e) ccode sc loc
    in

    let get_dstexp dstexp_r prefix ctyp flags ccode sc loc =
        match (ctyp, !dstexp_r) with
        | (CTypVoid, _) -> ((make_dummy_exp loc), ccode)
        | (_, Some(dst_exp)) -> (dst_exp, ccode)
        | _ ->
            let i = gen_temp_idc prefix in
            let (i_exp, ccode) = add_local i ctyp flags None ccode sc loc in
            dstexp_r := (Some i_exp);
            (i_exp, ccode)
    in

    let get_struct cexp =
        let (ctyp, cloc) = get_cexp_ctx cexp in
        let rec try_deref cexp ctyp =
            match ctyp with
            | CTypRawPtr(_, ctyp1) -> try_deref (cexp_deref cexp) ctyp1
            | _ ->
                (match ctyp with
                | CTypName tn ->
                    (match (cinfo_ tn cloc) with
                    | CTyp {contents={ct_typ=CTypStruct(_, relems); ct_data_start}} ->
                        (tn, cexp, relems, ct_data_start)
                    | CTyp {contents={ct_typ=CTypRawPtr(_, CTypStruct(rn, relems)); ct_data_start}} ->
                        ((Utils.opt_get rn noid), (cexp_deref cexp), relems, ct_data_start)
                    | _ -> raise_compile_err cloc
                        (sprintf "the type '%s' is not a structure" (get_idc_cname tn cloc)))
                | CTypStruct(rn, relems) -> ((Utils.opt_get rn noid), cexp, relems, 0)
                | _ -> raise_compile_err cloc "a structure is expected here")
        in try_deref cexp ctyp
    in

    let unpack_fun_args args rt is_nothrow =
        (* exclude "fx_fv" from real args if any *)
        let (real_args, have_fv_arg) = match (List.rev args) with
            | (_, _, flags) :: rest when (List.mem CArgFV flags) -> (rest, true)
            | rargs -> (rargs, false)
            in
        (* extract and exclude fx_result, if any *)
        let (real_args, ret_id, ret_rt) = match real_args with
            | (i, t, flags) :: rest when (List.mem CArgRetVal flags) -> (rest, i, t)
            | _ -> (real_args, noid, if is_nothrow then rt else CTypVoid)
        in
        let real_args = List.rev real_args in
        (real_args, ret_id, ret_rt, have_fv_arg)
    in

    let make_break_stmt loc =
        (check_inside_loop true loc;
        CExp (make_call !std_FX_BREAK [curr_block_label loc] CTypVoid loc))
    in

    let make_continue_stmt loc =
        (check_inside_loop false loc;
        CExp (make_call !std_FX_CONTINUE [curr_block_label loc] CTypVoid loc))
    in

    let handle_temp_ref flags e ctyp =
        if List.mem ValTempRef flags then
            (true, (cexp_get_addr e), CTypRawPtr([], ctyp))
        else
            (false, e, ctyp)
    in

    let id2cexp i save ccode sc loc =
        match (Env.find_opt i !i2e) with
        | Some(e) ->
            (match (save, e) with
            | (false, _) | (_, CExpIdent _) | (_, CExpLit _)
            | (_, CExpUnOp(COpDeref, (CExpIdent _), _))
                -> (e, ccode)
            | _ ->
                let (ctyp, eloc) = get_cexp_ctx e in
                let {kv_flags} = get_kval i loc in
                let i2 = dup_idc i in
                let (add_deref, e, ctyp) = handle_temp_ref kv_flags e ctyp in
                let (i2_exp, ccode) = add_local i2 ctyp kv_flags (Some e) ccode sc loc in
                i2e := Env.add i i2_exp !i2e;
                ((if add_deref then (cexp_deref i2_exp) else i2_exp), ccode))
        | _ ->
            let e = make_id_exp i loc in
            let e = (match cinfo_ i loc with
            | CVal {cv_typ; cv_flags} ->
                (match cv_typ with
                | CTypRawPtr(_, ctyp2) when ctyp2 = cv_typ -> cexp_deref e
                | _ -> e)
            | _ -> e)
            in (e, ccode)
    in

    let is_immutable_atomic_cexp e =
        match e with
        | CExpLit _ -> true
        | CExpIdent(i, (t, loc)) ->
            let {ctp_scalar} = C_gen_types.get_ctprops t loc in
            ctp_scalar && (match (cinfo_ i loc) with
                | CVal {cv_flags} -> not (List.mem ValMutable cv_flags)
                | _ -> false)
        | _ -> false
        in

    let finalize_loop_body body_code enable_break_continue loc =
        let end_loc = get_end_loc loc in
        let bctx = curr_block_ctx loc in
        let {bctx_kind; bctx_prologue; bctx_cleanup;
            bctx_break_used; bctx_continue_used; bctx_for_flags;
            bctx_label; bctx_br_label; bctx_label_used} = bctx in
        let _ = if bctx_kind = BlockKind_Loop || bctx_kind = BlockKind_LoopND then
            () else raise_compile_err loc "cgen: the current context is not a loop" in
        let epilogue = List.rev bctx_cleanup in
        let (br_label, epilogue) =
            if bctx_label_used + bctx_break_used + bctx_continue_used = 0 then
                (noid, epilogue)
            else
                (let parent_label_exp = parent_block_label end_loc in
                let epilogue = epilogue @ [CStmtLabel(bctx_label, end_loc)] in
                let _ = if enable_break_continue || bctx_continue_used + bctx_break_used = 0 then [] else
                    raise_compile_err loc "cgen: cannot use break/continue inside comprehensions" in
                let continue_code = if bctx_continue_used = 0 then []
                    else [CExp (make_call !std_FX_CHECK_CONTINUE [] CTypVoid end_loc)] in
                let (br_label, break_code) = if bctx_break_used = 0 then (noid, []) else
                    if bctx_br_label = noid then
                        (noid, [CExp (make_call !std_FX_CHECK_BREAK [] CTypVoid end_loc)])
                    else
                        let br_label_exp = make_id_exp bctx_br_label end_loc in
                        (bctx_br_label, [CExp (make_call !std_FX_CHECK_BREAK_ND [br_label_exp] CTypVoid end_loc)])
                    in
                let check_exn_code = CExp (make_call !std_FX_CHECK_EXN [parent_label_exp] CTypVoid end_loc) in
                (br_label, check_exn_code :: (break_code @ continue_code @ epilogue)))
            in
        let body_code = epilogue @ body_code @ bctx_prologue in
        let body_stmt = rccode2stmt body_code loc in
        pop_block_ctx end_loc; (br_label, body_stmt)
    in

    let atom2cexp_ a save ccode sc loc =
        match a with
        | Atom.Lit(l) ->
            (match l with
            | LitString _ ->
                (* since FX_MAKE_STR(<string_literal>) creates a string with NULL reference counter and
                without allocating string in memory heap, there is no need to call destructor for it *)
                let e0 = make_call !std_FX_MAKE_STR ((make_lit_exp l loc) :: []) CTypString loc in
                create_cdefval (gen_temp_idc "slit") CTypString [] "" (Some e0) ccode sc loc
            | _ ->
                let e = make_lit_exp l loc in (e, ccode))
        | Atom.Id(i) -> id2cexp i save ccode sc loc
    in

    let atom2cexp a ccode sc loc = atom2cexp_ a false ccode sc loc
    in

    let fix_nil e ktyp =
        match e with
        | CExpInit([], _) ->
            let loc = get_cexp_loc e in
            let {ktp_scalar; ktp_ptr} = K_annotate_types.get_ktprops ktyp loc in
            if not (ktp_scalar || ktp_ptr) then e else (make_int_exp 0 loc)
        | _ -> e
    in

    let make_make_arr_call arr_exp shape data ccode sc loc =
        let arr_ctyp = get_cexp_typ arr_exp in
        let dims = List.length shape in
        let shape_ctyp = CTypRawArray ([CTypConst], CTypInt) in
        let shape_arr = CExpInit(shape, (shape_ctyp, loc)) in
        let (shape_exp, ccode) = create_cdefval (gen_temp_idc "shape") shape_ctyp [] "" (Some shape_arr) ccode sc loc in
        let elem_ctyp = match arr_ctyp with
            | CTypArray(dims0, elem_ctyp) ->
                if dims0 = dims then () else
                    raise_compile_err loc (sprintf "cgen: incorrect number of shape elements (actual: %d, expected: %d)" dims dims0);
                elem_ctyp
            | _ -> raise_compile_err loc "cgen: invalid output type of array construction expression"
            in
        let (data_exp, ccode) = match data with
            | [] -> ((make_nullptr loc), ccode)
            | _ ->
                let elems_ctyp = CTypRawArray ([CTypConst], elem_ctyp) in
                let elems_arr = CExpInit(data, (elems_ctyp, loc)) in
                create_cdefval (gen_temp_idc "data") elems_ctyp [] "" (Some elems_arr) ccode sc loc
            in
        let sizeof_elem_exp = make_call !std_sizeof [CExpTyp(elem_ctyp, loc)] CTypSize_t loc in
        let free_f_exp = match (C_gen_types.get_free_f elem_ctyp true false loc) with
            | (_, (Some free_f)) -> CExpCast(free_f, !std_fx_free_t, loc)
            | _ -> make_nullptr loc
            in
        let copy_f_exp = match (C_gen_types.get_copy_f elem_ctyp true false loc) with
            | (_, Some(copy_f)) -> CExpCast(copy_f, !std_fx_copy_t, loc)
            | _ -> make_nullptr loc
            in
        let call_mkarr = make_call !std_fx_make_arr [(make_int_exp dims loc); shape_exp;
            sizeof_elem_exp; free_f_exp; copy_f_exp; data_exp; (cexp_get_addr arr_exp)] CTypCInt loc in
        add_fx_call call_mkarr ccode loc
    in

    let decl_arr arr_ctyp shape data dstexp_r ccode sc loc =
        let (arr_exp, _) = get_dstexp dstexp_r "arr" arr_ctyp [] [] sc loc in
        (arr_exp, (make_make_arr_call arr_exp shape data ccode sc loc))
    in

    let make_fun_arg e loc =
        let ctyp = get_cexp_typ e in
        let {ctp_pass_by_ref} = C_gen_types.get_ctprops ctyp loc in
        if ctp_pass_by_ref then (cexp_get_addr e) else e
    in

    let maybe_deref_fun_arg idx arg t flags loc =
        match ((List.mem CArgPassByPtr flags), t) with
        | (true, CTypRawPtr(_, t)) ->
            ((cexp_deref arg), t)
        | (true, _) ->
            raise_compile_err loc (sprintf
                "cgen: invalid type of argument #%d; it's passed by pointer, but the type is not pointer"
                idx)
        | _ -> (arg, t)
    in

    let make_cons_call hd_exp tl_exp addref_tl l_exp ccode loc =
        let ctyp = get_cexp_typ l_exp in
        let hd_exp = make_fun_arg hd_exp loc in
        let lcon = C_gen_types.get_constructor ctyp true loc in
        let call_cons = make_call lcon [hd_exp; tl_exp; make_bool_exp addref_tl loc; cexp_get_addr l_exp] CTypCInt loc in
        add_fx_call call_cons ccode loc
    in

    let make_mkref_call arg_exp r_exp ccode loc =
        let ctyp = get_cexp_typ r_exp in
        let arg_exp = make_fun_arg arg_exp loc in
        let rcon = C_gen_types.get_constructor ctyp true loc in
        let call_mkref = make_call rcon [arg_exp; cexp_get_addr r_exp] CTypCInt loc in
        add_fx_call call_mkref ccode loc
    in

    let add_size_eq_check check_list ccode lbl loc =
        match check_list with
        | e0 :: rest ->
            let check_exp = List.fold_left (fun e check_i ->
                CExpBinOp(COpLogicAnd, e, check_i, (CTypBool, loc))) e0 rest in
            let check_call = make_call !std_FX_CHECK_EQ_SIZE [check_exp; lbl] CTypVoid loc in
            (CExp check_call) :: ccode
        | _ -> ccode
    in

    (*let get_variant_cases vartyp loc =
        match vartyp with
        | KTypName n ->
            (match (kinfo_ n loc) with
            | KVariant kvar ->
                let {kvar_cases; kvar_constr} = !kvar in
                (kvar_cases, kvar_constr)
            | _ -> raise_compile_err loc (sprintf "type '%s' is not a variant" (get_idk_cname n loc)))
        | _ -> raise_compile_err loc "the type is not a variant, not even named type"
    in*)

    let for_err_msg for_idx nfors i msg =
        let for_msg_prefix = if nfors = 1 then "" else if for_idx = 0 then "outer "
        else if for_idx = nfors-1 then "inner " else
            (sprintf "%d-%s nested " for_idx (Utils.num_suffix for_idx)) in
        let i = i+1 in
        let it_clause = if i <= 0 then "" else (sprintf ", %d-%s iteration clause" i (Utils.num_suffix i)) in
        sprintf "cgen: %sfor-loop%s: %s" for_msg_prefix it_clause msg
    in

    let compute_for_ndims for_idx nfors kdl for_loc =
        let (_, ndims) = List.fold_left (fun (k, ndims) (_, dom_i) ->
            let ndims_i =
                match dom_i with
                | Domain.Elem(Atom.Id d) ->
                    (match (get_idk_ktyp d for_loc) with
                    | KTypArray(n, _) -> n
                    | _ -> 1)
                | _ -> 1
            in
            if ndims <> 0 && ndims <> ndims_i then
                raise_compile_err for_loc (for_err_msg k for_idx nfors
                (sprintf "dimensionalities of the simultaneously iterated collections/ranges are not the same (...%d...%d...)" ndims ndims_i))
            else ();
            (k+1, ndims_i)) (0, 0) kdl
        in ndims
    in

    let process_for lbl kdl for_idx nfors ndims dims_ofs nested_e_kdl init_ccode sc loc =
        let for_loc = get_start_loc loc in
        let end_for_loc = get_end_loc loc in
        let _ = if kdl <> [] then () else
            raise_compile_err loc (for_err_msg for_idx nfors (-1) "empty list of for iteration values")
            in

        (*
            [TODO] parallel loops are not supported yet.

            Compute various elements/attributes/parts of the for loop:

            list_exps: lst0, lst1, ... - lists (if any) which are iterated.
            i_exps: i, j, k etc. - for-loop integer iteration variables (only for closed ranges and arrays, not for open ranges or lists)
            n_exps: n0, n1, n2 etc. - for-loop limits (also integers)
            for_checks0: extra checks (besides `i < n0`, `j < n1`, `k < n2` etc.). Used for iteration over list(s): lst0[!=0], lst1[!=0] etc. ...
            incr_exps0: extra increment operations (besides `i++`, `j++`, `k++`). Used for iteration over lists(s): lst0=lst0->tl, lst1=lst1->tl, ...
            init_checks: the checks that we need to put before the loop into FX_CHECK_NE_SIZE((check0 || check1 || check2 ...), catch_label) macro.
                We check that all closed ranges and all simultaneously iterated 1D or nD arrays have the same shape.
                The lists sizes are not checked because we don't know their sizes before the loop,
                    and we don't want to make extra loop to count their lengths.
            init_ccode: inital code for the loop:
                Save all the arrays, lists etc. if needed to guarantee that they are not destroyed
                    in the middle of loop (and that they are computed just once).
                Save start:stop:step expressions in the ranges.
                Compute n_i=FX_LOOP_COUNT(start_i, stop_i, step_i) for each range.
                Save n0_i,n1_i,...=arr_i.dim[0,1,...].size.
                init_ccode does not include the check for size/shape equality/inequality (see init_checks). It's added after this let statement.
            pre_body_ccode: code before the inner-most loop. Now it's used only for arrays:
                elem_type0* ptr_arr0 = FX_PTR_<ndims>D(arr_0, i, j, ..., 0);
                elem_type1* ptr_arr1 = FX_PTR_<ndims>D(arr_1, i, j, ..., 0);
                that is, get the pointers to the linear slices of the iterated arrays.
                [TODO] we can check whether all the iterated arrays are continuous and modify n_exps accordingly,
                    e.g. in 2D case with 2 arrays A and B:
                    if(FX_ARR_CONTINUOUS(A) && FX_ARR_CONTINUOUS(B)) {
                        n1 *= n0;
                        n0 = 1;
                    }
                    with such a trick, the arrays are processed completely with a single run of inner loop with minimal overhead.
                note that in the case of 1D array processing pre_body_ccode immediately follows init_ccode and init_checks.
            body_pairs: a list of pairs (v_0, exp_0), (v_1, exp_1), ...
                This is a list of values that need to be extracted in the beginning of loop body.
                We keep them separately without forming expressions v_0 = exp_0, because in the case of complex types, e.g. strings or nested arrays,
                we need to initalize v_i separately and put the destructors to the for-loop body cleanup section. All this is done using add_local,
                but for that we need to form a nested for-loop body context, which we form after this let.
            post_checks: the checks that we need to put after the loop into FX_CHECK_NE_SIZE((check0 || check1 || check2 ...), catch_label) macro.
                We check that all closed ranges/arrays and all simultaneously iterated lists finished at once.
                In this let statement we put only lists. The range check is added later if needed.
                a) just list case:
                fx_list0_t lst0 = list0;
                fx_list1_t lst1 = list1;
                for(; lst0 && lst1; lst0=lst0->tl, lst1=lst1->tl) {
                    int a=lst0->hd, b=lst1->hd;
                    s += abs(a-b);
                }
                FX_CHECK_NE_SIZE(lst0 || lst1, catch_label); // check that both lists finished simultaneously.
                b) list and "closed range"/array case:
                fx_list0_t lst0 = list0;
                fx_list1_t lst1 = list1;
                for(int i = 0; i < n && lst0 && lst1; lst0=lst0->tl, lst1=lst1->tl) {
                    int a=lst0->hd, b=lst1->hd;
                    if(a!=b) {printf("diff=%d at %d\n", abs(a-b), i);}
                }
                FX_CHECK_NE_SIZE(i < n || lst0 || lst1, catch_label); // check that both lists and the range finished simultaneously.
        *)
        let (_, list_exps, i_exps, n_exps, for_checks0, incr_exps0, init_checks,
            init_ccode, pre_body_ccode, body_elems, post_checks) = List.fold_left
            (fun (k, list_exps, i_exps, n_exps, for_checks, incr_exps, init_checks, init_ccode,
                pre_body_ccode, body_elems, post_checks) (iter_val_i, dom_i) ->
                let (lists_i, i_exps, n_exps, for_checks, incr_exps, init_checks,
                    init_ccode, pre_body_ccode, body_elems, post_checks) = match dom_i with
                    | Domain.Range(a, b, delta) ->
                        let (aug_add_delta, add_delta, d_exp, init_ccode) = match delta with
                            | Atom.Lit(LitInt 0L) ->
                                raise_compile_err for_loc (for_err_msg for_idx nfors k "the iteration step is zero")
                            | Atom.Lit (LitInt i) ->
                                let (aug_add_delta, add_delta, i) = if i > 0L then
                                        (COpAugAdd, COpAdd, i)
                                    else
                                        (COpAugSub, COpSub, (Int64.neg i))
                                    in
                                (aug_add_delta, add_delta, (make_int__exp i for_loc), init_ccode)
                            | _ ->
                                let (d_exp, init_ccode) = atom2cexp_ delta true init_ccode sc for_loc in
                                let init_ccode = (CExp (make_call !std_FX_CHECK_ZERO_STEP [d_exp; lbl] CTypVoid for_loc)) :: init_ccode in
                                (COpAugAdd, COpAdd, d_exp, init_ccode)
                            in
                        (match b with
                        | Atom.Lit LitNil ->
                            (*
                                int iter_var = a;
                                for(;;iter_var += delta) {
                                    ...
                                }
                            *)
                            let (a_exp, init_ccode) = atom2cexp_ a false init_ccode sc for_loc in
                            let (i_exp, init_ccode) = create_cdefval iter_val_i CTypInt [ValMutable] "" (Some a_exp) init_ccode sc for_loc in
                            let incr_i_exp = CExpBinOp(aug_add_delta, i_exp, d_exp, (CTypVoid, for_loc)) in
                            ([], i_exps, n_exps, for_checks, incr_i_exp :: incr_exps, init_checks,
                            init_ccode, pre_body_ccode, body_elems, post_checks)
                        | _ ->
                            (*
                                // save the loop counter
                                int n = FX_LOOP_COUNT(a, b, delta); // n === loop_counter
                                // or check it
                                FX_CHECK_NE_SIZE(FX_LOOP_COUNT(a, b, delta) != loop_counter, catch_label);
                                for(int i = 0; i < loop_counter; i++) {
                                    int iter_var = a + i*delta; // compute the current value
                                }
                            *)
                            let (a_exp, init_ccode) = atom2cexp_ a true init_ccode sc for_loc in
                            let (b_exp, init_ccode) = atom2cexp_ b true init_ccode sc for_loc in
                            let is_canonical_for = match (a, delta) with
                                | ((Atom.Lit (LitInt 0L)), (Atom.Lit (LitInt 1L))) -> true
                                | _ -> false
                                in
                            let calc_n_exp = if is_canonical_for then b_exp else
                                make_call !std_FX_LOOP_COUNT [a_exp; b_exp; d_exp] CTypInt for_loc
                                in
                            let (add_elem, i_exp, i_exps, n_exps, init_checks, init_ccode) = match (i_exps, n_exps) with
                                | (prev_i :: _, prev_n :: _) ->
                                    (true, prev_i, i_exps, n_exps,
                                    (CExpBinOp(COpCompareEQ, prev_n, calc_n_exp, (CTypBool, for_loc))) :: init_checks,
                                    init_ccode)
                                | _ ->
                                    let (add_pair, i_id) = match (a, delta) with
                                        | ((Atom.Lit (LitInt 0L)), (Atom.Lit (LitInt 1L))) -> (false, iter_val_i)
                                        | _ -> (true, (dup_idc iter_val_i))
                                        in
                                    let (n_exp, init_ccode) =
                                        if is_canonical_for && (is_immutable_atomic_cexp b_exp) then
                                            (b_exp, init_ccode)
                                        else
                                            add_local (gen_temp_idc "n") CTypInt [] (Some calc_n_exp) init_ccode sc for_loc
                                        in
                                    let (i_exp, _) = add_local i_id CTypInt [ValMutable] None [] sc for_loc in
                                    (add_pair, i_exp, i_exp :: i_exps, n_exp :: n_exps, init_checks, init_ccode)
                                in
                            let body_elems = if not add_elem then body_elems else
                                let calc_i_exp = CExpBinOp(add_delta, a_exp,
                                    CExpBinOp(COpMul, i_exp, d_exp, (CTypInt, for_loc)), (CTypInt, for_loc)) in
                                (iter_val_i, calc_i_exp, []) :: body_elems
                                in
                            ([], i_exps, n_exps, for_checks, incr_exps, init_checks,
                            init_ccode, pre_body_ccode, body_elems, post_checks))
                    | Domain.Elem(a) ->
                        let col_ = match a with Atom.Id i -> i | _ -> noid in
                        let ktyp = get_atom_ktyp a for_loc in
                        let ctyp = C_gen_types.ktyp2ctyp ktyp for_loc in
                        (* before running iteration over a collection,
                            we need to make sure that it will not be deallocated in the middle *)
                        let (col_exp, init_ccode) = if col_ <> noid && List.exists (fun (e, _) -> occurs_id_kexp col_ e) nested_e_kdl then
                                let (src_exp, init_ccode) = atom2cexp (Atom.Id col_) init_ccode sc for_loc in
                                (*let src_exp = make_id_exp col_ (get_idk_loc col_ for_loc) in*)
                                let (col_exp, init_ccode) = get_dstexp (ref None) (pp_id2str col_) ctyp [] init_ccode sc for_loc in
                                let init_ccode = C_gen_types.gen_copy_code src_exp col_exp ctyp init_ccode for_loc in
                                (col_exp, init_ccode)
                            else
                                atom2cexp_ a true init_ccode sc for_loc
                            in
                        (match (deref_ktyp ktyp for_loc) with
                        | KTypList et ->
                            (*
                                some_lst_t lst = col;
                                for(; lst [&& ...]; lst=lst->tl) {
                                    some_lst_elem_t x = lst->hd;
                                    ...
                                }
                                // optional check
                                FX_CHECK_NE_SIZE(!lst || ..., catch_label);
                            *)
                            let (l_exp, init_ccode) = create_cdefval (gen_temp_idc "lst") ctyp [ValMutable] "" (Some col_exp) init_ccode sc for_loc in
                            let not_l_exp = CExpUnOp(COpLogicNot, l_exp, (CTypBool, end_for_loc)) in
                            let l_next_exp = make_assign l_exp (cexp_arrow l_exp (get_id "tl") ctyp) in
                            let c_et = C_gen_types.ktyp2ctyp et for_loc in
                            let get_hd_exp = cexp_arrow l_exp (get_id "hd") c_et in
                            let hd_flags = if (is_ktyp_scalar et) then [ValTemp] else [ValTempRef] in
                            ([l_exp], i_exps, n_exps, (l_exp :: for_checks), (l_next_exp :: incr_exps), init_checks, init_ccode,
                            pre_body_ccode, ((iter_val_i, get_hd_exp, hd_flags) :: body_elems), not_l_exp :: post_checks)
                        | KTypString ->
                            (*
                                // either save the length
                                int_ len = str->length; // loop_counter === len
                                // or check it
                                FX_CHECK_NE_SIZE(str->length != loop_counter, catch_label);
                                for(int i = 0; i < loop_counter; i++) {
                                    char_ x = str->data[i];
                                    ...
                                }
                            *)
                            let calc_n_exp = cexp_mem col_exp (get_id "length") CTypInt in
                            let (i_exp, i_exps, n_exps, init_checks, init_ccode) = match (i_exps, n_exps) with
                                | (prev_i :: _, prev_n :: _) ->
                                    (prev_i, i_exps, n_exps,
                                    (CExpBinOp(COpCompareEQ, prev_n, calc_n_exp, (CTypBool, for_loc))) :: init_checks,
                                    init_ccode)
                                | _ ->
                                    let (n_exp, init_ccode) = add_local (gen_temp_idc "len") CTypInt
                                        [] (Some calc_n_exp) init_ccode sc for_loc in
                                    let (i_exp, _) = add_local (gen_temp_idc (List.nth for_letters dims_ofs)) CTypInt [ValMutable] None [] sc for_loc in
                                    (i_exp, i_exp :: i_exps, n_exp :: n_exps, init_checks, init_ccode)
                                in
                            let get_chars = cexp_mem col_exp (get_id "data") (make_const_ptr CTypUniChar) in
                            let get_char_i = CExpBinOp(COpArrayElem, get_chars, i_exp, (CTypUniChar, for_loc)) in
                            ([], i_exps, n_exps, for_checks, incr_exps, init_checks, init_ccode,
                            pre_body_ccode, ((iter_val_i, get_char_i, []) :: body_elems), post_checks)
                        | KTypArray(ndims, et) ->
                            (*
                                // either save all the dimensions
                                int_ ni = FX_ARR_SIZE(arr, 0);
                                int_ nj = FX_ARR_SIZE(arr, 1);
                                ...
                                // or check them
                                FX_CHECK_NE_SIZE(FX_ARR_SIZE(arr, 0) != ni || FX_ARR_SIZE(arr, 1) != nj ..., catch_label);
                                for(int i = 0; i < ni; i++) {
                                    // before the inner-most loop
                                    arr_elem_t* ptr
                                    for(int j = 0; j < nj; j++) {
                                    char_ x = str->data[i];
                                    ...
                                }
                            *)
                            let (i_exps, n_exps, init_checks, init_ccode) = if n_exps = [] then
                                    let (i_exps, n_exps, init_ccode) = List.fold_left (fun (i_exps, n_exps, init_ccode) k ->
                                        let calc_n_exp = make_call !std_FX_ARR_SIZE [col_exp; (make_int_exp k for_loc)] CTypInt for_loc in
                                        let iter_letter = List.nth for_letters (k + dims_ofs) in
                                        let (n_exp, init_ccode) = add_local (gen_temp_idc ("n" ^ iter_letter)) CTypInt
                                            [] (Some calc_n_exp) init_ccode sc for_loc in
                                        let (i_exp, _) = add_local (gen_temp_idc iter_letter) CTypInt [ValMutable] None [] sc for_loc in
                                        (i_exp :: i_exps, n_exp :: n_exps, init_ccode))
                                        ([], [], init_ccode) (List.init ndims (fun k -> k))
                                    in ((List.rev i_exps), (List.rev n_exps), init_checks, init_ccode)
                                else
                                    let (_, init_checks) = List.fold_left (fun (k, init_checks) prev_nk ->
                                        let calc_n_exp = make_call !std_FX_ARR_SIZE [col_exp; (make_int_exp k for_loc)] CTypInt for_loc in
                                        let init_check_k = CExpBinOp(COpCompareEQ, prev_nk, calc_n_exp, (CTypBool, for_loc)) in
                                        (k+1, init_check_k :: init_checks)) (0, init_checks) n_exps
                                    in (i_exps, n_exps, init_checks, init_ccode)
                                in
                            let c_et = C_gen_types.ktyp2ctyp et for_loc in
                            let c_et_ptr = make_ptr c_et in
                            let rev_i_exps = List.rev i_exps in
                            let inner_idx = List.hd rev_i_exps in
                            let slice_idxs = List.rev ((make_int_exp 0 for_loc) :: (List.tl rev_i_exps)) in
                            let get_arr_slice = make_call (List.nth (!std_FX_PTR_xD) (ndims-1))
                                (CExpTyp (c_et, for_loc) :: col_exp :: slice_idxs) c_et_ptr for_loc in
                            let ptr_id = gen_temp_idc ("ptr_" ^ (pp_id2str col_)) in
                            let (ptr_exp, pre_body_ccode) = create_cdefval ptr_id c_et_ptr [] "" (Some get_arr_slice) pre_body_ccode sc for_loc in
                            let get_arr_elem = CExpBinOp(COpArrayElem, ptr_exp, inner_idx, (c_et, for_loc)) in
                            ([], i_exps, n_exps, for_checks, incr_exps, init_checks, init_ccode,
                            pre_body_ccode, ((iter_val_i, get_arr_elem, [ValTemp]) :: body_elems), post_checks)
                        | _ -> raise_compile_err for_loc (for_err_msg for_idx nfors k
                            (sprintf "cannot iterate over '%s'; it needs to be array, list or string" (atom2str a)))
                        )
                    | _ ->
                        raise_compile_err for_loc (for_err_msg for_idx nfors k "unsupported type of the for loop iteration domain")
                in (k+1, lists_i @ list_exps, i_exps, n_exps, for_checks, incr_exps, init_checks,
                    init_ccode, pre_body_ccode, body_elems, post_checks))
                (0, [], [], [], [], [], [], init_ccode, [], [], []) kdl
            in
        (* add initial size checks *)
        let init_ccode = add_size_eq_check (List.rev init_checks) init_ccode lbl for_loc in
        (* in the case of 1D arrays put pre_body_ccode immediately after initialization code *)
        let (init_ccode, pre_body_ccode) = if ndims > 1 then (init_ccode, pre_body_ccode)
            else (pre_body_ccode @ init_ccode, []) in
        (* add "post" checks, if needed *)
        let post_checks = List.rev post_checks in
        let post_checks = if post_checks <> [] && i_exps <> [] then
                (CExpBinOp(COpCompareEQ, (List.hd i_exps), (List.hd n_exps), (CTypBool, end_for_loc))) :: post_checks
            else if (List.length post_checks) > 1 then post_checks else []
            in
        let post_ccode = add_size_eq_check post_checks [] lbl end_for_loc in

        (* form for-loop headers *)
        let i_exps = List.rev i_exps in
        let n_exps = List.rev n_exps in
        let (k_final, for_headers) = List.fold_left2 (fun (k, for_headers) i_exp n_exp ->
            let ifor_loc = get_cexp_loc n_exp in
            let init_exps = [make_assign i_exp (make_int_exp 0 ifor_loc)] in
            let check_exp = CExpBinOp(COpCompareLT, i_exp, n_exp, (CTypBool, ifor_loc)) in
            let incr_exps = [CExpUnOp(COpSuffixInc, i_exp, (CTypInt, ifor_loc))] in
            let (check_exp, incr_exps) = if k > 0 then (check_exp, incr_exps) else
                let check_exp = List.fold_left (fun check_exp e ->
                    CExpBinOp(COpLogicAnd, check_exp, e, (CTypBool, ifor_loc)))
                    check_exp (List.rev for_checks0) in
                (check_exp, incr_exps @ (List.rev incr_exps0))
                in
            (k+1, (((Some CTypInt), init_exps, (Some check_exp), incr_exps) :: for_headers))) (0, []) i_exps n_exps
            in
        (* if we have open loop or loop over lists (i.e. i_exps and n_exps are empty lists),
           we still need to form the for-loop statement *)
        let for_headers = if k_final > 0 then for_headers else
            let check_exp_opt = List.fold_left (fun check_exp_opt check_i ->
                Some (match check_exp_opt with
                | Some e -> CExpBinOp(COpLogicAnd, e, check_i, (CTypBool, for_loc))
                | _ -> check_i)) None (List.rev for_checks0) in
            [(None, [], check_exp_opt, incr_exps0)]
            in

        (for_headers, list_exps, n_exps, init_ccode, pre_body_ccode, body_elems, post_ccode)
    in

    let decl_for_body_elems body_elems body_ccode sc =
        List.fold_left (fun body_ccode (v, e, flags) ->
            let (ctyp, loc) = get_cexp_ctx e in
            let (_, body_ccode) =
                if List.mem ValTempRef flags then
                    add_local_tempref v ctyp flags e body_ccode sc loc
                else
                    add_local v ctyp flags (Some e) body_ccode sc loc
                in
            body_ccode) body_ccode body_elems
    in

    let rec process_cases cases dstexp_r ccode is_catch_case sc kloc =
        let end_loc = get_end_loc kloc in
        let endmatch = make_label (if is_catch_case then "endcatch" else "endmatch") sc end_loc in
        let (have_default, em_label_used, have_epilogues, have_complex_branches, all_cases_ccode) =
            List.fold_left
            (fun (have_default, em_label_used, have_epilogues,
                have_complex_branches, all_cases_ccode) (checks_i, action_i) ->
            let (cchecks_i, pre_cchecks_i) = List.fold_left (fun (checks_i, pre_checks_i) check_ij ->
                let (ccheck_ij, ccode_ij) = kexp2cexp check_ij (ref None) [] sc in
                (ccheck_ij :: checks_i, ccode_ij :: pre_checks_i)) ([], []) checks_i
                in
            let ai_loc = get_kexp_loc action_i in
            let new_have_default =
                match checks_i with
                | [] -> if have_default then raise_compile_err ai_loc
                    "cgen: more than one default action" else true
                | _ -> have_default
                in
            (* for each action we create a dedicated scope with its own cleanup section;
                this is because it can be very lengthy match expressions with
                many cases (like in compilers), so if we put all the
                non-trivial locals into the common scope, the cleanup section
                will be very inefficient *)
            let ai_end_loc = get_end_loc ai_loc in
            let (ai_ccode, em_label_used_i, have_epilogue_i) =
                match action_i with
                | KExpThrow _ ->
                    let (_, ai_ccode) = kexp2cexp action_i dstexp_r [] sc in
                    (ai_ccode, false, false)
                | _ ->
                    let _ = new_block_ctx BlockKind_Case sc ai_loc in
                    let (_, ai_ccode) = kexp2cexp action_i dstexp_r [] sc in
                    let bctx_i = curr_block_ctx kloc in
                    let {bctx_prologue; bctx_cleanup;
                        bctx_label; bctx_label_used} = bctx_i in
                    let prologue = bctx_prologue in
                    let epilogue = List.rev bctx_cleanup in
                    let (ai_ccode, epilogue, have_epilogue_i) =
                        if epilogue = [] && prologue = [] then
                            let _ = pop_block_ctx ai_end_loc in
                            (* recompile the action code inside the parent context.
                                that is, in the case of exception, jump to the higher-level label
                                instead of this one. that probably makes compile the graph somewhat
                                simpler to analyze.
                                [TODO]
                                instead of complete re-compilation of the branch,
                                we could just replace all the bctx_label
                                occurences with the parent label *)
                            let (_, ai_ccode) = kexp2cexp action_i dstexp_r [] sc in
                            (ai_ccode, epilogue, false)
                        else
                            let epilogue =
                                if bctx_label_used = 0 then
                                    epilogue
                                else
                                    epilogue @ (CStmtLabel (bctx_label, ai_end_loc) :: [])
                                in
                            let _ = pop_block_ctx ai_end_loc in
                            (ai_ccode, epilogue, true)
                        in
                    let (em_label_used_i, epilogue) = if new_have_default then
                        (false, epilogue)
                    else
                        (true, ((CStmtGoto (endmatch, ai_end_loc)) :: epilogue))
                    in
                    let ai_ccode = epilogue @ ai_ccode @ prologue in
                    (ai_ccode, em_label_used_i, have_epilogue_i)
                in
            let complex_branch_i = match (cchecks_i, pre_cchecks_i) with
                | ([], []) -> false
                | (c::[], []::[]) -> false
                | _ -> true
                in
            let case_ccode = match (cchecks_i, pre_cchecks_i) with
                | ([], []) -> ai_ccode
                | _ ->
                    let ai_stmt = rccode2stmt ai_ccode ai_loc in
                    (* generate the nested if statement;
                    [TODO] need to replace it with one
                    `if (expi0 && expi1 && ... && expi{n-1}) { action_i }`
                    if possible (i.e. when all pre_check_ij's are empty) *)
                    do_fold_left2 (fun case_ccode check_ij pre_check_ij ->
                        let case_stmt = rccode2stmt case_ccode ai_end_loc in
                        let checkij_loc = get_cexp_loc check_ij in
                        let if_stmt = CStmtIf(check_ij, case_stmt, (CStmtNop ai_end_loc), checkij_loc) in
                        if_stmt :: pre_check_ij) (ai_stmt :: []) cchecks_i pre_cchecks_i ai_end_loc
                        "cgen: KExpMatch fold_left2"
                        in
            (new_have_default, em_label_used || em_label_used_i,
            have_epilogues || have_epilogue_i,
            have_complex_branches || complex_branch_i,
            case_ccode :: all_cases_ccode)) (false, false, false, false, []) cases
            in
        let parent_lbl = curr_block_label end_loc in
        let all_cases_ccode = if have_default then all_cases_ccode else
            let no_match_err = make_id_t_exp (get_id "FX_EXN_NoMatchError") CTypCInt end_loc in
            let throw_no_match = make_call !std_FX_FAST_THROW [no_match_err; parent_lbl] CTypVoid end_loc in
            [CExp throw_no_match] :: all_cases_ccode
            in
        let (em_label_used, ccode) =
            match (have_complex_branches, all_cases_ccode) with
            | (false, else_s :: ifs) ->
                let complex_if = List.fold_left (fun complex_if s_i ->
                    match s_i with
                    | CStmtIf(c_i, then_i, (CStmtNop _), loc_i) :: [] ->
                        let then_i =
                            match List.rev (stmt2ccode then_i) with
                            | (CStmtGoto(i, _) :: rest) when i = endmatch ->
                                rccode2stmt rest loc_i
                            | _ -> then_i
                        in CStmtIf(c_i, then_i, complex_if, loc_i)
                    | _ ->
                        raise_compile_err end_loc
                            "cgen: unexpected statement in the chained match statement")
                    (rccode2stmt else_s end_loc) ifs
                in
                (false, complex_if :: ccode)
            | _ -> (em_label_used, (List.concat all_cases_ccode) @ ccode)
            in
        let ccode = if not em_label_used then ccode
            else (CStmtLabel (endmatch, end_loc)) :: ccode in
        let ccode = if not have_epilogues then ccode else
            let check_exn = make_call !std_FX_CHECK_EXN (parent_lbl::[]) CTypVoid end_loc in
            (CExp check_exn) :: ccode
        in ccode

    (*
        cases:
           - input kexp is void:
                no expression should be stored anywhere,
                just need to update ccode and return "nop"
           - non-void expression,
                the result should be stored to some pre-defined value (dstid).
                returns this CExpIdent(dstid)
           - non-void expression (dstid=noid),
                the result should be returned as expression
                if needed, some temporary id is generated where the result is stored.
    *)
    and kexp2cexp kexp dstexp_r ccode sc =
        let (ktyp, kloc) = get_kexp_ctx kexp in
        let ctyp = C_gen_types.ktyp2ctyp ktyp kloc in
        let dummy_exp = make_dummy_exp kloc in
        (*let _ = (printf "processing kexp: "; K_pp.pprint_kexp_x kexp; printf "\n") in*)
        (*let _ = match kexp with
            | KDefFun {contents={kf_name}} ->
                printf "processing function '%s'\n" (idk2str kf_name kloc)
            | _ -> ()
        in*)

        (* generate exp and then optionally generate the assignment if needed *)
        let (assign, result_exp, ccode) = match kexp with
        | KExpNop _ -> (false, dummy_exp, ccode)
        | KExpBreak _ ->
            let break_stmt = make_break_stmt kloc in
            (false, dummy_exp, break_stmt :: ccode)
        | KExpContinue _ ->
            let continue_stmt = make_continue_stmt kloc in
            (false, dummy_exp, continue_stmt :: ccode)
        | KExpAtom(a, _) ->
            let (e, ccode) = atom2cexp a ccode sc kloc in
            let e = fix_nil e ktyp in
            (true, e, ccode)
        | KExpBinOp(bop, a1, a2, _) ->
            let (ce1, ccode) = atom2cexp a1 ccode sc kloc in
            let (ce2, ccode) = atom2cexp a2 ccode sc kloc in
            (match bop with
            | OpPow ->
                let (need_cast, ce1, ce2, rtyp, f) = match ctyp with
                    | CTypFloat(32) -> (false, ce1, ce2, ctyp, get_id "powf")
                    | CTypFloat(64) -> (false, ce1, ce2, ctyp, get_id "pow")
                    | _ ->
                        let ce1 = CExpCast(ce1, (CTypFloat 64), kloc) in
                        let ce2 = CExpCast(ce2, (CTypFloat 64), kloc) in
                        (true, ce1, ce2, (CTypFloat 64), get_id "pow") in
                let e = make_call f (ce1 :: ce2 :: []) rtyp kloc in
                let e = if need_cast then CExpCast(e, ctyp, kloc) else e in
                (true, e, ccode)
            | OpMod ->
                let e =
                if (is_ktyp_integer (get_atom_ktyp a1 kloc) true) &&
                   (is_ktyp_integer (get_atom_ktyp a2 kloc) true) then
                    CExpBinOp(COpMod, ce1, ce2, (ctyp, kloc))
                else
                    let (need_cast, ce1, ce2, rtyp, f) = match ctyp with
                        | CTypInt
                        | CTypFloat(32) -> (false, ce1, ce2, ctyp, get_id "fmodf")
                        | CTypFloat(64) -> (false, ce1, ce2, ctyp, get_id "fmod")
                        | _ ->
                            let ce1 = CExpCast(ce1, (CTypFloat 64), kloc) in
                            let ce2 = CExpCast(ce2, (CTypFloat 64), kloc) in
                            (true, ce1, ce2, (CTypFloat 64), get_id "fmod") in
                    let e = make_call f (ce1 :: ce2 :: []) rtyp kloc in
                    if need_cast then CExpCast(e, ctyp, kloc) else e
                in
                (true, e, ccode)
            | OpCons ->
                (*
                    l = e1 :: e2;
                    if !dstexp_r = None && (e2 is single-use id from u1vals) && (ce2 is id) then
                        re-use ce2 as l
                    else
                        obtain l using get_dstexp.
                *)
                let a2_id = match a2 with (Atom.Id i) when IdSet.mem i u1vals -> i | _ -> noid in
                let ce2_id = match ce2 with CExpIdent(i, _) -> i | _ -> noid in
                let (reuse_ce2, (l_exp, _)) = if (Utils.is_none !dstexp_r) && a2_id <> noid && ce2_id <> noid then
                        (true, (ce2, []))
                    else (false, (get_dstexp dstexp_r "lst" ctyp [] [] sc kloc)) in
                let ccode = make_cons_call ce1 ce2 (not reuse_ce2) l_exp ccode kloc in
                (false, l_exp, ccode)
            | _ ->
                let c_bop = match bop with
                    | OpAdd -> COpAdd
                    | OpSub -> COpSub
                    | OpMul -> COpMul
                    | OpDiv -> COpDiv
                    | OpShiftLeft -> COpShiftLeft
                    | OpShiftRight -> COpShiftRight
                    | OpBitwiseAnd -> COpBitwiseAnd
                    | OpBitwiseOr -> COpBitwiseOr
                    | OpBitwiseXor -> COpBitwiseXor
                    | OpCompareEQ -> COpCompareEQ
                    | OpCompareNE -> COpCompareNE
                    | OpCompareLT -> COpCompareLT
                    | OpCompareLE -> COpCompareLE
                    | OpCompareGT -> COpCompareGT
                    | OpCompareGE -> COpCompareGE
                    | OpCons | OpPow | OpMod | OpLogicAnd | OpLogicOr | OpSpaceship ->
                        raise_compile_err kloc (sprintf "cgen: unsupported op '%s' at this stage"
                        (binop_to_string bop))
                in (true, CExpBinOp(c_bop, ce1, ce2, (ctyp, kloc)), ccode))
        | KExpUnOp(OpMkRef, a1, _) ->
            let (ce1, ccode) = atom2cexp a1 ccode sc kloc in
            let (r_exp, _) = get_dstexp dstexp_r "r" ctyp [] [] sc kloc in
            let ccode = make_mkref_call ce1 r_exp ccode kloc in
            (false, r_exp, ccode)
        | KExpUnOp(OpDeref, a1, _) ->
            let a_id = match a1 with
                | Atom.Id a_id -> a_id
                | _ -> raise_compile_err kloc "cgen: deref operand is not an identifier"
                in
            let (ce, ccode) = id2cexp a_id false ccode sc kloc in
            let n_id = get_id "data" in
            (true, (cexp_arrow ce n_id ctyp), ccode)
        | KExpUnOp(uop, a1, _) ->
            let (ce1, ccode) = atom2cexp a1 ccode sc kloc in
            let c_uop = match uop with
                | OpPlus -> COpPlus
                | OpNegate -> COpNegate
                | OpBitwiseNot -> COpBitwiseNot
                | OpLogicNot -> COpLogicNot
                | OpDeref | OpMkRef | OpExpand ->
                    raise_compile_err kloc (sprintf "cgen: unsupported unary op '%s'" (unop_to_string uop))
            in (true, CExpUnOp(c_uop, ce1, (ctyp, kloc)), ccode)
        | KExpIntrin(intr, args, _) ->
            (match (intr, args) with
            | (IntrinVariantTag, v :: []) ->
                let (cv, ccode) = atom2cexp v ccode sc kloc in
                let ktyp = get_atom_ktyp v kloc in
                let {ktp_ptr} = K_annotate_types.get_ktprops ktyp kloc in
                let extract_ctag = if ktp_ptr then
                        make_call !std_FX_REC_VARIANT_TAG [cv] CTypCInt kloc
                    else
                        cexp_mem cv (get_id "tag") CTypCInt
                    in
                let extract_ctag = match ktyp with
                    | KTypName tn -> (match (kinfo_ tn kloc) with
                        | KVariant {contents={kvar_flags; kvar_cases}} ->
                            let have_tag = not (List.mem VariantNoTag kvar_flags) in
                            let is_recursive = List.mem VariantRecursive kvar_flags in
                            let ncases = List.length kvar_cases in
                            if have_tag then extract_ctag
                            else if ncases = 1 && not is_recursive then
                                (make_int_exp 1 kloc)
                            else if ncases <= 2 && is_recursive then
                                CExpBinOp(COpCompareNE, cv, (make_nullptr kloc), (CTypBool, kloc))
                            else
                                raise_compile_err kloc "cgen: variants with no tag may have either 1 or 2 cases"
                        | _ -> raise_compile_err kloc (sprintf
                            "cgen: unexpected type '%s'; should be variant of exception"
                            (idk2str tn kloc)))
                    | _ -> extract_ctag
                    in
                (true, extract_ctag, ccode)
            | (IntrinVariantCase, v :: vn_val :: []) ->
                let (cv, ccode) = atom2cexp v ccode sc kloc in
                let vktyp = get_atom_ktyp v kloc in
                let {ktp_ptr} = K_annotate_types.get_ktprops vktyp kloc in
                (match (vktyp, vn_val) with
                | (KTypExn, (Atom.Id vn)) ->
                    (match (cinfo_ vn kloc) with
                    | CExn {contents={cexn_data}} ->
                        let exn_data = cexp_mem cv (get_id "data") CTypAny in
                        let exn_data = make_call (get_id "FX_EXN_DATA")
                            [CExpTyp ((CTypName cexn_data), kloc); exn_data] ctyp kloc in
                        (true, exn_data, ccode)
                    | _ -> raise_compile_err kloc (sprintf "cgen: information about exception '%s' is not found"
                        (idk2str vn kloc)))
                | (_, (Atom.Id vn)) ->
                    let vn_val = get_orig_id vn in
                    let cvu = if ktp_ptr then
                        cexp_arrow cv (get_id "u") CTypAny
                    else
                        cexp_mem cv (get_id "u") CTypAny in
                    let celem = cexp_mem cvu vn_val ctyp in
                    (true, celem, ccode)
                | _ -> raise_compile_err kloc "cgen: invalid IntrinVariantCase 2nd parameter")
            | (IntrinListHead, l :: []) ->
                let (cl, ccode) = atom2cexp l ccode sc kloc in
                (true, (cexp_arrow cl (get_id "hd") ctyp), ccode)
            | (IntrinListTail, l :: []) ->
                let (cl, ccode) = atom2cexp l ccode sc kloc in
                (true, (cexp_arrow cl (get_id "tl") ctyp), ccode)
            | (IntrinPopExn, []) ->
                let (dst_exp, ccode) = get_dstexp dstexp_r "curr_exn" CTypExn [ValTemp] ccode sc kloc in
                let e = make_call (get_id "fx_exn_get_and_reset") [cexp_get_addr dst_exp] CTypVoid kloc in
                (false, dst_exp, (CExp e) :: ccode)
            | _ -> raise_compile_err kloc "cgen: unsupported KExpIntrin")
        | KExpSeq(el, _) ->
            let rec process_seq el ccode = match el with
                | [] -> (dummy_exp, ccode)
                | last :: [] -> kexp2cexp last dstexp_r ccode sc
                | e :: rest ->
                    let (_, ccode) = kexp2cexp e (ref None) ccode sc in
                    process_seq rest ccode
            in let (e, ccode) = process_seq el ccode in
            (false, e, ccode)
        | KExpIf(c, e1, e2, _) ->
            let (cc, ccode) = kexp2cexp c (ref None) ccode sc in
            let (dst_exp, ccode) = get_dstexp dstexp_r "t" ctyp [] ccode sc kloc in
            let (_, ccode1) = kexp2cexp e1 dstexp_r [] sc in
            let (_, ccode2) = kexp2cexp e2 dstexp_r [] sc in
            let c_e1 = rccode2stmt ccode1 (get_kexp_loc e1) in
            let c_e2 = rccode2stmt ccode2 (get_kexp_loc e2) in
            (false, dst_exp, (CStmtIf(cc, c_e1, c_e2, kloc)) :: ccode)

        | KExpCall(f, args, _) ->
            (*let _ = (printf "called function '%s'('%s') typ: " (id2str f) (idk2str f kloc); K_pp.pprint_ktyp_x ftyp_ kloc; printf "\n") in*)
            let (args, ccode) = List.fold_left (fun (args, ccode) arg ->
                let (carg, ccode) = atom2cexp arg ccode sc kloc in
                let carg = make_fun_arg carg kloc in
                (carg :: args, ccode)) ([], ccode) args
                in
            let (f, ci) = match (cinfo_ f kloc) with
                | CExn {contents={cexn_make}} -> (cexn_make, (cinfo_ cexn_make kloc))
                | ci -> (f, ci)
                in
            let (f_exp, have_out_arg, fv_args, is_nothrow, ccode) = match ci with
                | CFun cf ->
                    let _ = ensure_func_is_defined_or_declared f kloc in
                    let {cf_args; cf_rt; cf_flags; cf_cname; cf_loc} = !cf in
                    let is_nothrow = List.mem FunNoThrow cf_flags in
                    let (_, ret_id, _, have_fv_arg) = unpack_fun_args cf_args cf_rt is_nothrow in
                    let f_exp = make_id_exp f cf_loc in
                    let fv_args =
                        if not have_fv_arg then
                            []
                        else if not (List.mem FunUseFV cf_flags) then
                            [make_lit_exp LitNil kloc]
                        else if f = (curr_func kloc) then
                            [make_id_t_exp (get_id "fx_fv") std_CTypVoidPtr cf_loc]
                        else
                            raise_compile_err kloc
                                (sprintf "cgen: %s '%s' %s %s" "cgen: looks like lambda lifting did not transform"
                                cf_cname "call correctly. Functions that access free variables must be called via closure"
                                "(except for the case when function calls itself)")
                        in
                    (f_exp, ret_id <> noid, fv_args, is_nothrow, ccode)
                | CVal {cv_typ; cv_loc} ->
                    let (fclo_exp, ccode) = id2cexp f false ccode sc kloc in
                    let ftyp = deref_ktyp (get_idk_ktyp f kloc) kloc in
                    let cftyp = C_gen_types.ktyp2ctyp ftyp kloc in
                    let f_exp = cexp_mem fclo_exp (get_id "fp") cftyp in
                    let fv_args = [cexp_mem fclo_exp (get_id "fcv") std_CTypVoidPtr] in
                    (f_exp, true, fv_args, false, ccode)
                | _ -> raise_compile_err kloc (sprintf "cgen: the called '%s' is not a function nor value" (id2str f))
                in
            if not have_out_arg && ctyp <> CTypVoid then
                let args = List.rev (fv_args @ args) in
                let call_exp = CExpCall(f_exp, args, (ctyp, kloc)) in
                (true, call_exp, ccode)
            else
                let (args, dst_exp, ccode) = if ctyp = CTypVoid then (args, dummy_exp, ccode) else
                    let (dst_exp, ccode) = get_dstexp dstexp_r "res" ctyp [] ccode sc kloc in
                    (((cexp_get_addr dst_exp) :: args), dst_exp, ccode)
                    in
                let args = List.rev (fv_args @ args) in
                let fcall_rt = if is_nothrow then CTypVoid else CTypCInt in
                let fcall_exp = CExpCall(f_exp, args, (fcall_rt, kloc)) in
                if is_nothrow then
                    (false, dst_exp, (CExp fcall_exp) :: ccode)
                else
                    let ccode = add_fx_call fcall_exp ccode kloc in
                    (false, dst_exp, ccode)

        | KExpMkTuple(args, _) | KExpMkRecord(args, _) ->
            let prefix = match kexp with KExpMkTuple(_, _) -> "tup" | _ -> "rec" in
            let tcon = C_gen_types.get_constructor ctyp false kloc in
            let (cargs, ccode) = List.fold_left (fun (cargs, ccode) a ->
                let (ca, ccode) = atom2cexp a ccode sc kloc in
                let ca = if tcon = noid then ca else make_fun_arg ca kloc in
                ((ca :: cargs), ccode)) ([], ccode) args in
            if tcon <> noid then
                let (t_exp, _) = get_dstexp dstexp_r prefix ctyp [] [] sc kloc in
                let call_mktup = make_call tcon
                    ((List.rev cargs) @ [cexp_get_addr t_exp]) CTypVoid kloc in
                (false, t_exp, (CExp call_mktup) :: ccode)
            else
                let tup = gen_temp_idc prefix in
                let e0 = CExpInit((List.rev cargs), (ctyp, kloc)) in
                let (t_exp, ccode) = create_cdefval tup ctyp [] "" (Some e0) ccode sc kloc in
                (true, t_exp, ccode)
        | KExpMkClosure(make_fp, f, args, _) ->
            let fp_prefix = ((pp_id2str f) ^ "_fp") in
            if args = [] && make_fp = noid then
                let fp_id = gen_temp_idc fp_prefix in
                let f_exp = make_id_exp f kloc in
                let e0 = CExpInit([f_exp; (make_nullptr kloc)], (ctyp, kloc)) in
                let (fp_exp, ccode) = create_cdefval fp_id ctyp [] "" (Some e0) ccode sc kloc in
                (true, fp_exp, ccode)
            else
                let (cargs, ccode) = List.fold_left (fun (cargs, ccode) a ->
                    let (ca, ccode) = atom2cexp a ccode sc kloc in
                    let ca = make_fun_arg ca kloc in
                    ((ca :: cargs), ccode)) ([], ccode) args in
                let (fp_exp, _) = get_dstexp dstexp_r fp_prefix ctyp [] [] sc kloc in
                let call_mkclo = make_call make_fp
                    ((List.rev cargs) @ [cexp_get_addr fp_exp]) CTypVoid kloc in
                (false, fp_exp, (CExp call_mkclo) :: ccode)
        | KExpMkArray(shape, elems, _) ->
            let shape = List.map (fun i -> make_int_exp i kloc) shape in
            let (data, ccode) = List.fold_left (fun (data, ccode) a ->
                    let (e, ccode) = atom2cexp a ccode sc kloc in
                    (e :: data, ccode)) ([], ccode) elems in
            let (arr_exp, ccode) = decl_arr ctyp shape (List.rev data) dstexp_r ccode sc kloc in
            (false, arr_exp, ccode)
        | KExpAt(arr, idxs, _) ->
            (*
                there are 2 major cases:
                1. some of the idxs are ranges. Then the result is fx_arr_t
                2. all the ranges are scalars. Then the result is array element

                1. In the first case need to call a special function
                    `FX_CALL(fx_subarr(arr, ranges, subarr));`.
                    where ranges is array, concatenation of the following groups:
                    (0, idx) scalar indices
                    (1, a, b, delta) closed ranges [a:b:delta]
                        (if a was missing, it's set to 0, if delta was missing, it's set to 1)
                    (2, a, delta) open ranges [a::delta]
                        (if delta was missing, it's set to 1)
                1.1. special case if a single [:] range, which means flattening operation.
                    just call fx_flatten_arr().

                2. In the second case need first to process each index idx_k (k=0..ndims-1):
                   2.1. If idx_k is "fast index" - great, just use the expression for the index
                        (process it via `atom2cexp`)
                   2.2. Otherwise we need to use the index more than once, so we need to
                        store it to temporary variable (unless it's already an indentifier or constant)
                        and add it to the check
                        `FX_CHKIDX(FX_CHKIDX1(arr, k1, idx_k1) && FX_CHKIDX1(arr, k2, idx_k2) ..., catch_label);`
                    if all the indices are fast indices, the whole check is excluded, of course.
                    then we return `(true, FX_PTR_{ndims}D(elem_ctyp, arr, idx0, ..., idx{ndims-1}), ccode)`
            *)
            let (arr_exp, ccode) = atom2cexp_ arr false ccode sc kloc in
            let need_subarr = List.exists (fun d -> match d with Domain.Range _ -> true | _ -> false) idxs in
            let need_flatten = need_subarr && (match idxs with
                | Domain.Range((Atom.Lit LitNil), (Atom.Lit LitNil), (Atom.Lit LitNil)) :: []
                | Domain.Range((Atom.Lit (LitInt 0L)), (Atom.Lit LitNil), (Atom.Lit (LitInt 1L))) :: [] -> true
                | _ -> false)
                in
            if need_flatten then
                let (subarr_exp, _) = get_dstexp dstexp_r "arr" ctyp [] [] sc kloc in
                let call_flatten = make_call (get_id "fx_flatten_arr")
                    [(cexp_get_addr arr_exp); (cexp_get_addr subarr_exp)] CTypCInt kloc in
                (false, subarr_exp, (add_fx_call call_flatten ccode kloc))
            else if need_subarr then
                let (range_data, ccode) = List.fold_left (fun (range_data, ccode) d ->
                    match d with
                    | Domain.Elem i | Domain.Fast i ->
                        let (i_exp, ccode) = atom2cexp i ccode sc kloc in
                        ((i_exp :: (make_int_exp 0 kloc) :: range_data), ccode)
                    | Domain.Range (a, b, delta) ->
                        let (a_exp, ccode) = atom2cexp a ccode sc kloc in
                        let (range_delta, ccode) = match b with
                            | Atom.Lit LitNil -> ((a_exp :: (make_int_exp 2 kloc) :: []), ccode)
                            | _ ->
                                let (b_exp, ccode) = atom2cexp b ccode sc kloc in
                                ((b_exp :: a_exp :: (make_int_exp 1 kloc) :: []), ccode)
                            in
                        let (d_exp, ccode) = atom2cexp delta ccode sc kloc in
                        (((d_exp :: range_delta) @ range_data), ccode)) ([], ccode) idxs
                    in
                let rdata_ctyp = CTypRawArray ([CTypConst], CTypInt) in
                let rdata_arr = CExpInit((List.rev range_data), (rdata_ctyp, kloc)) in
                let (rdata_exp, ccode) = create_cdefval (gen_temp_idc "ranges") rdata_ctyp [] "" (Some rdata_arr) ccode sc kloc in
                let (subarr_exp, _) = get_dstexp dstexp_r "arr" ctyp [] [] sc kloc in
                let call_subarr = make_call !std_fx_subarr [(cexp_get_addr arr_exp);
                    rdata_exp; (cexp_get_addr subarr_exp)] CTypCInt kloc in
                (false, subarr_exp, (add_fx_call call_subarr ccode kloc))
            else
                let elem_ctyp = ctyp in
                let (_, chk_exp_opt, i_exps, ccode) = List.fold_left (fun (dim, chk_exp_opt, i_exps, ccode) d ->
                    match d with
                    | Domain.Fast i ->
                        let (i_exp, ccode) = atom2cexp i ccode sc kloc in
                        (dim+1, chk_exp_opt, i_exp :: i_exps, ccode)
                    | Domain.Elem i ->
                        let (i_exp, ccode) = atom2cexp_ i true ccode sc kloc in
                        let chk_exp1 = make_call !std_FX_CHKIDX1 [arr_exp; (make_int_exp dim kloc); i_exp] CTypBool kloc in
                        let chk_exp_opt = match chk_exp_opt with
                            | Some(chk_exp) ->
                                let chk_exp = CExpBinOp(COpLogicAnd, chk_exp, chk_exp1, (CTypBool, kloc)) in
                                Some chk_exp
                            | _ -> Some(chk_exp1)
                            in
                        (dim+1, chk_exp_opt, i_exp :: i_exps, ccode)
                    | _ -> raise_compile_err kloc "cgen: unexpected index type")
                    (0, None, [], ccode) idxs
                    in
                let ccode = match chk_exp_opt with
                    | Some (chk_exp) ->
                        let l = curr_block_label kloc in
                        let call_chkidx = make_call !std_FX_CHKIDX [chk_exp; l] CTypVoid kloc in
                        (CExp call_chkidx) :: ccode
                    | _ -> ccode
                    in
                let ndims = List.length idxs in
                let get_elem_exp = make_call (List.nth (!std_FX_PTR_xD) (ndims-1))
                    (CExpTyp (elem_ctyp,kloc) :: arr_exp :: (List.rev i_exps)) (make_ptr elem_ctyp) kloc in
                (true, (cexp_deref get_elem_exp), ccode)
        | KExpMem(a1, n, _) ->
            let (ce1, ccode) = id2cexp a1 false ccode sc kloc in
            let (_, ce1, relems, ofs) = get_struct ce1 in
            let nelems = List.length relems in
            let _ = if n < 0 || n+ofs >= nelems then
                raise_compile_err kloc (sprintf "cgen: the tuple/record element index %d is out of range [0, %d]" n nelems)
                else () in
            let (n_id, _) = List.nth relems (n+ofs) in
            (true, (cexp_mem ce1 n_id ctyp), ccode)
        | KExpAssign(i, a, _) ->
            let ktyp = get_idk_ktyp i kloc in
            let {ktp_complex} = K_annotate_types.get_ktprops ktyp kloc in
            let ccode =
                if ktp_complex then
                    let (i_exp, ccode) = id2cexp i true ccode sc kloc in
                    let (e_exp, ccode) = atom2cexp_ a true ccode sc kloc in
                    let ctyp = get_cexp_typ i_exp in
                    (if is_subarray i kloc then
                        let copy_arr_data = make_call !std_fx_copy_arr_data [(cexp_get_addr e_exp);
                            (cexp_get_addr i_exp); (make_bool_exp true kloc)] CTypInt kloc in
                        add_fx_call copy_arr_data ccode kloc
                    else
                        (* if "i" occurs in "e2", we need to be safe and free "i" only after "e2" is computed *)
                        let ccode = C_gen_types.gen_free_code i_exp ctyp true false ccode kloc in
                        C_gen_types.gen_copy_code e_exp i_exp ctyp ccode kloc)
                else
                    (* if the type is simple, copy it rhs directly to lhs *)
                    let (i_exp, ccode) = id2cexp i false ccode sc kloc in
                    let (a_exp, ccode) = atom2cexp a ccode sc kloc in
                    C_gen_types.gen_copy_code a_exp i_exp ctyp ccode kloc
                in
            (false, dummy_exp, ccode)
        | KExpMatch(cases, _) ->
            (*
            code00; if(exp00) {
                code01; if(exp01) {
                ... if(exp0N0) {
                    action0; goto _fx_endmatch...;
            }...}}
            code10; if(exp01) {
                code11; if(exp11) {
                ... if(exp1N1) {
                    action1; goto _fx_endmatch...;
            }...}}
            ...
            #if <have_default_action>
            default_action; // if there is default case
            #else
            FX_THROW_FAST(FX_EXN_NoMatchError, parent_label);
            #endif
            [_fx_endmatch...:]
            ...
            *)
            let (dst_exp, ccode) = get_dstexp dstexp_r "res" ctyp [] ccode sc kloc in
            let ccode = process_cases cases dstexp_r ccode false sc kloc in
            (false, dst_exp, ccode)

        | KExpTryCatch(try_e, catch_e, _) ->
            (*
            [dst_exp =] try_block
            if(fx_status < 0) {
                fx_status = 0;
                [destruct dst_exp] // because it maybe partially constructed at this point,
                                   // but we are going to re-use it
                catch_code
            }
            *)
            let (dst_exp, ccode) = get_dstexp dstexp_r "res" ctyp [] ccode sc kloc in
            let try_loc = get_kexp_loc try_e in
            let try_end_loc = get_end_loc try_loc in
            let _ = new_block_ctx BlockKind_Try sc try_loc in
            let (_, try_ccode) = kexp2cexp try_e dstexp_r [] sc in
            let bctx_try = curr_block_ctx kloc in
            let {bctx_prologue; bctx_cleanup; bctx_label; bctx_label_used} = bctx_try in
            let epilogue =
                if bctx_label_used = 0 then bctx_cleanup
                else bctx_cleanup @ (CStmtLabel (bctx_label, try_end_loc) :: [])
                in
            let ccode = epilogue @ try_ccode @ bctx_prologue @ ccode in
            let _ = pop_block_ctx try_end_loc in
            let fx_status_exp = make_fx_status try_end_loc in
            let catch_ccode = [CExp (CExpBinOp(COpAssign, fx_status_exp,
                (make_int_exp 0 try_end_loc), (CTypVoid, try_end_loc)))] in
            let catch_ccode = match ctyp with
                | CTypVoid -> catch_ccode
                | _ -> C_gen_types.gen_free_code dst_exp ctyp true true catch_ccode try_end_loc
                in
            let (_, catch_ccode) = kexp2cexp catch_e dstexp_r catch_ccode sc in
            let check_neg_status = CExpBinOp(COpCompareLT, (make_fx_status try_end_loc),
                (make_int_exp 0 try_end_loc), (CTypBool, try_end_loc)) in
            let catch_loc = get_kexp_loc catch_e in
            let catch_clause = CStmtIf(check_neg_status,
                (rccode2stmt catch_ccode catch_loc), (CStmtNop try_end_loc), catch_loc) in
            (false, dst_exp, catch_clause :: ccode)
        | KExpThrow(i, rethrow, _) ->
            let lbl = curr_block_label kloc in
            let ccode = if rethrow then
                let (i_exp, ccode) = id2cexp i false ccode sc kloc in
                let throw_exp = make_call !std_FX_RETHROW [(cexp_get_addr i_exp); lbl] CTypVoid kloc in
                (CExp throw_exp) :: ccode
            else match Hashtbl.find_all builtin_exceptions i with
            | [] ->
                let move_f = match (kinfo_ i kloc) with
                    | KExn _ -> false
                    | KVal {kv_typ=KTypExn} -> IdSet.mem i u1vals
                    | _ -> raise_compile_err kloc
                        "cgen: throw is applied to neither exception nor value of 'exn' type"
                    in
                let (i_exp, ccode) = id2cexp i move_f ccode sc kloc in
                let throw_exp = make_call !std_FX_THROW
                    [(cexp_get_addr i_exp); (make_bool_exp move_f kloc); lbl] CTypVoid kloc in
                (CExp throw_exp) :: ccode
            | _ ->
                let i = get_id ("FX_EXN_" ^ (pp_id2str i)) in
                let i_exp = make_id_t_exp i CTypCInt kloc in
                let throw_exp = make_call !std_FX_FAST_THROW [i_exp;lbl] CTypVoid kloc in
                (CExp throw_exp) :: ccode
                in
            (false, dummy_exp, ccode)
        | KExpCast(a1, kt, _) ->
            let (ce1, ccode) = atom2cexp a1 ccode sc kloc in
            let ctyp = C_gen_types.ktyp2ctyp kt kloc in
            (true, CExpCast(ce1, ctyp, kloc), ccode)
        | KExpMap(e_kdl_l, body, flags, _) ->
            (*
                1. generate output collection (`arr/list_first = get_dstexp).
                   in the case of list also declare `_fx_L... list_last=0;`
                2. make list of expressions before each for in the comprehension, starting from the outer loop:
                    pre_e1 :: pre_e2 ... :: pre_body :: []
                   at once compute the output dimensionality
                3. define recursive function:
                    run process_for
                    if it's the inner-most loop and if we make array,
                        check the size of array if it is already created,
                        otherwise create the array.
                    if we make array, but there are just lists
                    form nested scope
                    form nested_ccode (see KExpFor, how body_ccode is formed)
                    if there are no more nested fors,
                        call `result=get_dstexp...` to store the body expression result.
                        gen ccode for the body.
                        if we make array,
                            check that there are no break or continue statement inside for.
                            form `*dstptr++ = result;` expression
                        otherwise (we make list)
                            create list cell (no need to put it to prologue, because we are not going to release it)
                            _fx_L... list_cell;
                            FX_CALL(_fx_make_L...(result, 0, &list_cell), end_loop);
                            FX_LIST_APPEND(list_first, list_last, list_cell);
                        finalize loop, make CExp (CExpFor(...)) :: []
                    else
                        call function recursively, get for-loop with attached parts.
                    return post_ccode :: (formed_for_loop @ init_ccode)
                4. pass there everything, append the result to ccode.
                5. return (false, arr/list_exp, ccode)
            *)
            let for_loc = get_start_loc kloc in
            let end_for_loc = get_end_loc kloc in
            let need_make_list = List.mem ForMakeList flags in
            let need_make_array = (List.mem ForMakeArray flags) || not need_make_list in
            let nfors = List.length e_kdl_l in
            (* compute the total array dimensionality *)
            let (_, ndims) = List.fold_left (fun (for_idx, ndims) (e, kdl) ->
                let ndims_i = compute_for_ndims for_idx nfors kdl for_loc in
                (for_idx+1, ndims + ndims_i)) (0, 0) e_kdl_l
                in
            (* declare the output array/list; in the case of array also declare the output pointer;
               in the case of list also declare pointer to the last list element *)
            let (elemtyp, dst_exp, dstptr, lstend, ccode) =
                match (need_make_array, need_make_list, ctyp, (deref_ktyp ktyp for_loc)) with
                | (true, false, CTypArray(nd, elemtyp), KTypArray _) ->
                    let (dst_exp, ccode) = get_dstexp dstexp_r "arr" ctyp [] ccode sc for_loc in
                    let (dst_ptr, ccode) = create_cdefval (gen_temp_idc "dstptr") (make_ptr elemtyp)
                        [ValMutable] "" (Some (make_nullptr for_loc)) ccode sc for_loc in
                    if nd <> ndims then
                        raise_compile_err kloc
                        (sprintf "cgen: invalid dimensionaly of array comprehension result (computed: %d, expected: %d)" ndims nd)
                    else (elemtyp, dst_exp, dst_ptr, (make_dummy_exp for_loc), ccode)
                | (false, true, _, KTypList kelemtyp) ->
                    let elemtyp = C_gen_types.ktyp2ctyp kelemtyp for_loc in
                    let (dst_exp, ccode) = get_dstexp dstexp_r "lst" ctyp [] ccode sc for_loc in
                    let (lst_end, ccode) = create_cdefval (gen_temp_idc "lstend") ctyp
                        [ValMutable] "" (Some (make_nullptr for_loc)) ccode sc for_loc in
                    (elemtyp, dst_exp, (make_dummy_exp for_loc), lst_end, ccode)
                | _ -> raise_compile_err kloc (sprintf
                    "cgen: invalid combination of comprehension type (%s) and the output collection type"
                    (if need_make_array then "MAKE_ARRAY" else if need_make_list then "MAKE_LIST" else "???"))
                in
            let rec form_map for_idx e_kdl_l prev_n_exps =
                let (init_kexp, kdl, nested_e_kdl) =
                    match e_kdl_l with
                    | (e, kdl) :: rest -> (e, kdl, rest)
                    | _ -> raise_compile_err for_loc "cgen: empty e_kdl_l in KExpMap"
                    in
                let dims_ofs = List.length prev_n_exps in
                let nested_loc = get_kexp_loc init_kexp in
                let nested_loc = if nested_loc = noloc then for_loc else nested_loc in
                let (_, init_ccode) = kexp2cexp init_kexp (ref None) [] sc in
                let lbl = curr_block_label nested_loc in
                let (for_headers, list_exps, n_exps, init_ccode, pre_body_ccode, body_elems, post_ccode) =
                    process_for lbl kdl for_idx nfors ndims dims_ofs nested_e_kdl init_ccode sc nested_loc in
                let (ndims_i, n_exps, init_ccode) = match (list_exps, n_exps, need_make_array) with
                    | (_, n_exp :: _, _) -> ((List.length n_exps), n_exps, init_ccode)
                    | (l_exp :: _, [], true) ->
                        (* if there is no fixed range or array iterated, just list(s),
                           and we need to make array, we need to compute length of the list. *)
                        let call_list_len = make_call !std_fx_list_length [l_exp] CTypInt nested_loc in
                        let (lstlen, init_ccode) = create_cdefval (gen_temp_idc "len")
                            CTypInt [] "" (Some call_list_len) init_ccode sc nested_loc in
                        (1, [lstlen], init_ccode)
                    | ([], [], true) ->
                        raise_compile_err nested_loc
                            (for_err_msg for_idx nfors (-1) "array comprehension uses 'for' with indefinite range")
                    | _ -> (1, n_exps, init_ccode)
                    in
                let n_exps = prev_n_exps @ n_exps in
                let init_ccode = if (not need_make_array) || (dims_ofs + ndims_i < ndims) then init_ccode else
                    let (_, cmp_size_list) = List.fold_left (fun (k, cmp_size_list) n_exp ->
                        let size_i = make_call !std_FX_ARR_SIZE [dst_exp; (make_int_exp k nested_loc)] CTypInt nested_loc in
                        let cmp_size_i = CExpBinOp(COpCompareEQ, size_i, n_exp, (CTypBool, nested_loc)) in
                        (k+1, cmp_size_i :: cmp_size_list)) (0, []) n_exps
                        in
                    let then_ccode = make_make_arr_call dst_exp n_exps [] [] sc nested_loc in
                    let arr_data = CExpCast((cexp_mem dst_exp (get_id "data") std_CTypVoidPtr), (make_ptr elemtyp), nested_loc) in
                    let set_dstptr = make_assign dstptr arr_data in
                    let then_ccode = (CExp set_dstptr) :: then_ccode in
                    if for_idx = 0 then
                        then_ccode @ init_ccode
                    else
                        let cc_exp = cexp_mem dst_exp (get_id "data") std_CTypVoidPtr in
                        let cc_exp = CExpUnOp(COpLogicNot, cc_exp, (CTypBool, nested_loc)) in
                        let else_ccode = add_size_eq_check cmp_size_list [] lbl nested_loc in
                        let check_or_create = CStmtIf(cc_exp,
                            (rccode2stmt then_ccode nested_loc),
                            (rccode2stmt else_ccode nested_loc), nested_loc) in
                        check_or_create :: init_ccode
                    in
                let for_flags = if for_idx > 0 then [ForNested] else [] in
                let _ = new_for_block_ctx ndims for_flags sc kloc in
                (* inside the loop body context form `<etyp> v=e` expressions (or more complex ones in the case of complex types) *)
                let body_ccode = decl_for_body_elems body_elems [] sc in
                let (add_incr_dstptr, body_ccode) = match nested_e_kdl with
                    | (body, []) :: [] ->
                        (* add the loop body itself *)
                        let (result, body_ccode) = kexp2cexp body (ref None) body_ccode sc in
                        let body_loc = get_kexp_loc body in
                        (* [TODO] if the result is temporarily created value, then it would be more efficient
                               to "move" it to the output collection instead of copying it there:
                            1. the result should be local variable that is defined in the body prologue
                               (which means that it's temporary and it's complex).
                               Note that it is compile-time check, not runtime check.
                               If the result is not complex, we don't call destructor and use simple '=' operator,
                               no need to bother with move.
                            2. we update C_gen_types.get_ctprops to return move macro
                               (FX_MOVE_STR, FX_MOVE_ARR, FX_MOVE_PTR, FX_MOVE_RECORD
                               (the last one is universal macro)).
                               we use move_macro(result, *dstptr).
                               We still need to retain conditional destructor call for 'result',
                               but it will do nothing (and the check will be perfectly predicted,
                               because it will _always_ do nothing, except for the exceptional situations)
                            3. (optional: we need to extend _fx_cons_L...() implementation:
                                add `bool move_hd` parameter), otherwise we use this 'move' trick
                                only with array comprehensions.
                        *)
                        if need_make_array then
                            (true, (C_gen_types.gen_copy_code result
                                    (cexp_deref dstptr) elemtyp body_ccode body_loc))
                        else
                            let (node_exp, body_ccode) = create_cdefval (gen_temp_idc "node") ctyp [] ""
                                (Some (make_nullptr body_loc)) body_ccode sc body_loc in
                            let body_ccode = make_cons_call result (make_nullptr body_loc)
                                false node_exp body_ccode body_loc in
                            let append_call = make_call !std_FX_LIST_APPEND [dst_exp; lstend; node_exp] CTypVoid body_loc in
                            (false, (CExp append_call) :: body_ccode)
                    | _ ->
                        (false, (form_map (for_idx+1) nested_e_kdl n_exps))
                    in
                (* add the initialization and the cleanup sections, if needed *)
                let (br_label, body_stmt) = finalize_loop_body body_ccode (not need_make_array) kloc in

                (* form (possibly nested) for statement *)
                let (_, for_stmt) = List.fold_left (fun (k, for_stmt) (t_opt, for_inits, for_check_opt, for_incrs) ->
                    let for_incrs = if k > 0 || (not add_incr_dstptr) then for_incrs else
                        for_incrs @ [CExpUnOp(COpSuffixInc, dstptr, (CTypVoid, for_loc))]
                        in
                    let for_stmt = CStmtFor(t_opt, for_inits, for_check_opt, for_incrs, for_stmt, kloc) in
                        (k+1, (if k > 0 || pre_body_ccode = [] then for_stmt else
                    rccode2stmt (for_stmt :: pre_body_ccode) for_loc))) (0, body_stmt) (List.rev for_headers)
                in
                (* add the non-local "break" label if needed *)
                let post_ccode = if br_label = noid then post_ccode else (CStmtLabel(br_label, end_for_loc)) :: post_ccode in
                post_ccode @ (for_stmt :: init_ccode)
            in
            let map_ccode = form_map 0 (e_kdl_l@[(body, [])]) [] in
            (false, dummy_exp, map_ccode @ ccode)
        | KExpFor(kdl, body, flags, _) ->
            let lbl = curr_block_label kloc in
            let for_loc = get_start_loc kloc in
            let end_for_loc = get_end_loc kloc in
            let ndims = compute_for_ndims 0 1 kdl for_loc in
            let (for_headers, _, _, ccode, pre_body_ccode, body_elems, post_ccode) =
                process_for lbl kdl 0 1 ndims 0 [(body, [])] ccode sc kloc
                in
            let _ = new_for_block_ctx ndims flags sc kloc in
            (* inside the loop body context form `<etyp> v=e` expressions (or more complex ones in the case of complex types) *)
            let body_ccode = decl_for_body_elems body_elems [] sc in
            (* add the loop body itself *)
            let (_, body_ccode) = kexp2cexp body (ref None) body_ccode sc in
            let body_loc = get_kexp_loc body in
            (* add the initialization and the cleanup sections, if needed *)
            let (br_label, body_stmt) = finalize_loop_body body_ccode true body_loc in

            (* form (possibly nested) for statement *)
            let (_, for_stmt) = List.fold_left (fun (k, for_stmt) (t_opt, for_inits, for_check_opt, for_incrs) ->
                let for_stmt = CStmtFor(t_opt, for_inits, for_check_opt, for_incrs, for_stmt, kloc) in
                (k+1, (if k > 0 || pre_body_ccode = [] then for_stmt else
                    rccode2stmt (for_stmt :: pre_body_ccode) for_loc))) (0, body_stmt) (List.rev for_headers)
                in
            (* add the non-local "break" label if needed *)
            let post_ccode = if br_label = noid then post_ccode else (CStmtLabel(br_label, end_for_loc)) :: post_ccode in
            (* add it all to ccode; nothing to return/assign, since "for-loop" is "void" expression *)
            (false, dummy_exp, post_ccode @ (for_stmt :: ccode))
        | KExpWhile(c, body, _) ->
            let _ = new_block_ctx BlockKind_Loop sc kloc in
            let (cc, cc_code) = kexp2cexp c (ref None) [] sc in
            let (is_for_loop, check_code) =
                (match (cc, cc_code) with
                | (CExpLit((LitBool true), _), []) -> (true, [])
                | (_, []) -> (false, [])
                | _ ->
                    let cc_loc = get_cexp_loc cc in
                    let not_cc = CExpUnOp(COpLogicNot, cc, (CTypBool, cc_loc)) in
                    let break_stmt = make_break_stmt cc_loc in
                    let check_cc = CStmtIf(not_cc, break_stmt, CStmtNop(cc_loc), cc_loc) in
                    (true, check_cc :: cc_code))
                in
            let (_, body_ccode) = kexp2cexp body (ref None) [] sc in
            let body_ccode = body_ccode @ check_code in
            let (_, body_stmt) = finalize_loop_body body_ccode true kloc in
            let loop_stmt = (if is_for_loop then
                    CStmtFor(None, [], None, [], body_stmt, kloc)
                else
                    CStmtWhile(cc, body_stmt, kloc))
            in
            (false, dummy_exp, loop_stmt :: ccode)
        | KExpDoWhile(body, c, _) ->
            let _ = new_block_ctx BlockKind_Loop sc kloc in
            let (_, body_ccode) = kexp2cexp body (ref None) [] sc in
            let (cc, cc_code) = kexp2cexp c (ref None) [] sc in
            let (is_for_loop, check_code) =
                (match (cc, cc_code) with
                | (CExpLit((LitBool true), _), []) -> (true, [])
                | (_, []) -> (false, [])
                | _ ->
                    let cc_loc = get_cexp_loc cc in
                    let not_cc = CExpUnOp(COpLogicNot, cc, (CTypBool, cc_loc)) in
                    let break_stmt = make_break_stmt cc_loc in
                    let check_cc = CStmtIf(not_cc, break_stmt, CStmtNop(cc_loc), cc_loc) in
                    (true, check_cc :: cc_code))
                in
            let body_ccode = check_code @ body_ccode in
            let (_, body_stmt) = finalize_loop_body body_ccode true kloc in
            let loop_stmt = if is_for_loop then
                    CStmtFor(None, [], None, [], body_stmt, kloc)
                else
                    CStmtDoWhile(body_stmt, cc, kloc)
            in
            (false, dummy_exp, loop_stmt :: ccode)
        | KExpCCode(ccode_str, _) ->
            if (curr_block_ctx kloc).bctx_kind <> BlockKind_Global then
                raise_compile_err kloc "cgen: unexpected ccode expression"
            else ();
            top_ccode := CExp (CExpCCode(ccode_str, kloc)) :: !top_ccode;
            (false, dummy_exp, ccode)
        | KDefVal(i, e2, _) ->
            let {kv_typ; kv_cname; kv_flags} = get_kval i kloc in
            let {ktp_ptr; ktp_complex; ktp_scalar} = K_annotate_types.get_ktprops kv_typ kloc in
            let ctyp = C_gen_types.ktyp2ctyp kv_typ kloc in
            let bctx = curr_block_ctx kloc in
            let (is_ccode, ccode_lit, ccode_loc) = match e2 with
                | KExpCCode (c, (_, l)) -> (true, c, l)
                | _ -> (false, "", kloc)
                in
            let ctor_id = get_val_ctor kv_flags in
            let is_temp = List.mem ValTemp kv_flags in
            let is_temp_ref = List.mem ValTempRef kv_flags in
            let is_global = bctx.bctx_kind == BlockKind_Global && not is_temp && not is_temp_ref in
            let is_fast_cons = is_temp && (match e2 with
                | KExpBinOp(OpCons, a, (Atom.Id l), _) when (IdSet.mem l u1vals) ->
                    (match (kinfo_ l kloc) with
                    | KVal {kv_flags} -> List.mem ValTemp kv_flags
                    | _ -> false)
                | _ -> false)
                in
            (* there are 3 cases (ce2 denotes e2 converted to C):
                1. definition "ctyp i = ce2" is not added; instead, i is replaced with ce2.
                2. i is defined separately: "ctyp i[={}|0];" and then
                   expression is compiled with 'i' as the destination.
                3. i is defined and initialized at once: "ctyp i=ce2;"
            *)
            let ccode =
                if is_ccode then
                    let (_, delta_ccode) = create_cdefval i ctyp [] "" (Some (CExpCCode(ccode_lit, ccode_loc))) [] sc kloc in
                    let _ = bctx.bctx_prologue <- delta_ccode @ bctx.bctx_prologue in
                    ccode
                else if ctor_id <> noid then
                    let tag_exp = make_id_t_exp ctor_id CTypCInt kloc in
                    let is_null = (match kv_typ with
                        | KTypName tn -> (match (kinfo_ tn kloc) with
                            | KVariant {contents={kvar_flags}} -> List.mem VariantRecOpt kvar_flags
                            | _ -> false)
                        | _ -> false)
                        in
                    let (init_exp, delta_ccode) =
                        if not ktp_ptr then
                            let init_exp = CExpInit([tag_exp], (ctyp, kloc)) in
                            (init_exp, [])
                        else if is_null then
                            ((make_nullptr kloc), [])
                        else
                            (* temporarily put (i, ctyp) into the value table *)
                            let (i_exp, _) = create_cdefval i ctyp [] "" None [] sc kloc in
                            let (rn, _, _, _) = get_struct i_exp in
                            let struct_ctyp = CTypName rn in
                            let data_id = gen_temp_idc ((pp_id2str i) ^ "_data") in
                            let rc_exp = make_int_exp 1 kloc in
                            let data_init = CExpInit([rc_exp; tag_exp], (struct_ctyp, kloc)) in
                            let (data_exp, delta_ccode) = create_cdefval data_id struct_ctyp [ValPrivate] ""
                                (Some data_init) [] sc kloc in
                            ((cexp_get_addr data_exp), delta_ccode)
                        in
                    let (_, delta_ccode) = create_cdefval i ctyp [ValPrivate] "" (Some init_exp) delta_ccode sc kloc in
                    (* just put initialization into the global scope, no destructors are needed *)
                    let _ = bctx.bctx_prologue <- delta_ccode @ bctx.bctx_prologue in
                    ccode
                else if is_fast_cons || ((is_temp_ref || (ktp_scalar && is_temp)) && (IdSet.mem i u1vals)) then
                    let (ce2, ccode) = kexp2cexp e2 (ref None) ccode sc in
                    (* we still need to declare i to be able to access its type *)
                    let _ = create_cdefval i ctyp kv_flags "" None [] sc kloc in
                    let _ = i2e := Env.add i ce2 !i2e in
                    ccode
                else if is_temp_ref then
                    let (ce2, ccode) = kexp2cexp e2 (ref None) ccode sc in
                    let (_, ccode) = add_local_tempref i ctyp kv_flags ce2 ccode sc kloc in
                    ccode
                else if ktp_complex || is_global ||
                    (match e2 with
                    | KExpAtom _ | KExpBinOp _ | KExpUnOp _ | KExpIntrin _ | KExpMkTuple _
                    | KExpMkRecord _ | KExpAt _ | KExpMem _ | KExpCast _ | KExpCCode _ -> false
                    | _ -> true) then
                    (* disable i=e2 assignment if i has complex type and e2 is "Nil".
                       If i is complex, it will be initialized anyway with "0" or "{}".
                       We do not need to re-initialize it once again *)
                    let assign_e2 =
                        match (ktp_complex, e2) with
                        | (true, KExpAtom((Atom.Lit LitNil), _)) -> false
                        | _ -> true
                        in
                    let (flags, e0_opt, assign_e2) =
                        if not is_global then (kv_flags, None, assign_e2)
                        else
                            (* if a global value/variable is initialized with constant,
                            we just use this constant for its initialization instead of
                            setting it to "0" and reassigning inside fx_toplevel() *)
                            let (e0_opt, assign_e2) =
                            if ktp_complex then
                                (None, assign_e2)
                            else if ktp_ptr || ktp_scalar then
                                (match e2 with
                                | KExpAtom((Atom.Lit l), (e2_ktyp, e2_loc)) ->
                                    let e2_ctyp = C_gen_types.ktyp2ctyp e2_ktyp e2_loc in
                                    (Some (CExpLit(l, (e2_ctyp, e2_loc))), false)
                                | _ -> (None, assign_e2))
                            else
                                (None, assign_e2)
                            in
                        (ValPrivate :: kv_flags, e0_opt, assign_e2)
                        in
                    let (i_exp, delta_ccode) = add_local i ctyp flags e0_opt [] sc kloc in
                    let ccode = if is_global then (bctx.bctx_prologue <- delta_ccode @ bctx.bctx_prologue; ccode)
                        else delta_ccode @ ccode in
                    if assign_e2 then
                        let (_, ccode) = kexp2cexp e2 (ref (Some i_exp)) ccode sc in
                        (match ccode with
                        | CExp (CExpBinOp(COpAssign, CExpIdent(j, _), e, (_, loc))) ::
                            CDefVal(t, i, None, _) :: rest when j = i ->
                            CDefVal(t, i, (Some e), loc) :: rest
                        | _ -> ccode)
                    else
                        ccode
                else
                    let (ce2, ccode) = match (ktp_ptr, e2) with
                        | (false, KExpAtom((Atom.Lit LitNil), (_, loc))) -> (CExpInit([], (ctyp, loc)), ccode)
                        | _ -> kexp2cexp e2 (ref None) ccode sc
                        in
                    let (_, ccode) = match (e2, ccode) with
                        | ((KExpMkRecord _), (CDefVal (t, tval, (Some rhs), loc) :: rest))
                        | ((KExpMkTuple _), (CDefVal (t, tval, (Some rhs), loc) :: rest)) ->
                            add_local i ctyp kv_flags (Some rhs) rest sc kloc
                        | _ -> add_local i ctyp kv_flags (Some ce2) ccode sc kloc
                        in
                    ccode
                in
            (if kv_cname = "" then () else
            match (cinfo_ i kloc) with
            | CVal cv ->
                let cv = {cv with cv_cname=kv_cname} in
                set_idc_entry i (CVal cv)
            | _ -> ());
            (false, dummy_exp, ccode)
        | KDefFun kf ->
            (*
                generate new context.
                generate ccode for the body with dstid=fx_result.
                add the prologue and the cleanup sections to the generated c code.
                before cleanup possibly insert a label if needed.
                prior to the cleanup save the output expression if needed
                (because it may use elements that will be released)
                after cleanup section add "return fx_status;" if needed or
                "return ret_exp"; if the function is nothrow and is not void.

                handle the case of 'c code'-body separately
            *)
            let {kf_name; kf_rt; kf_closure; kf_body; kf_cname; kf_flags; kf_scope; kf_loc} = !kf in
            let {kci_arg; kci_fcv_t} = kf_closure in
            let ctor = get_fun_ctor kf_flags in
            let _ = if kci_arg = noid then () else ensure_func_is_defined_or_declared kf_name kf_loc in
            let _ = defined_funcs := IdSet.add kf_name !defined_funcs in
            let _ = new_block_ctx (BlockKind_Fun kf_name) sc kloc in
            let (args, rt, is_nothrow, cf) = match (cinfo_ kf_name kf_loc) with
                | CFun ({contents={cf_args; cf_flags; cf_rt}} as cf) ->
                    let is_nothrow = List.mem FunNoThrow cf_flags in
                    (cf_args, cf_rt, is_nothrow, cf)
                | _ -> raise_compile_err kf_loc "cgen: the function declaration was not properly converted"
                in
            let (real_args, retid, _, _) = unpack_fun_args args rt is_nothrow in
            let nreal_args = List.length real_args in
            (* in the list of parameters the return value (if any) can be the last one
               (in the case of no-throw functions) or pre-last one
               (in the case of functions that may throw exceptions)
            *)
            let new_body = (match (kf_body, ctor) with
                (* C function *)
                | (KExpCCode(code, (_, loc)), CtorNone) -> CExp (CExpCCode(code, loc)) :: []
                (* generic function *)
                | (_, CtorNone) ->
                    let dstexp_r = ref (if retid = noid then None else
                        (Some (cexp_deref (make_id_exp retid kf_loc))))
                        in
                    let orig_status_id = gen_temp_idc "fx_status" in
                    let (status_exp, ccode) = create_cdefval orig_status_id CTypCInt [ValMutable] "fx_status"
                        (Some (make_int_exp 0 kf_loc)) [] kf_scope kf_loc in
                    let status_id = if is_nothrow then noid else orig_status_id in
                    (*let _ = printf "converting function %s:\n" kf_cname in*)
                    let _ = List.iter (fun (a, t, flags) ->
                        if not (List.mem CArgPassByPtr flags) then () else
                            i2e := Env.add a (cexp_deref (make_id_exp a kf_loc)) !i2e) real_args
                        in
                    let ccode = if kci_arg = noid then ccode else
                        let fcv_ptr_ctyp = make_ptr (CTypName kci_fcv_t) in
                        let fcv_arg_exp0 = make_id_t_exp (get_id "fx_fv") std_CTypVoidPtr kf_loc in
                        let cast_ptr = CExpCast(fcv_arg_exp0, fcv_ptr_ctyp, kf_loc) in
                        let (_, ccode) = create_cdefval kci_arg fcv_ptr_ctyp [] ""
                            (Some cast_ptr) ccode kf_scope kf_loc in
                        ccode
                        in
                    let (ret_e, ccode) = kexp2cexp kf_body dstexp_r ccode kf_scope in
                    let end_loc = get_kexp_end kf_body in
                    let bctx = curr_block_ctx end_loc in
                    (* exclude FX_CHECK_EXN() if it's in the very end of function *)
                    let ccode = match ccode with
                        | CExp (CExpCall(CExpIdent (f, _), _, _)) :: rest when f = !std_FX_CHECK_EXN ->
                            bctx.bctx_label_used <- bctx.bctx_label_used - 1; rest
                        | _ -> ccode
                        in
                    let {bctx_label; bctx_prologue; bctx_cleanup; bctx_label_used} = bctx in
                    let ccode = if bctx_label_used > 0 then
                        CStmtLabel(bctx_label, end_loc) :: ccode else ccode in
                    let (ret_e, ccode) =
                        if bctx_cleanup = [] then
                            (ret_e, ccode)
                        else
                            let (ret_e, ccode) =
                                if retid <> noid || status_id <> noid || (Utils.is_some !dstexp_r) then
                                    (ret_e, ccode)
                                else
                                    (match ret_e with
                                    | CExpInit([], _) | CExpLit _ | CExpIdent _ -> (ret_e, ccode)
                                    | _ ->
                                        create_cdefval (gen_temp_idc "result") (get_cexp_typ ret_e)
                                                        [] "" (Some ret_e) ccode kf_scope end_loc)
                            in
                                (ret_e, (bctx_cleanup @ ccode))
                        in
                    let ccode = if status_id <> noid then
                            CStmtReturn ((Some status_exp), end_loc) :: ccode
                        else if rt = CTypVoid then ccode
                        else CStmtReturn ((Some ret_e), end_loc) :: ccode
                        in
                    (List.rev bctx_prologue) @ (List.rev ccode)
                (* recursive or non-recursive variant constructor *)
                | (_, CtorVariant(tag_value)) ->
                    let (have_tag, is_recursive_variant) = match kf_rt with
                        | KTypName vn ->
                            (match (kinfo_ vn kf_loc) with
                            | KVariant {contents={kvar_flags}} ->
                                let have_tag = not (List.mem VariantNoTag kvar_flags) in
                                let is_recursive = List.mem VariantRecursive kvar_flags in
                                (have_tag, is_recursive)
                            | _ -> raise_compile_err kf_loc
                                (sprintf "cgen: the return type of variant constructor %s is not variant" (id2str kf_name)))
                        | _ -> raise_compile_err kf_loc
                            (sprintf "cgen: the return type of variant constructor %s is not variant" (id2str kf_name))
                        in
                    let var_exp = (make_id_exp retid kf_loc) in
                    let result_ctyp = C_gen_types.ktyp2ctyp kf_rt kf_loc in
                    let (var_exp, ccode, ret_ccode) =
                        if is_recursive_variant then
                            let alloc_var = make_call !std_FX_MAKE_RECURSIVE_VARIANT_IMPL_START
                                [CExpTyp(result_ctyp, kf_loc)] CTypVoid kf_loc in
                            let (var_exp, _) = create_cdefval (gen_temp_idc "v") result_ctyp
                                    [ValMutable] "v" None [] kf_scope kf_loc in
                            let ret_ccode = [CStmtReturn (Some (make_int_exp 0 kf_loc), kf_loc)] in
                            (var_exp, [CExp alloc_var], ret_ccode)
                        else
                            (var_exp, [], [])
                        in
                    let init_tag = make_assign (cexp_arrow var_exp (get_id "tag") CTypInt)
                        (make_id_t_exp tag_value CTypCInt kloc) in
                    let ccode = if have_tag then (CExp init_tag) :: ccode else ccode in
                    let dst_base = cexp_arrow var_exp (get_id "u") CTypAny in
                    let dst_base = cexp_mem dst_base (get_orig_id kf_name) CTypAny in
                    let (_, ccode) = List.fold_left (fun (idx, ccode) (a, t, flags) ->
                        let src_exp = make_id_t_exp a t kf_loc in
                        let (src_exp, t) = maybe_deref_fun_arg idx src_exp t flags kf_loc in
                        let dst_exp = dst_base in
                        let dst_exp = if nreal_args = 1 then dst_exp else
                            let tup_elem = get_id ("t" ^ (string_of_int idx)) in
                            (cexp_mem dst_exp tup_elem t)
                            in
                        let ccode = C_gen_types.gen_copy_code src_exp dst_exp t ccode kf_loc in
                        (idx+1, ccode)) (0, ccode) real_args
                    in
                    List.rev (ret_ccode @ ccode)
                (* function pointer/closure constructor *)
                | (_, CtorFP(f_id)) ->
                    let fcv_t_id = match (kinfo_ f_id kf_loc) with
                        | KFun {contents={kf_closure={kci_fcv_t}}} -> kci_fcv_t
                        | _ -> raise_compile_err kf_loc
                            (sprintf "cgen: '%s' is not a function" (get_idk_cname f_id kf_loc))
                        in
                    let fcv_t = CTypName fcv_t_id in
                    let free_f_exp = match (C_gen_types.get_free_f fcv_t true false kf_loc) with
                        | (_, (Some free_f)) -> free_f
                        | _ -> raise_compile_err kf_loc
                            (sprintf "cgen: missing destructor for closure vars '%s'"
                            (get_idk_cname fcv_t_id kf_loc))
                        in
                    let alloc_fcv = make_call !std_FX_MAKE_FP_IMPL_START
                        [CExpTyp(fcv_t, kf_loc); free_f_exp;
                        make_id_t_exp f_id std_CTypVoidPtr kloc] CTypVoid kf_loc
                        in
                    let (fcv_exp, _) = create_cdefval (gen_temp_idc "fcv") (make_ptr fcv_t)
                        [] "fcv" None [] kf_scope kf_loc in
                    let ret_ccode = [CStmtReturn (Some (make_int_exp 0 kf_loc), kf_loc)] in
                    let ccode = [CExp alloc_fcv] in
                    let (_, ccode) = List.fold_left (fun (idx, ccode) (a, t, flags) ->
                        let src_exp = make_id_t_exp a t kf_loc in
                        let (src_exp, t) = maybe_deref_fun_arg idx src_exp t flags kf_loc in
                        let fcv_elem = get_id ("t" ^ (string_of_int idx)) in
                        let dst_exp = (cexp_arrow fcv_exp fcv_elem t) in
                        let ccode = C_gen_types.gen_copy_code src_exp dst_exp t ccode kf_loc in
                        (idx+1, ccode)) (0, ccode) real_args
                    in
                    List.rev (ret_ccode @ ccode)
                | (_, CtorExn(exn_id)) ->
                    let (exn_typ, exn_tag, exn_std, exn_data_id, exn_info) = match (cinfo_ exn_id kf_loc) with
                        | CExn {contents={cexn_typ; cexn_tag; cexn_std; cexn_data; cexn_info}} ->
                            (cexn_typ, cexn_tag, cexn_std, cexn_data, cexn_info)
                        | _ -> raise_compile_err kf_loc (sprintf
                            "cgen: constructor of exception '%s' is expecting converted KExn=>CExn structure"
                            (idk2str exn_id kf_loc))
                        in
                    if exn_std then
                        ccode
                    else
                        let exn_data_t = CTypName(exn_data_id) in
                        let alloc_exn_data = make_call !std_FX_MAKE_EXN_IMPL_START
                            [(make_id_t_exp exn_tag CTypCInt kf_loc);
                            CExpTyp(exn_data_t, kf_loc);
                            (make_id_t_exp exn_info !std_fx_exn_info_t kf_loc)]
                            CTypVoid kf_loc
                            in
                        let ret_ccode = [CStmtReturn (Some (make_int_exp 0 kf_loc), kf_loc)] in
                        let exn_data = make_id_t_exp (get_id "exn_data") (make_ptr exn_data_t) kf_loc in
                        let dst_exp = cexp_arrow exn_data (get_id "data") exn_typ in
                        let ccode = [CExp alloc_exn_data] in
                        let (_, ccode) = List.fold_left (fun (idx, ccode) (a, t, flags) ->
                            let src_exp = make_id_t_exp a t kf_loc in
                            let (src_exp, t) = maybe_deref_fun_arg idx src_exp t flags kf_loc in
                            let dst_exp = if nreal_args = 1 then dst_exp else
                                let t_elem = get_id ("t" ^ (string_of_int idx)) in
                                (cexp_mem dst_exp t_elem t)
                                in
                            let ccode = C_gen_types.gen_copy_code src_exp dst_exp t ccode kf_loc in
                            (idx+1, ccode)) (0, ccode) real_args
                        in
                        List.rev (ret_ccode @ ccode)
                | _ -> raise_compile_err kloc (sprintf "cgen: unsupported type of constructor %s: %s"
                        kf_cname (ctor2str ctor)))
                in
            pop_block_ctx kloc;
            cf := {!cf with cf_body = (filter_out_nops new_body)};
            (false, dummy_exp, ccode)
        | KDefExn ke -> (* handled in c_gen_fdecls *)
            (false, dummy_exp, ccode)
        | KDefVariant kvar -> (false, dummy_exp, ccode) (* handled in c_gen_types *)
        | KDefTyp kt -> (false, dummy_exp, ccode) (* handled in c_gen_types *)
        | KDefClosureVars kcv -> (false, dummy_exp, ccode) (* handled in c_gen_fdecls *)
        in
        if not assign || ctyp = CTypVoid then
            (result_exp, ccode)
        else match !dstexp_r with
        | Some (dst_exp) ->
            let skip_copy = (match result_exp with
            | CExpLit(LitNil, _) ->
                let {ctp_ptr} = C_gen_types.get_ctprops ctyp kloc in ctp_ptr
            | _ -> false) in
            let ccode = if skip_copy then ccode else
                C_gen_types.gen_copy_code result_exp dst_exp ctyp ccode kloc
            in
            (dst_exp, ccode)
        | _ -> (result_exp, ccode)
    in
    (* ok, here is the top-level C code generation procedure *)

    (* 1. convert all types to C *)
    let c_types_ccode = C_gen_types.convert_all_typs top_code in

    (* 3. convert function declarations to C *)
    let (c_fdecls, mod_init_calls) = C_gen_fdecls.convert_all_fdecls top_code in
    (*let _ = C_pp.pprint_top (c_types_ccode @ c_fdecls) in*)

    (* 4. all the global code should be put into fx_toplevel() function. Let's form its body,
          starting with the classical `int fx_status = 0;` *)
    let sc0 = ScGlobal::[] in
    let start_loc = if top_code = [] then noloc else get_kexp_loc(List.hd top_code) in
    let _ = new_block_ctx BlockKind_Global sc0 start_loc in
    let (status_exp, ccode) = create_cdefval (gen_temp_idc "fx_status") CTypCInt
        [ValMutable] "fx_status" (Some (make_int_exp 0 start_loc)) [] sc0 start_loc in
    (* 5. convert all the code to C. It will automatically update functions bodies *)
    let (e, ccode) = kexp2cexp (code2kexp top_code start_loc) (ref None) ccode sc0 in
    (*let e = make_dummy_exp start_loc in*)
    let end_loc = get_cexp_loc e in

    (* 6. bctx_prologue will contain all the global definitions.
          bctx_cleanup will contain destructor calls for all the global definitions.
          Need to add it to end of fx_toplevel() and
          form its body
    *)
    let {bctx_prologue; bctx_label; bctx_cleanup; bctx_label_used} = curr_block_ctx end_loc in
    let (global_prologue, temp_toplevel_vals) = List.fold_left (fun (global_prologue, temp_toplevel_vals) s ->
        let is_global = match s with
            | CDefVal (_, i, _, loc) ->
                (match (cinfo_ i loc) with
                | CVal {cv_flags} -> not ((List.mem ValTemp cv_flags) || (List.mem ValTempRef cv_flags))
                | _ -> true)
            | _ -> true
            in
        if is_global then
            (s :: global_prologue, temp_toplevel_vals)
        else
            (global_prologue, s :: temp_toplevel_vals))
        ([], []) bctx_prologue in
    let _ = pop_block_ctx end_loc in
    let ccode = (cexp2stmt e) :: ccode in
    let ccode = if bctx_label_used = 0 then ccode else (CStmtLabel(bctx_label, end_loc)) :: ccode in
    let ccode = filter_out_nops (bctx_cleanup @ ccode) in
    let ccode = CStmtReturn ((Some status_exp), end_loc) :: ccode in
    let toplevel_cname = "fx_toplevel" in
    let toplevel_name = (gen_temp_idc toplevel_cname) in
    let toplevel_f = ref {cf_name=toplevel_name; cf_args=[]; cf_rt=CTypCInt;
        cf_cname=toplevel_cname; cf_body=temp_toplevel_vals @ mod_init_calls @ (List.rev ccode);
        cf_flags=[]; cf_scope=sc0; cf_loc=end_loc} in
    let _ = set_idc_entry toplevel_name (CFun toplevel_f) in
    let all_ccode = (make_ccode_prologue start_loc) @ (List.rev !top_ccode) @
        c_types_ccode @ global_prologue @ (List.rev !fwd_fdecls) @ c_fdecls @
        [CDefFun toplevel_f] @ (make_ccode_epilogue end_loc) in
    all_ccode
