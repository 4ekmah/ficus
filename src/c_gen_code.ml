(*
    This file is a part of ficus language project.
    See ficus/LICENSE for the licensing terms
*)

(*
    Converts K-form into C-form (see c_form.ml).
    We assume that K-form has been prepared for the conversion,
    i.e. lambda lifting has been performed, all the complex
    data structures, such as records, tuple, lists etc. have
    been converted to KTypName(...) etc.

    The algorithm:
        1. do the 1st pass through the K-form, convert all the types and exceptions (see c_gen_types.ml).
        2. do the 2nd pass through the K-form, generate headers for all the functions.
            - each function gets extra "free variables"/"closure data" parameter fx_fv, even if it's not used.
            - the return value becomes the output parameter fx_result (before the closure pointer).
            - the function gets "int" return value, the status.
        3. do the 3rd pass through the K-form:
            - convert body of each function to C-form
            - put all the global calculations to a dedicated function _fx_init();
              all the intermediate values, used at the global scope, are moved to this function as well.
            - put all the global c-code fragments into a separate code sequence.
        4. output the final C code as concatenation of the following parts (in this particular order):
            - preamble (some general comment about autogenerated file + #include "ficus/ficus.h")
            - all the global c code
            - forward declarations of some types and their destructors
            - declarations of all the types and their helper functions (constructors, destructors, copy operators)
            - declarations of all the exceptions and their constructors
            - declarations of the global variables together with their default initializers.
            - forward declarations of some functions
            - declarations and definitions of all the functions
            - the function "int _fx_init(void) {...}"
            _ the function main() that initializes runtime, calls _fx_init() and returns its value.

    The transformed K-form as a recursive tree of expressions. So the basic element, workhorse
    of the conversion algorithm is the function to convert K expression to C code.

    We maintain and recursively pass the following compiler state:
    - C code generated so far. Just like in k_normalize.ml, this is the reverse list of c statements.
      We add new elements to the beginning of it and then reverse the produced list in the end.
    - The "catch" label stack. In the beginning of new function we push the default "cleanup" label
      for that function and pop in the end. We also push-pop a new label when we translate
      try {} catch {} block. In principle, we can use dedicated catch labels in some other nested statements,
      like for(), if() etc. For simplicity we do not do that, at the expense of slightly higher
      overhead imposed by the single big cleanup section per function. After we employ the inline function
      call optimization, the relative overhead of the cleanup sections should decrease.
      In the catch blocks we jump to the underlying label in the stack,
      thus providing the exception propagation mechanism.
    - the map of id->cexp_t pairs. It does not make sense to represent all the values in K form as C variables.
      If the value (id) is:
      1. used just once
      2. immutable (val, not var)
      3. a result of expression, which operands are also values
      then the id can be just replaced with the expression in C-form.
    - the name of currently processed function (noid in the case of global/module scope expressions).
      First of all, it helps us to detect and efficiently translate the recursive calls of the function itself:

      int _fx_foo(...args..., void* fx_fv) {... _fx_foo(...new_args..., fx_fv); } // just pass fx_fv directly

      It also lets us to distinguish between 2 cases: global and non-global. We need to handle
      KDefVal() differently, depending on the context.
    - id of the value to store the result at, or noid.
        - when the translated kexp_t has type KTypVoid, no output value is needed.
        - in some other cases, there is no pre-defined id.
          Then we need to generate a new temporary id and store the result there.
          Or even postpone the temporary value assignment and put the pair (id, cexp) to the map.
        - in some cases we are given the pre-defined id.
        - For example, the function body expression result should be stored in fx_result.
        - When we have K-form code "var x=val0; ... x=new_val;", new_val should be stored in x,
          no need to generate a temporary value, because we want to avoid unnecessary data copying.
        - "record.f = new_val", "arr[idx] += newval" etc. are other such cases. In those cases we
          use a TEMP_REF val that is the pointer to the proper record field or array element.
          However, in those cases we will try to generate idiomatic C code, e.g. "record.f = new_val",
          not the direct replication of K-form: "sometype* pf /* TEMP_REF */ = &record.f; *pf = new_val"
*)
open Ast
open K_form
open C_form

let make_label basename sc loc =
    let li = gen_temp_idc basename in
    let cname = if basename = "cleanup" then "_fx_cleanup"
        else (sprintf "_fx_%s%d" basename (id2idx li)) in
    set_idc_entry li (CLabel {cl_name=li; cl_cname=cname; cl_scope=sc; cl_loc=loc});
    li

(* Finds a set of immutable values that can potentially be replaced
   with the expressions that they are initalized with, e.g.

   val b = a + 1; foo(b)
   can be replaced with foo(a+1).

   Here we find a superset of such values, i.e. a set of values
   that are pure expressions and used just once.
   If a value is used more than once, it makes
   sense to store it in a temporary variable.

   Later on we shrink this superset. We check that their initialization
   expressions can be represented as scalar C expressions.
   This is a recursive rule that cannot be checked at this stage.
*)
let find_single_use_vals topcode =
    (let count_map = ref (Env.empty: int env_t) in
    let decl_const_vals = ref (IdSet.empty) in
    let rec count_atom a loc callb =
        match a with
        | Atom.Id i ->
            if IdSet.mem i !decl_const_vals then
                let n = match (Env.find_opt i !count_map) with
                    | Some(n) -> n
                    | _ -> 0
                in count_map := Env.add i (n+1) !count_map
            else ()
        | _ -> ()
    and count_ktyp t loc callb = ()
    and count_kexp e callb =
        (* we put to decl_const_vals only the values declared with
           "val" operator, which means they are declared by
           user or are temporary intermediate values.
           we do not put there function parameters and
           loop counters, because they cannot be replaced with
           any expressions. They themselves are expressions.
        *)
        match e with
        | KDefVal(k, e1, loc) ->
            if K_deadcode_elim.pure_kexp e1 then
                decl_const_vals := IdSet.add k !decl_const_val
            else ();
            count_kexp e1 callb
        | _ -> fold_kexp e callb
    in count_callb =
    {
        kcb_fold_typ=Some(count_ktyp);
        kcb_fold_exp=Some(count_kexp);
        kcb_fold_atom=Some(count_atom);
        kcb_result=0
    } in
    List.iter (fun e -> count_kexp e) topcode;
    IdSet.filter (fun i -> match (Env.find_opt i !count_map) with Some 1 -> true | _ -> false) !decl_const_vals)

type block_kind_t = BlockKind_Global | BlockKind_Fun | BlockKind_Try | BlockKind_Loop | BlockKind_General

type block_ctx_t =
{
    bctx_kind: block_kind_t;
    bctx_scope: scope_t list;
    bctx_label: id_t;
    mutable bctx_prologue: cstmt_t list;
    mutable bctx_cleanup: cstmt_t list;
    mutable bctx_break_used: int;
    mutable bctx_continue_used: int;
    mutable bctx_label_used: int;
}

let gen_ccode topcode =
    let i2e = ref (Env.empty: cexp_t env_t) in
    let u1vals = find_single_use_vals topcode in
    let block_stack = ref ([]: block_ctx_t list) in
    let curr_fun = ref noid in

    let check_inside_loop is_break loc =
        let rec check_inside_loop_ s =
            match s with
            | ({bctx_kind=BlockKind_Loop;} as top) :: _ ->
                if is_break then
                    top.bctx_break_used <- top.bctx_break_used + 1
                else
                    top.bctx_continue_used <- top.bctx_continue_used + 1
            | {bctx_kind=BlockKind_General} :: _
            | {bctx_kind=BlockKind_Fun} :: _ ->
                raise_compile_err loc
                    (sprintf "'%s' is used outside of a loop" (if is_break then "break" else "continue"))
            | _ :: rest -> check_inside_for rest
        in check_inside_loop_ !block_stack
    in

    let curr_block_ctx loc = match !block_stack with
        | top :: _ -> top
        | _ -> raise_compile_err loc "cgen: empty block stack!"
    in

    let push_block_ctx kind sc loc =
        let l_basename = match kind with
            | BlockKind_Global | BlockKind_Fun -> "cleanup"
            | _ -> "catch" in
        let l = make_label l_basename sc loc in
        let bctx = {bctx_kind = kind; bctx_scope=sc; bctx_label=l;
                    bctx_prologue=[]; bctx_cleanup=[];
                    bctx_break_used=0; bctx_continue_used=0;
                    bctx_label_used=0} in
        block_stack := bctx :: !block_stack
    in

    let pop_block_ctx loc =
        match !block_stack with
        | _ :: rest -> block_stack := rest
        | _ -> raise_compile_err loc "cgen: empty block stack!"

    let curr_block_label loc =
        let bctx = curr_block_ctx loc in
        bctx.bctx_label_used <- bctx.bctx_label_used + 1;
        make_id_exp bctx.bctx_label loc
    in

    let parent_block_label loc = match !block_stack with
        | _ :: parent :: _ ->
            parent.bctx_label_used <- parent.bctx_label_used + 1;
            made_id_exp parent.bctx_label loc
        | _ ->
            raise_compile_err loc "cgen internal err: there is no parent block!"
    in

    let add_fx_call call_exp ccode loc =
        let l = curr_block_label loc in
        let fx_call_e = make_call !std_FX_CALL (call_exp :: l :: []) CTypVoid loc in
        (CExp fx_call_e) :: ccode
    in

    let add_val i ctyp flags init sc loc =
        let bctx = curr_block_ctx loc in
        let {ctp_ptr; ctp_free=(freem,freef)} = get_ctprops ctyp loc in
        let e0 = if ctp_ptr then CExpLit(LitNil, (ctyp, loc)) else CExpStructInit([], (ctyp, loc)) in
        let i_exp = make_id_exp i loc in
        if init then bctx.bctx_prologue <- create_cdefval i ctyp flags (Some e0) bctx.bctx_prologue sc loc else ();
        bctx.bctx_cleanup <- C_gen_types.gen_free_code i_exp ctyp true true bctx.bctx_cleanup loc;
        i_exp
    in

    let get_dstexp dstexp_r prefix ctyp flags init sc loc =
        match !dstexp_r with
        | Some(dstexp) -> dstexp
        | _ ->
            let i = gen_temp_idc prefix in
            let i_exp = add_val i ctyp flags init sc loc in
            (dstid_r := (Some i_exp); i_exp)
    in

    let get_struct c_e =
        let (ctyp, cloc) = get_cexp_ctx c_e in
        let rec try_deref c_e ctyp =
            match ctyp with
            | CTypRawPtr(_, ctyp1) -> try_deref (cexp_deref c_e) ctyp1
            | _ ->
                (match ctyp with
                | CTypName tn ->
                    (match (cinfo_ tn cloc) with
                    | CTyp {contents={ct_typ=CTypStruct(_, relems)}} ->
                        (c_e, relems)
                    | CTyp {contents={ct_typ=CTypRawPtr(_, CTypStruct(_, relems))}} ->
                        ((cexp_deref ce), relems)
                    | _ -> raise_compile_err cloc
                        (sprintf "the type '%s' is not a structure" (get_idc_cname tn cloc)))
                | CTypStruct(_, relems) -> (ce, relems)
                | _ -> raise_compile_err cloc "a structure is expected here")
        in try_deref c_e ctyp
    in

    let gen_break_continue_stmt is_break loc =
        let _ = check_inside_loop is_break loc in
        let f = if is_break then !std_FX_BREAK else !std_FX_CONTINUE in
        let l = curr_block_label loc in
        CExp (make_call f (l::[]) CTypVoid loc)
    in

    let finalize_loop_body body_code loc =
        let bctx = curr_block_ctx loc in
        let {bctx_prologue; bctx_cleanup;
            bctx_break_used;bctx_continue_used;
            bctx_label_used} = bctx in
        let epilogue =
            if bctx_label_used = 0 then
                bctx_cleanup
            else
                let parent_label_exp = parent_block_label loc in
                let catch_m = if bctx_break_used + bctx_continue_used > 0 then
                    !std_FX_LOOP_CATCH_BREAK_CONTINUE else !std_FX_LOOP_CATCH in
                let handle_exn = make_call catch_m (parent_label_exp::[]) CTypVoid kloc in
                (CExp handle_exn) :: bctx_cleanup
            in
        let body_code = epilogue @ body_code @ bctx_prologue in
        let body_stmt = rccode2stmt body_code loc in
        pop_block_ctx loc; body_stmt
    in

    (*
        cases:
           - input kexp is void:
                no expression should be stored anywhere,
                just need to update ccode and return "nop"
           - non-void expression,
                the result should be stored to some pre-defined value (dstid).
                returns this CExpIdent(dstid)
           - non-void expression (dstid=noid),
                the result should be returned as expression
                if needed, some temporary id is generated where the result is stored.
    *)
    let rec kexp2cexp kexp dstexp_r ccode sc =
        let fname = match sc with ScFun f :: _ -> f | _ -> noid in
        let (ktyp, kloc) = get_kexp_ctx kexp in
        let ctyp = C_gen_types.ktyp2ctyp ktyp kloc in
        let dummy_exp = CExpStructInit([], (CTypVoid, kloc)) in
        let is_dummy_exp e = match e with CExpStructInit([], (CTypVoid, _)) -> true | _ -> false in

        (* generate exp and then optionally generate the assignment if needed *)
        let (assign, cexp, ccode) = match kexp with
        | KExpNop _ -> (false, dummy_exp, ccode)
        | KExpBreak _ ->
            let break_stmt = gen_break_continue_stmt true kloc in
            (false, dummy_exp, break_stmt :: ccode)
        | KExpContinue _ ->
            let continue_stmt = gen_break_continue_stmt false kloc in
            (false, dummy_exp, continue_stmt :: ccode)
        | KExpAtom(a, _) ->
            (match a with
            | Atom.Lit(l) ->
                (match l with
                | LitString _ ->
                    (* since FX_MAKE_STR(<string_literal>) creates a string with NULL reference counter and
                       without allocating string in memory heap, there is no need to call destructor for it *)
                    let e0 = make_call !std_FX_MAKE_STR ((make_lit_exp l kloc) :: []) CTypString kloc in
                    let i = gen_temp_idc "slit" in
                    let ccode = create_cdefval i CTypString [] (Some e0) ccode sc kloc in
                    (true, (make_id_exp i kloc), ccode)
                | _ ->
                    let e = make_lit_exp l kloc in (true, e, ccode))
            | Atom.Id(i) ->
                (true, (match (Env.find_opt i !i2e) with
                | Some(e) -> e
                | _ ->
                    let e = make_id_exp i kloc in
                    let add_deref = match cinfo_ i kloc with
                    | CDefVal {cv_typ} ->
                        (match cv_typ with
                        | CTypRawPtr(_, ctyp2) when ctyp2 = ctyp -> true
                        | _ -> false)
                    | _ -> false
                    in
                    if add_deref then cexp_deref e else e), ccode)
            )
        | KExpBinOp(bop, e1, e2, _) ->
            let (ce1, ccode) = kexp2cexp e1 (ref None) ccode sc in
            let (ce2, ccode) = kexp2cexp e2 (ref None) ccode sc in
            (match bop with
            | OpLogicAnd | OpLogicOr ->
                raise_compile_err kloc "cgen: unexpected operation"
            | OpPow ->
                let (need_cast, ce1, ce2, rtyp, f) = match ctyp with
                    | CTypFloat(32) -> (false, ce1, ce2, ctyp, get_id "powf")
                    | CTypFloat(64) -> (false, ce1, ce2, ctyp, get_id "pow")
                    | _ ->
                        let ce1 = CExpCast(ce1, (CTypFloat 64), kloc) in
                        let ce2 = CExpCast(ce2, (CTypFloat 64), kloc) in
                        (true, ce1, ce2, (CTypFloat 64), get_id "pow") in
                let e = make_call f (ce1 :: ce2 :: []) rtyp kloc in
                let e = if need_cast then CExpCast(e, ctyp, kloc) else e in
                (true, e, ccode)
            | OpCons ->
                (*
                    l = e1 :: e2;
                    if !dstexp_r == None && (e2 is single-use id from u1vals) && (ce2 is id) then
                        re-use ce2 as l
                    else
                        obtain l using get_dstexp.
                *)
                let e2_id = match e2 with KExpAtom(Atom.Id i, _) when IdSet.mem i u1vals -> i | _ -> noid in
                let ce2_id = match ce2 with CExpIdent(i, _) -> i | _ -> noid in
                let (reuse_ce2, l_exp) = (Utils.is_none !dstexp_r) && e2_id <> noid && ce2_id <> noid then
                        (true, ce2_id)
                    else (false, (get_dstexp dstexp_r "lst" ctyp [] true sc kloc)) in
                let lcon = C_gen_types.get_constructor ctyp true kloc in
                let call_cons = make_call lcon
                    (ce1 :: ce2 :: (make_lit_exp (LitBool (not reuse_ce2)) kloc) ::
                    (cexp_get_addr l_exp) :: []) CTypCInt kloc in
                (false, l_exp, (add_fx_call call_cons ccode kloc))
            | _ ->
                let c_bop = match bop with
                    | OpAdd -> COpAdd
                    | OpSub -> COpSub
                    | OpMul -> COpMul
                    | OpDiv -> COpDiv
                    | OpMod -> COpMod
                    | OpShiftLeft -> COpShiftLeft
                    | OpShiftRight -> COpShiftRight
                    | OpBitwiseAnd -> COpBitwiseAnd
                    | OpBitwiseOr -> COpBitwiseOr
                    | OpBitwiseXor -> COpBitwiseXor
                    | OpCompareEQ -> COpCompareEQ
                    | OpCompareNE -> COpCompareNE
                    | OpCompareLT -> COpCompareLT
                    | OpCompareLE -> COpCompareLE
                    | OpCompareGT -> COpCompareGT
                    | OpCompareGE -> COpCompareGE
                    | _ -> raise_compile_err kloc (sprintf "cgen: unsupported op '%s'" (binop_to_string bop))
                in (true, CExpBinOp(c_bop, ce1, ce2, (ctyp, kloc)), ccode))
        | KExpUnOp(OpMkRef, e1, _) ->
            let (ce1, ccode) = kexp2cexp e1 (ref None) ccode sc in
            let r_exp = get_dstexp dstexp_r "r" ctyp [] true sc kloc in
            let rcon = C_gen_types.get_constructor ctyp true kloc in
            let call_mkref = make_call rcon
                (ce1 :: (cexp_get_addr r_exp) :: []) CTypCInt kloc in
            (false, r_exp, (add_fx_call call_mkref ccode kloc))
        | KExpUnOp(OpDeref, e1, _) ->
            let (ce1, ccode) = kexp2cexp e1 (ref None) ccode sc in
            (true, (cexp_deref ce1), ccode)
        | KExpUnOp(uop, e1, _) ->
            let (ce1, ccode) = kexp2cexp e1 (ref None) ccode sc in
            let c_uop = match uop with
                | OpPlus -> COpPlus
                | OpNegate -> COpNegate
                | OpBitwiseNot -> COpBitwiseNot
                | OpLogicNot -> COpLogicNot
                | OpExpand -> raise_compile_err kloc "cgen: unsupported op 'expand'"
            in (true, CExpUnOp(c_uop, ce1, (ctyp, kloc)), ccode)
        | KExpIntrin(intr, args, _) ->
            (match (intr, args) with
            | (IntrinVariantTag, v :: []) ->
                let cv = kexp2cexp last (ref None) ccode sc in
                let {ktp_ptr} = get_ktprops (get_kexp_typ v) kloc in
                let ctag = if ktp_ptr then
                        cexp_arrow cv (get_id "tag") CTypCInt
                    else
                        cexp_mem cv (get_id "tag") CTypCInt in
                (true, ctag, ccode)
            | (IntrinVariantCase, v :: (KExpAtom((Atom.Id vn), _)) :: []) ->
                let cv = kexp2cexp last (ref None) ccode sc in
                let {ktp_ptr} = get_ktprops (get_kexp_typ v) kloc in
                let cvu = if ktp_ptr then
                        cexp_arrow cv (get_id "u") CTypAny
                    else
                        cexp_mem cv (get_id "u") CTypAny in
                let celem = cexp_mem cvu (get_orig_id vn) ctyp in
                (true, celem, ccode)
            | (IntrinListHead, l :: []) ->
                let (cl, ccode) = kexp2cexp l (ref None) ccode sc in
                (true, (cexp_arrow cl (get_id "hd") ctyp), ccode)
            | (IntrinListTail, l :: []) ->
                let (cl, ccode) = kexp2cexp l (ref None) ccode sc in
                (true, (cexp_arrow cl (get_id "hd") ctyp), ccode)
            | _ -> raise_compile_err kloc "cgen: unsupported KExpIntrin")
        | KExpSeq(el, _) ->
            let rec process_seq el ccode = match el with
                | [] -> (dummy_exp, ccode)
                | last :: [] -> kexp2cexp last dstid_r ccode sc
                | e :: rest ->
                    let (_, ccode) = kexp2cexp e (ref None) ccode sc in
                    process_seq rest ccode
            in let (e, ccode) = process_seq el ccode in
            (false, e, ccode)
        | KExpIf(c, e1, e2, _) -> raise_compile_err kloc "cgen: unsupported KExpIf"
            let (cc, ccode) = kexp2cexp c (ref None) ccode sc in
            let dstexp = get_dstexp dstexp_r "t" ctyp [] true sc kloc in
            let (c_e1, ccode1) = kexp2cexp e1 dstid_r [] sc in
            let (c_e2, ccode2) = kexp2cexp e2 dstid_r [] sc in
            let c_e1 = rccode2stmt ((cexp2stmt c_e1) :: ccode1) (get_kexp_loc e1) in
            let c_e2 = rccode2stmt ((cexp2stmt c_e2) :: ccode2) (get_kexp_loc e2) in
            (false, dstexp, (CStmtIf(cc, c_e1, c_e2, kloc)) :: ccode)
        | KExpCall(f, args, _) -> raise_compile_err kloc "cgen: unsupported KExpCall"
            (*
                generate the call; if the function returns the result via output parameter
                (for now we do not support "nothrow" functions properly, so this always be the case),
                we pass pointer to dstid as the output parameter. If dstid=noid and the function is non-void,
                we generate temporary id. Let's call it dstid' (=dstid if dstid!=noid, some_temp_id overwise).
                The result will look like: FX_CALL(f(args, &dstid', fv_data))
                Return dstid' as the result.
                If f is a known function, just call it and pass fv_data=0. If it's function closure,
                call it via pointer and provide the stored in closure fv_data:
                FX_CALL(f.ptr(args, &dstid', f.fv_data));
                if f is "void" function (can only be in th case of known nothrow function, e.g. destructor),
                FX_CALL is not needed.

                Need to look at each argument and optionally add '&' or '*' if needed.
            *)
        | KExpMkTuple(args, _) | KExpMkRecord(args, _) ->
            let prefix = match kexp with KExpMkTuple(_, _) -> "tup" | _ -> "rec" in
            let (cargs, ccode) = List.fold_left (fun (cargs, ccode) a ->
                let (ca, ccode) = kexp2cexp a (ref None) ccode sc in
                ((a :: cargs), ccode)) ([], ccode) args in
            let tcon = C_gen_types.get_constructor ctyp true kloc in
            if tcon <> noid then
                let t_exp = get_dstexp dstexp_r prefix ctyp [] true sc kloc in
                let call_mktup = make_call tcon
                    ((List.rev cargs) @ [cexp_get_addr t_exp]) CTypVoid kloc in
                (false, t_exp, call_mktup :: ccode)
            else
                let tup = gen_temp_idc prefix in
                let e0 = CExpStructInit((List.rev cargs), (ctyp, kloc)) in
                let _ = add_val i ctyp flags init sc loc in
                let ccode = create_cdefval tup ctyp [] (Some e0) ccode sc kloc in
                let t_exp = make_id_exp tup kloc in
                (true, t_exp, ccode)
        | KExpMkClosure(f, fcv, args, _) -> raise_compile_err kloc "cgen: unsupported KExpMkClosure"
            (* TBD *)
        | KExpMkArray(shape, elems, _) -> raise_compile_err kloc "cgen: unsupported KExpMkArray"
            (* declare array with initializer expressions.
               [TODO] if array is just an argument to some simple arithmetic operation
               or array comprehension or a pure function, maybe
               we can avoid allocation of the memory on heap and copying data there?
               call fx_make_arrNd(...); *)
        | KExpAt(a, idxs, _) -> raise_compile_err kloc "cgen: unsupported KExpAt"
            (*
                there are 2 major cases:
                1. some of the idxs are ranges. Then the result is fx_arr_t
                2. all the ranges are scalars. Then the result is scalar.

                1. In the first case need to call a special function
                    `FX_CALL(fx_subarr(arr, temp_idx, &dst, kind0, {idx0_data}, kind1, {idx1_data}, ..., -1), catch_label)`.
                    where kind{i} is type of i-th index:
                    =0 scalar index, followed by the index itself
                    =1 normal range [a, b), followed by a and b
                    =2 open range [a,end_of_dim), followed by the a;
                       the whole range is equivalent to [0,end_of_dim)
                    =3 normal range with stride [a..stride..b), followed by a, b and stride
                    =4 open range with stride [a..stride..end_of_dim), followed by a and a and stride
                    -1 end of the range spec; strictly speaking, it's not needed,
                       because we know the dimensionality
                also obtain `dst` using `get_dstexp()`
                and then call
                return `(false, dst, ccode)`.

                2. In the second case need first to process each index idx_k (k=0..dims-1):
                   2.1. If idx_k is "fast index" - great, just use the expression for the index
                        (process it via `kexp2cexp (KExpAtom i) (ref None) ccode sc`)
                   2.2. Otherwise we need to use the index more than once, so we need to
                        store it to temporary variable (unless it's already an indentifier or constant)
                        and add it to the check
                        `if(FX_CHKIDX(arr, k1, idx_k1) || FX_CHKIDX(arr, k2, idx_k2) ...)
                            FX_THROW_OUT_OF_RANGE(catch_label);`
                    if all the indices are fast indices, the check is excluded, of course,
                    otherwise it's added to ccode
                    and we return `(true, FX_PTR_{dims}D(elemtypname, arr, idx0, ..., idx{dims-1}, ccode)`
            *)
        | KExpMem(e1, n, _) ->
            let ce1 = kexp2cexp e1 (ref None) ccode sc in
            let (ce1, relems) = get_struct ce1 in
            let nelems = List.length relems in
            let _ = if n < 0 || n >= nelems then
                raise_compile_err kloc (sprintf "the tuple/record element index %d is out of range [0, %d]" n nelems)
                else () in
            let (n_id, _) = List.nth relems n in
            (true, (cexp_mem ce1 n_id ctyp), ccode)
        | KExpAssign(i, e1, _) -> raise_compile_err kloc "cgen: unsupported KExpAssign"
            (* 1. if needed, call destructor for i.
               2. then call _fx_copy(e1, &i), fx_copy(e1, &i) or simply do assignment i=e1 *)
        | KExpMatch(cases, _) -> raise_compile_err kloc "cgen: unsupported KExpMatch"
            (* very similar to if, just a little bit more complex *)
        | KExpTryCatch(try_e, catch_e, _) -> raise_compile_err kloc "cgen: unsupported KExpCatch"
            (* create new block context, generate temporary value to assign the try result.
               generate code for try_e. then generate code for catch similarly to kexpmatch:

               tvtype try_val = ...;
               try_code;
               try_val = try_code_result;

            try_cleanup:
               ...; // call destructors for complex data structures used in try
               if(fx_status >= 0) goto end_catch;

               int code = fx_status;
               fx_status = FX_OK;
               ... // code to match the exception
               // if not caught
               fx_status = FX_OK; goto next_label_in_stack; // propagate the unhandled exception
            end_catch:
               // here we jump after each successful try or after successful catch.
            *)
        | KExpThrow(i, _) -> raise_compile_err kloc "cgen: unsupported KExpThrow"
            (*
                set the current exception to i, which includes setting fx_status=i.tag;
                then "goto try_cleanup";
            *)
        | KExpCast(e1, kt, _) ->
            let ce1 = kexp2cexp e1 (ref None) ccode sc in
            let ct = C_gen_types.ktyp2ctyp kt kloc in
            (true, CExpCast(ce1, ct, kloc), ccode)
        | KExpMap(e_kdl_l, body, flags, _) -> raise_compile_err kloc "cgen: unsupported KExpMap"
            (*
                TBD
            *)
        | KExpFor(kdl, body, flags, _) -> raise_compile_err kloc "cgen: unsupported KExpFor"
            (*
                TBD
            *)
        | KExpWhile(c, body, _) ->
            let _ = new_block_ctx BlockKind_Loop sc kloc in
            let (cc, cc_code) = kexp2cexp c (ref None) [] sc in
            let (is_for_loop, check_code) =
                match (cc, cc_code) with
                | (CExp(CExpLit(LitBool(true), _)), []) -> (true, [])
                | (_, []) -> (false, [])
                | _ ->
                    let cc_loc = get_cexp_loc cc in
                    let not_cc = CExpUnOp(COpLogicNot, cc, (CTypBool, cc_loc)) in
                    let break_stmt = gen_break_continue_stmt cc_loc in
                    let check_cc = CStmtIf(not_cc, break_stmt, CStmtNop(cc_loc), cc_loc) in
                    (true, check_cc :: cc_code)
                in
            let (e, body_code) = kexp2cexp body (ref None) [] sc in
            let body_code = ((CExp e) :: body_code) @ check_code in
            let body_stmt = finalize_loop_body body_code kloc in
            let loop_stmt = if is_for_loop then
                    CStmtFor([], None, [], body_stmt, kloc)
                else
                    CStmtWhile(cc, loop_stmt, kloc)
            in
            (false, dummy_exp, loop_stmt :: ccode)
        | KExpDoWhile(body, c, _) ->
            let _ = new_block_ctx BlockKind_Loop sc kloc in
            let (e, body_code) = kexp2cexp body (ref None) [] sc in
            let (cc, cc_code) = kexp2cexp c (ref None) [] in
            let (is_for_loop, check_code) =
                match (cc, cc_code) with
                | (CExp(CExpLit(LitBool(true), _)), []) -> (true, [])
                | (_, []) -> (false, [])
                | _ ->
                    let cc_loc = get_cexp_loc cc in
                    let not_cc = CExpUnOp(COpLogicNot, cc, (CTypBool, cc_loc)) in
                    let break_stmt = gen_break_continue_stmt cc_loc in
                    let check_cc = CStmtIf(not_cc, break_stmt, CStmtNop(cc_loc), cc_loc) in
                    (true, check_cc :: cc_code)
                in
            let body_code = check_code :: body_code in
            let body_stmt = finalize_loop_body body_code kloc in
            let loop_stmt = if is_for_loop then
                    CStmtFor([], None, [], body_stmt, kloc)
                else
                    CStmtDoWhile(loop_stmt, cc, kloc)
            in
            (false, dummy_exp, loop_stmt :: ccode)
        | KExpCCode(ccode_str, _) ->
            (false, CExpCCode(ccode_str, kloc), ccode)
        | KDefVal(i, e1, _) -> raise_compile_err kloc "cgen: unsupported KDefVal"
            (*
                * if e1/i has complex type:
                    ** generate "type i={};",
                    ** add it to prologue, add destuctor to cleanup.
                    ** set dstid = i
                * otherwise dstid = noid
                convert e1 to cexp. if e1/i has simple type, then do "some_type i = e1;"
                (otherwise during the conversion the result of e1 will automatically be stored to dstid)
            *)
        | KDefFun kf -> raise_compile_err kloc "cgen: unsupported KDefFun"
            (*
                generate new context.
                generate ccode for the body with dstid=fx_result.
                after cleanup section add "return fx_status;"
                check the case of 'c code' body
            *)
        | KDefExn ke -> raise_compile_err kloc "cgen: unsupported KDefExn"
            (*
                should generate constructor in the case of exception with argument(s) (TBD).
            *)
        | KDefVariant kvar -> (false, dummy_exp, ccode) (* handled in c_gen_types *)
        | KDefTyp kt -> (false, dummy_exp, ccode) (* handled in c_gen_types *)
        | KDefClosureVars kcv -> raise_compile_err kloc "cgen: unsupported KDefClosureVars"
            (* TBD *)
    in ...

let convert_to_c top_code =
    let c_types_ccode = C_gen_types.convert_all_typs top_code in
