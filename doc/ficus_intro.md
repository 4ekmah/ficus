# Ficus Intro

Ficus is a quite simple (but not simpler) functional language with many of the modern features that should make it suitable for efficient processing of multi-dimensional arrays of numbers or hierarhical tree-like data structures. In other words, for AI.

## Essential Ficus Features

Here are the essential features that are planned for Ficus 1.0:
  - [x] C/C++-style syntax. It's similar to C/C++, Java, JS, Swift etc. programming languages. That is, we use the same expression syntax and semantics (including the type coercion rules), curly braces for code blocks and structures, mostly the same keywords, same single-line and block comments.
  - [x] Since this is a functional language, *everything is expression*. However, there is no currying, like in OCaml or Haskell, and the syntax is a bit closer to the popular imperative languages, such as C/C++, Python or Matlab. That is, instead of "f arg1 arg2 ..." we use "f(arg1, arg2, ...)" notation.
  - [x] Just like in many modern languages, in the end of each expression ';' may be skipped, unless it separates two expressions on the same line.
  - [x] Automatic memory management; the current implementation of Ficus uses automatic reference counting (*ARC*, or simply *RC*) with various optimizations. Comparing to the full-scale Garbage Collectors (*GC*), ARC let us reduce the runtime overhead and make the apps less memory-hungry and more cache-friendly. It's also makes interaction with 3rd-party C libraries and the inline C code (see further) much simpler.
  - [x] Type safety and strict compile-time type checking with partial type inference. Because of this feature, Ficus is both type-safe, very efficient and yet not very verbose. The language does not use "type boxing", that is, no any meta-information about the data types is stored. For example, a single-precision floating-point number (`float`) takes 4 bytes, the tuple (`uint8`, `uint8`, `uint8`) takes 3 bytes, the record `point { x: int, y: int }` takes 8 bytes on 32-bit machine and 16 bytes on 64-bit machine. Overall, the data representation model and the language semantics potentially enable many compile-time optimizations that could be difficult to implement in the case of dynamic languages, such as Python or Javascript, even with a tracing JIT.
  - [WIP] Memory safety. Ficus does not only manages memory buffers automatically, it also checks indices for the proper value ranges when accessing arrays, which makes various memory access problems much easier to catch and fix. Special optimizations are applied to eliminate unnecessary range checks when arrays are accessed sequentially (in this case the checks are moved outside of the loop).
  - [ ] Multi-threading support, which includes:
    * reenterable C code, generated by Ficus compiler. Compiler does not generates read-write data structures accessible from multiple threads, unless user explicitly defines such structures (e.g. mutable variables at the global module scope, or arrays that are shared between threads).
    * (*planned*) atomic operations are used for ARC by default, however some heuristics are used to reduce the number of such operations.
    * (*planned*) standard low-level data structures, such as `Mutex.t`, with cross-platform API and platform-dependent implementation that help to synchronize access to shared data and to implement higher-level threading API.
    * (*planned*) `parallel for` operator with platform-dependent implementation that makes it easy to distribute heavy data-parallel tasks across multiple cores. With `parallel for` and `Mutex.t` it's also possible to implement a popular *map-reduce* paradigm.
    * (*planned*) asynchronous execution of I/O operations and computationally-extensive tasks.
    * (*planned*) co-routines to enable light-weight threading without associated OS overhead on switching between the threads and their scheduling.
  - [x] Rich set of primitive data types: 8-, 16-, 32-, 64-bit signed and unsigned integers, 32- and 64-bit floating-point values (16-bit floating-point type will eventually be added as well), bool, char. In other words, matrices, images, audio data, tensors and other massive data arrays can be represented in the most optimal way.
  - [WIP] Native `string` type and good Unicode support.
  - [x] Tuples and records. They are efficient (equally efficient) data types, allocated on stack with no any extra overhead (i.e. no tags, dictionaries of keys etc.)
  - [x] Native support for multi-dimensional dense arrays. Many modern languages represent 2D arrays as arrays of arrays. Thus, 4D arrays, which are essential data structures in Deep Learning, would need arrays of arrays of arrays of arrays, which is very inefficient. Of course, it's possible to represent multi-dimensional arrays using 1D arrays and on each access transform N-D index into the "raw" 1D index, but it's both inconvenient and error-prone, e.g. out-of-range 4D index, when converted to a raw index, may be a within-range value. Instead, Ficus offers full support for multi-dimensional arrays, including convenient access to individual elements, as well as sub-arrays, just like in Python+numpy:

        // create 1920x1080 image containing 3-tuples and initialize it with 0's
        val myimg = array((1080, 1920), (0u8, 0u8, 0u8))
        val (top, left, bottom, right) = (20, 10, 50, 100)
        // invert the ROI
        myimg[top:bottom, left:right] ^= array((bottom-top, right-left),
                                               (255u8, 255u8, 255u8))

  - [x] Decent support for the functional programming, including:
    * immutable values by default. For example, after some value `y` is initialized `val y = f(x)`, it cannot be changed further. Defining mutable values is also possible, but the compiler performs more optimizations on immutable values.
    * first-class functions (i.e. nested functions and anonymous *lambda* functions can be freely passed and returned by functions; closures are formed when necessary)
    * recursion is handled efficiently, tail recursion is always converted into a loop, even in *DEBUG* mode.
    * key (immutable) functional data structures: *single-connected lists*, *algebraic data types* (a.k.a. *sum types* or *variants*). Later on, it's planned to add more efficient modern immutable data structures, such as immutable vectors or immutable hash tables.
    * functional-style pattern matching, which can be used to analyze, decompose and process lists, tuples, records, variants etc.
  - [x] Exception-based error handling. New exceptions are very easy to define (with just a single line of code), and the pattern matching is used to handle exceptions.
  - [x] Array and list comprehensions. Those are special constructs, similar to Python and F# list comprehensions, that let user to apply classical higher-order functions (map, filter, reduce) to arrays and lists (and to the user-defined containers as well, such as dictionaries, in the future versions of Ficus), i.e. implement data processing algorithms in a functional style.
  - [x] Good support for imperative programming. Ficus is not a purely  functional language. It includes:
    * Variables (`var`, a mutable counterpart of `val`, slightly less efficient, but sometimes a very useful one). When a record or a tuple is a variable, its elements can be modified as well.
    * References (immutable pointers to mutable values). They mimic OCaml and F# references.
    * Arrays, which are also mutable data structures, so they are efficient. However, neither dimensionality, shape (number of elements along each axis) nor element type of each instance of array can be changed after it has been created.
    * `for`, `while` and `do-while` loops, `break` and `continue` operators etc.
  - [x] Generic programming, a.k.a. Parametric Polymorphism. Generic data stuctures and functions (a.k.a. templates) can be defined to avoid code duplication. By the way, Ficus does not offer a macro facility, but one can preprocess Ficus source code using `cpp` preprocessor (since Ficus syntax does not use `#` symbol and the overal lexical structure is more or less compatible with C)
  - [x] Function and operator overloading, a.k.a. Ad-hoc Polymorphism. In other words, functions and operators are not only diffirentiated by their names and the lexical scope, but also by the number of arguments and their types. Generic programming together with overloading let users to create a reusable code that automatically adapts to the processed data type.
  - [WIP] Modules. We mostly follow Python in this part, i.e. there are `import modname1, modname2 as nickname2, ...` and `from modname1 import f1, f2; from modname2 import *` constructs. However, unlike Python, Ficus does not support dynamic import of the modules. Import directives are processed by the compiler, and the final program or library is formed out of a collection of modules. If a certain module contains some initialization code, it is executed after all the module dependencies (i.e. the other modules it depends on) have been initialized. Compile-time handling of "import" directives let us to completely eliminate any overhead of calling some function from another module; it's as fast as if the called and the caller functions were in the same module. Inline function expansion across modules is also possible.
  - [ ] Object-oriented programming. It's very useful concept that helps to create good, reusable frameworks and build apps out of those frameworks. The classical OOP paradigm is based on 3 principles:
    * incapsulation
    * inheritance
    * polymorphism

    Without any doubt, the first and the last principles are widely used everywhere, including the standard C++ library. However, votes are split about the inheritance. In pursuit of minimalism, simplicity of implementation and the decent performance, it's planned that Ficus 1.0 will provide incapsulation and polymorphism, as well as inheritance of interfaces. However, inheritance of implementations will not be supported. That is, Ficus will introduce *classes* (and objects, as their instances) and *interfaces* (a.k.a. protocols). An interface may define some types and function prototypes. A class may then implement zero or more interfaces, as well as add some members and extra methods that do not belong to any interface. An interface can actually inherit from another interface, so inheritance is party supported as well, but only at interface level, not the implementation level. Such approach automatically makes all classes "final", and all the method calls can be automatically inlined (unless we pass an interface as argument to some function instead of a particular class, and then the function calls some method of the interface - in this case we cannot figure out the concrete implementation at compile time, so we will use a table of virtual methods). Classes, which do not implement any interfaces, do not need any virtual tables, they are as light-weight as tuples containing all the class members.
  - [WIP] Very smooth interaction with C/C++. First of all, Ficus compiler generates C
  code instead of machine code. By doing that we seriously reduce the effort of implementing efficient and portable Ficus compiler. We also let user to implement functions right in C (or C++):

        ccode "#include <math.h>"
        nothrow pure inline fun sin(x: float): float = ccode "return sinf(x);"

    That is, just like C compilers let users to put in some inline assembly code, we let users to put in some inline C (or C++) code :) It makes implementation of some standard library functions, as well as adding bindings for 3rd-party C/C++ libraries a very simple task. The generated by Ficus compiler C sources can be combined with other C/C++ modules to form the final app or component.
  - [ ] Self-hosting compiler. Currently, Ficus has been implemented in a subset of OCaml, however, the compiler source code should be converted to Ficus by v1.0. When it's done, it should be enough to have a `C` compiler and `make` utility to compile a fresh version of Ficus. It will also be a good regression test for a big portion of the compiler, and finally some proof of the language versatality.

**[TODO] Cover separate compilation, REPL and the upcoming standard library.**
