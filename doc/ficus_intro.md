# Ficus Intro

Ficus is a quite simple (but not simpler) functional language with many of the modern features that should make it suitable for intensive processing of numeric arrays or hierarhical tree-like data structures. In other words, for AI.

## Essential Ficus Features

Here are the essential features that are planned for Ficus 1.0:
  - [x] C/C++-style syntax. It's similar to C/C++, Java, JS, Swift etc. programming languages. That is, we use the same expression syntax and semantics (including the type coercion rules), curly braces for code blocks and structures, mostly the same keywords, same single-line and block comments (even though `/* */` can be nested).
  - [x] Since this is a functional language, *everything is expression*. However we made it more familar to the users of popular imperative languages, such as C/C++, Python or Matlab, meaning that instead of "f arg1 arg2 ..." we use "f(arg1, arg2, ...)" notation.
  - [x] Just like in many modern languages, in the end of each expression ';' may be skipped, unless it separates two expressions on the same line.
  - [x] Automatic memory management; the current implementation of Ficus uses automatic reference counting (*ARC*, or simply *RC*) with various optimizations to reduce unncessary increments/decrements, and also to avoid atomic operations whenever possible. Comparing to the full-scale Garbage Collectors (*GC*), ARC let us reduce the runtime overhead (especially the sudden pauses incurred by some not very sophisticated GC algorithms) and make the apps less memory-hungry and more cache-friendly. It's also makes interaction with 3rd-party C libraries and the inline C code (see further) much simpler.
  - [x] Type safety and strict compile-time type checking with partial type inference. Because of this feature, Ficus is both type-safe, very efficient and yet not very verbose. No "type boxing" is used at runtime, that is, no any meta-information about the data type is stored. For example, a single-precision floating-point number (`float`) takes 4 bytes, the tuple (`uint8`, `uint8`, `uint8`) takes 3 bytes, the record `point { x: int, y: int }` takes 8 bytes on 32-bit machine and 16 bytes on 64-bit machine. Such efficient representation and strict compile-time type checking potentially enables many compile-time optimizations that are very difficult to implement in the case of dynamic languages, such as Python or Javascript, even with a tracing JIT.
  - [x] Memory safety. Ficus does not only manages memory buffers automatically, it also checks indices for the proper value ranges when accessing arrays, which makes various memory access problems much easier to catch and fix. Special optimizations are applied to eliminate unnecessary range checks when arrays are accessed sequentially (in this case the checks are moved outside of the loop).
  - [±] Multi-threading support, which includes:
    * reenterable C code, generated by Ficus compiler. Compiler does not generates read-write data structures accessible from multiple threads, unless user explicitly defines such structures (e.g. mutable variables at the global module scope, or arrays that are shared between threads).
    * atomic operations used for ARC, even though Ficus compiler avoids use of atomic operations when a data structure is allocated, used and then deallocated in the same thread.
    * standard low-level data structures, such as `Mutex.t`, with cross-platform API and platform-dependent implementation that help to synchronize access to shared data and to implement higher-level threading API.
    * (*planned*) `parallel for` operator with platform-dependent implementation that makes it easy to distribute heavy data-parallel tasks across multiple cores. With `parallel for` and `Mutex.t` it's also possible to implement a popular *map-reduce* paradigm.
    * (*planned*) asynchronous execution of I/O operations and computationally-extensive tasks.
    * (*planned*) co-routines to enable light-weight threading without associated OS overhead on switching between the threads and their scheduling.
  - [x] Rich set of primitive data types: 8-, 16-, 32-, 64-bit signed and unsigned integers, 32- and 64-bit floating-point values (16-bit floating-point type will eventually be added as well), bool, char. In other words, matrices, images, audio data, tensors and other massive data arrays can be represented in the most optimal way.
  - [±] Native `string` type and good Unicode support.
  - [x] Tuples and records. At compile-time records are converted to tuples. They are allocated on stack and there is no any extra overhead (i.e. no tags, dictionaries of keys etc.)
  - [x] Native support for multi-dimensional dense arrays. Many modern languages represent 2D arrays as arrays of arrays. Thus, 4D arrays, which are essential data structures in Deep Learning, would need arrays of arrays of arrays of arrays, which is very inefficient. Of course, it's possible to represent multi-dimensional arrays using 1D arrays and on each access transform N-D index into the "raw" 1D index, but it's both inconvenient and error-prone, e.g. out-of-range 4D index, when converted to a raw index, may be a within-range value. Instead, Ficus offers full support for multi-dimensional arrays, including convenient access to individual elements, as well as sub-arrays, just like in Python+numpy:

        // create 1920x1080 image containing 3-tuples and initialize it with 0's
        val myimg = array((1080, 1920), (0u8, 0u8, 0u8))
        val (top, left, bottom, right) = (20, 10, 50, 100)
        // invert the ROI
        myimg[top:bottom, left:right] ^= array((bottom-top, right-left),
                                               (255u8, 255u8, 255u8))

  - [x] Decent support for the functional programming, including:
    * immutable values by default. For example, after some value `y` is initialized `val y = f(x)`, it cannot be changed further. Defining mutable values is also possible, but the compiler performs more optimizations on immutable values.
    * first-class functions (i.e. nested functions and anonymous *lambda* functions can be freely passed and returned by functions; closures are formed when necessary)
    * recursion is handled efficiently, tail recursion is always converted into a loop, even in *DEBUG* mode.
    * key (immutable) functional data structures: *single-connected lists*, *algebraic data types* (a.k.a. *sum types* or *variants*). Later on, it's planned to add more efficient modern immutable data structures, such as immutable vectors or immutable hash tables.
    * functional-style pattern matching, which can be used to analyze, decompose and process lists, tuples, records, variants etc.
  - [x] Exception-based error handling. New exceptions are very easy to define (with just a single line of code), and the pattern matching is used to handle exceptions.
  - [x] Array and list comprehensions. Those are special constructs, similar to Python and F# list comprehensions, that let user to apply classical higher-order functions (map, filter, reduce) to arrays and lists (and to the user-defined containers as well, such as dictionaries, in the future versions of Ficus), i.e. implement data processing algorithms in a functional style.
  - [x] Good support for imperative programming. Ficus is not a purely  functional language. It includes:
    * Variables (`var`, a mutable counterpart of `val`, slightly less efficient, but sometimes a very useful one). When a record or a tuple is a variable, its elements can be modified as well.
    * References (immutable pointers to mutable values). They mimic OCaml and F# references.
    * Arrays, which are also mutable data structures, so they are efficient. However, neither dimensionality, shape (number of elements along each axis) nor element type of each instance of array can be changed after it has been created.
    * `for`, `while` and `do-while` loops, `break` and `continue` operators etc.
  - [x] Generic programming, a.k.a. Parametric Polymorphism. Generic data stuctures and functions (a.k.a. templates) can be defined to avoid code duplication. By the way, Ficus does not offer a macro facility, but one can preprocess Ficus source code using `cpp` preprocessor (since Ficus syntax does not use `#` symbol and the overal lexical structure is more or less compatible with C)
  - [x] Function and operator overloading, a.k.a. Ad-hoc Polymorphism. In other words, functions and operators are not only diffirentiated by their names and the lexical scope, but also by the number of arguments and their types. Generic programming together with overloading let users to create a reusable code that automatically adapts to the processed data type.
  - [±] Modules. We mostly follow Python in this part, i.e. there are `import modname1, modname2 as nickname2, ...` and `from modname1 import f1, f2; from modname2 import *` constructs. However, unlike Python, Ficus does not support dynamic import of the modules. Import directives are processed by the compiler, and the final program or library is formed out of a collection of modules. If a certain module contains some initialization code, it is executed after all the module dependencies (i.e. the other modules it depends on) have been initialized. Compile-time handling of "import" directives let us to completely eliminate any overhead of calling some function from another module; it's as fast as if the called and the caller functions were in the same module. Inline function expansion across modules is also possible.
  - [ ] Object-oriented programming. It's very useful concept that helps to create good, reusable frameworks and build apps out of those frameworks. The classical OOP paradigm is based on 3 principles:
    * incapsulation
    * inheritance
    * polymorphism

    Without any doubt, the first and the last principles are widely used everywhere, including the standard C++ library. However, votes are split about the inheritance. In pursuit of minimalism, simplicity of implementation and the decent performance, it's planned that Ficus 1.0 will provide incapsulation and polymorphism, as well as inheritance of interfaces. However, inheritance of implementations will not be supported. That is, Ficus will introduce *classes* (and objects, as their instances) and *interfaces* (a.k.a. protocols). An interface may define some types and function prototypes. A class may then implement zero or more interfaces, as well as add some members and extra methods that do not belong to any interface. An interface can actually inherit from another interface, so inheritance is party supported as well, but only at interface level, not the implementation level. Such approach automatically makes all classes "final", and all the method calls can be automatically inlined (unless we pass an interface as argument to some function instead of a particular class, and then the function calls some method of the interface - in this case we cannot figure out the concrete implementation at compile time, so we will use a table of virtual methods). Classes, which do not implement any interfaces, do not need any virtual tables, they are as light-weight as tuples containing all the class members.
  - [x] Very smooth interaction with C/C++. First of all, Ficus compiler generates C
  code instead of machine code. By doing that we seriously reduce the effort of implementing efficient and portable Ficus compiler. We also let user to implement functions right in C (or C++):

        ccode "#include <math.h>"
        nothrow pure inline fun sin(x: float): float = ccode "return sinf(x);"

    That is, just like C compilers let users to put in some inline assembly code, we let users to put in some inline C (or C++) code :) It makes implementation of some standard library functions, as well as adding bindings for 3rd-party C/C++ libraries a very simple task. The generated by Ficus compiler C sources can be combined with other C/C++ modules to form the final app or component.
  - [ ] Self-hosting compiler. Currently, Ficus has been implemented in a subset of OCaml, however, the compiler source code should be converted to Ficus by v1.0. When it's done, it should be enough to have a `C` compiler and `make` utility to compile a fresh version of Ficus. It will also be a good regression test for a big portion of the compiler, and finally some proof of the language versatality.

**[TODO] Cover separate compilation, REPL and the upcoming standard library.**

## Ficus vs. Other Languages

Let's overview the currently available solutions for AI apps. For example, consider *OCaml*. It's elegant, very robust language that is used for some critical projects (in terms of required robustness). It demonstrates very good performance when processing complex hierarchical data structures, thanks to its static typing, efficient compiler and very efficient memory manager. We want something similar, but tailored for parallel array processing. And something more familar to C/C++ users. *Kotlin* and *Swift* can be used as examples of such modern functional or semi-functional languages that use more conventional syntax and modern technologies. So, we want Ficus to be similar to them as well. Then the obvious question arises - why not just take one of those languages? The answer is that the above-mentioned languages provide many of the desured features, but not all of them, and in general they are quite similar to each other (here is a very nice comparison: http://nilhcem.com/swift-is-like-kotlin/) and mostly suited for implementation of enterprise apps, whereas Ficus' primary focus is on data crunching, top performance and compatibility with C/C++; basically, Ficus project has quite an ambitious goal to replace C/C++ and Python for AI apps, where the 2 languages dominate currently.

Here is brief comparison of the languages (where in the Ficus column we put the planned but not yet implemented features :) ):

|   | Ficus  | Kotlin  | Swift  | OCaml | F#  | C++ | Python |
|---|---|---|---|---|---|--|--|
| syntax  | C-style | C-style | C-style  | ML-style  | ML-style  | C-style | Python-style |
| paradigms | functional, imperative, OOP | funcional, imperative, OOP | functional, imperative, OOP | functional, imperative, OOP | functional, imperative, OOP | imperative, OOP, partly functional | functional, imperative, OOP |
| multi-threading  | +  | +  | +  | –  | + | + | ± (GIL) |
| memory management  | ARC  | GC  | ARC | GC  | GC  | manual, ARC via stdlib | ARC |
| safe | + | + | + | + | + | – | + (but heavily relies on runtime checks) |
| [projected] performance of array processing algorithms | excellent | good | good | good with int's, fair with float's | very good | excellent | poor (needs C++ kernels for good speed), better with Cython and PyPy |
| interface to C | embedded | easy in native mode, unknown in JVM mode | easy | possible | possible | embedded | possible (easier with Cython) |
| real multi-dimensional arrays | + (embedded into the language and compiler) | nested 1D arrays | nested 1D arrays | nested 1D arrays | nested 1D arrays | via 3d-party libs | + (via numpy) |
| runtime footprint (which affects the use on *edge* devices) | tiny | v. big - JVM (or smaller with LLVM - w.i.p) | big, but smaller than JVM | small | .NET (v. big) | normally small; depends on the framework used | relatively small |
| std lib | looong way to go, but easy to connect 3rd-party C/C++ libs | excellent on JVM | excellent on Apple platforms; v. good on others | very good | excellent on MS platforms | v. good + many 3rd-party libs | excellent + myriads of 3rd-party libs |
| numerical lib | looong way to go, but some basic algorithms are embedded into the language or are very easy to implement | + (Koma) | + (w.i.p, Fast AI etc.) | ± | + | OpenCV and such | fantastic! (numpy, scipy + many ML/AI frameworks) |
| implemented in itself? | TBD (for now we are using OCaml) | + | – (C++) | + | – (C#) | + | ± (CPython is implemented in C, PyPy is implemented in Python) |
| REPL (interactive mode) | – (planned in 2.0) | – | + | + | + | – | + |
